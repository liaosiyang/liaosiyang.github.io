<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Be Level5 Coder</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-15T14:51:46.251Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android笔记-Retrofit</title>
    <link href="http://yoursite.com/2016/08/15/Android%E7%AC%94%E8%AE%B0-Retrofit/"/>
    <id>http://yoursite.com/2016/08/15/Android笔记-Retrofit/</id>
    <published>2016-08-15T13:47:57.000Z</published>
    <updated>2016-08-15T14:51:46.251Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/faf2b2119313b07eb36f89b10dd7912396dd8cbd.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h1><p>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是 Retrofit 来完成的。 Retrofit 2.0 开始内置 OkHttp ，前者专注于接口的封装，后者专注于网络请求的高效，二者分工协作。</p>
<p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。<br><a href="http://blog.igevin.info/posts/restful-architecture-in-general/" target="_blank" rel="external">RESTful 架构风格概述</a></p>
<p>我们的应用程序通过 Retrofit 请求网络，实际上是使用 Retrofit 接口层封装请求参数、Header、Url 等信息，之后由 OkHttp 完成后续的请求操作，在服务端返回数据之后， OkHttp 将原始的结果交给 Retrofit ，后者根据用户的需求对结果进行解析的过程。</p>
<h1 id="Retrofit-的基本用法"><a href="#Retrofit-的基本用法" class="headerlink" title="Retrofit 的基本用法"></a>Retrofit 的基本用法</h1><p>访问 GitHub 的 api，就定义一个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">    Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>其中，在发起请求时， {user} 会被替换为方法的第一个参数 user 。</p>
<p>构造 Retrofit：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">.baseUrl(<span class="string">"https://api.github.com/"</span>)</div><div class="line">.build();</div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure><br>发送请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</div></pre></td></tr></table></figure><br>repos 其实并不是真正的数据结果，它更像一条指令，你可以在合适的时机去执行它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步调用</span></div><div class="line">List&lt;Repo&gt; data=repos.execute();</div><div class="line"></div><div class="line"><span class="comment">//异步调用</span></div><div class="line">repos.enquene(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Reps&gt;&gt; response)</span></span>&#123;</div><div class="line">               List&lt;Reps&gt; data=response.body();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call,Throwable t)</span></span>&#123;</div><div class="line">               t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>  </p>
<h2 id="Url-配置"><a href="#Url-配置" class="headerlink" title="Url 配置"></a>Url 配置</h2><p>Retrofit 支持的协议包括 GET / POST / PUT / DELETE / HEAD / PATCH ，当然你也可以直接用 HTTP 来自定义请求。这些协议均以注解的形式进行配置。</p>
<h2 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h2><p>发请求时，需要传入参数， Retrofit 通过注解的形式令 Http 请求的参数变得更加直接，而且类型安全。</p>
<h2 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h2><p>Retrofit 允许我们自己定义入参和返回的类型，不过，如果这些类型比较特别，我们还需要准备相应的 Converter，也正是因为 Converter 的存在， Retrofit 在入参和返回类型上表现得非常灵活。</p>
<h1 id="Retrofit-原理"><a href="#Retrofit-原理" class="headerlink" title="Retrofit 原理"></a>Retrofit 原理</h1><h2 id="接口请求的处理"><a href="#接口请求的处理" class="headerlink" title="接口请求的处理"></a>接口请求的处理</h2><p>Retrofit 创建的一个代理对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">        eagerlyValidateMethods(service);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></div><div class="line">        <span class="keyword">throws</span> Throwable &#123;</div><div class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">                <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">                    <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">                    <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">                &#125;</div><div class="line">                ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">                OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">                <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>在我们调用 GitHubService.listRepos 时，实际上调用的是这里的 InvocationHandler.invoke 方法。</p>
<h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h2><p>Retrofit 为我们构造了一个 OkHttpCall ，实际上每一个 OkHttpCall 都对应于一个请求，它主要完成最基础的网络请求，而我们在接口的返回中看到的 Call 默认情况下就是 OkHttpCall 了，如果我们添加了自定义的 callAdapter ，那么它就会将 OkHttp 适配成我们需要的返回值，并返回给我们。</p>
<p>Call 的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;  </div><div class="line">    <span class="comment">//同步发起请求</span></div><div class="line">    <span class="function">Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </div><div class="line">    <span class="comment">//异步发起请求，结果通过回调返回</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;  </div><div class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">//返回原始请求</span></div><div class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>前面repos 其实就是一个 OkHttpCall 实例， execute 就是要发起网络请求。</p>
<p>OkHttpCall.execute：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">okhttp3.Call call;</div><div class="line"></div><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</div><div class="line">  executed = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</div><div class="line">      <span class="keyword">throw</span> (IOException) creationFailure;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">throw</span> (RuntimeException) creationFailure;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  call = rawCall;</div><div class="line">  <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      call = rawCall = createRawCall();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</div><div class="line">      creationFailure = e;</div><div class="line">      <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (canceled) &#123;</div><div class="line">  call.cancel();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> parseResponse(call.execute());</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>OkHttpCall 其实也是封装了 okhttp3.Call。<br>parseResponse 主要完成了由 okhttp3.Response 向 retrofit.Response 的转换，同时也处理了对原始返回的解析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    <span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ResponseBody rawBody = rawResponse.body();    </div><div class="line"></div><div class="line">    <span class="comment">//略掉一些代码</span></div><div class="line">    <span class="keyword">try</span> &#123;      </div><div class="line">    <span class="comment">//在这里完成了原始 Response 的解析，T 就是我们想要的结果，比如 GitHubService.listRepos 的 List&lt;Repo&gt;</span></div><div class="line">        T body = serviceMethod.toResponse(catchingBody);      </div><div class="line">        <span class="keyword">return</span> Response.success(body, rawResponse);</div><div class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;      </div><div class="line">        <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></div><div class="line">        <span class="comment">// a runtime exception.</span></div><div class="line">        catchingBody.throwIfCaught();      </div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="适配RxJava"><a href="#适配RxJava" class="headerlink" title="适配RxJava"></a>适配RxJava</h2><p>只需要提供一个 Adapter，将 OkHttpCall 转换为 Observable 即可。 Retrofit 的开发者们早就想到了这个问题，并且为我们提供了相应的 Adapter：RxJavaCallAdapterFactory<br>我们只需要在构造 Retrofit 时，添加它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div></pre></td></tr></table></figure><br>这样我们的接口就可以以 RxJava 的方式工作了。</p>
<p>同样，还可以添加Gson,将网络传输回的数据直接转化成Java类的形式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addConverterFactory(GsonConverterFactory.create())</div></pre></td></tr></table></figure></p>
<p>参考资料：<br><a href="http://www.tuicool.com/articles/bIFvIfY" target="_blank" rel="external">深入浅出 Retrofit，这么牛逼的框架你们还不来看看？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/faf2b2119313b07eb36f89b10dd7912396dd8cbd.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-RxJava</title>
    <link href="http://yoursite.com/2016/08/15/Android%E7%AC%94%E8%AE%B0-RxJava/"/>
    <id>http://yoursite.com/2016/08/15/Android笔记-RxJava/</id>
    <published>2016-08-15T12:20:05.000Z</published>
    <updated>2016-08-15T13:44:17.063Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/1920x1080_4be7f3a22d45ffe.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="RxJAVA"><a href="#RxJAVA" class="headerlink" title="RxJAVA"></a>RxJAVA</h1><p>RxJava算得上是我最喜欢的开源库了。以前在项目中使用异步是个很头疼的问题，来回回调，互相嵌套，往往让代码可读性变的很差。RxJava的出现算是解决了这个问题，一开始使用的时候还不觉得什么，用多了就发现这个开源库真心牛逼。它不仅仅是取代了AsyncTask,Handler等，而且还有一些实用的衍生产品。<br><br></p>
<h1 id="什么是Rx"><a href="#什么是Rx" class="headerlink" title="什么是Rx"></a>什么是Rx</h1><p>Rx就是一种响应式编程，来创建基于事件的异步程序。<br><br></p>
<h1 id="RxJava是什么"><a href="#RxJava是什么" class="headerlink" title="RxJava是什么"></a>RxJava是什么</h1><p>RxJava就是一种用Java语言实现的响应式编程，来创建基于事件的异步程序。<br><br></p>
<h1 id="扩展的观察者模式"><a href="#扩展的观察者模式" class="headerlink" title="扩展的观察者模式"></a>扩展的观察者模式</h1><p>RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。</p>
<p>观察者（Observer）需要在被观察者(Observable)变化的一瞬间做出反应。<br>而两者通过注册（Register）或者订阅(Subscribe)的方式进行绑定。<br><br></p>
<h2 id="RxJava-的观察者模式"><a href="#RxJava-的观察者模式" class="headerlink" title="RxJava 的观察者模式"></a>RxJava 的观察者模式</h2><p>RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。</p>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。<br><br></p>
<h1 id="如何实现RxJava"><a href="#如何实现RxJava" class="headerlink" title="如何实现RxJava"></a>如何实现RxJava</h1><p><br></p>
<h2 id="创建Observer"><a href="#创建Observer" class="headerlink" title="创建Observer"></a>创建Observer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Observer</span></div><div class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"onNext ---&gt; "</span>, <span class="string">"Item: "</span> + s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"onCompleted ---&gt; "</span>, <span class="string">"完成"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"onError ---&gt; "</span>, e.toString());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>  
<p>在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。</p>
<p>Subscriber跟Observer接口几乎完全一样，只是多了两个方法：</p>
<ul>
<li>onStart(): 它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。</li>
<li>unsubscribe(): 用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</li>
</ul>
<p><br></p>
<h2 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h2><p>Observable是通过 create() 方法来创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Observable</span></div><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"World"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>  
<p><br></p>
<h2 id="订阅（Subscribe）"><a href="#订阅（Subscribe）" class="headerlink" title="订阅（Subscribe）"></a>订阅（Subscribe）</h2><p>在之前，我们创建了 Observable 和 Observer ，现在就需要用 subscribe() 方法来将它们连接起来，形成一种订阅关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//订阅</span></div><div class="line">observable.subscribe(observer);</div></pre></td></tr></table></figure>  
<p><br></p>
<h1 id="线程控制——Scheduler"><a href="#线程控制——Scheduler" class="headerlink" title="线程控制——Scheduler"></a>线程控制——Scheduler</h1><p>在RxJava中，Scheduler相当于线程控制器，可以通过它来指定每一段代码运行的线程。</p>
<ul>
<li>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。</li>
<li>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</li>
<li>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。</li>
<li>Schedulers.computation(): 计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li>AndroidSchedulers.mainThread()，Android专用线程，指定操作在主线程运行。</li>
</ul>
<p>RxJava中提供了两个方法：subscribeOn() 和 observeOn() 切换线程，两者的不同点在于：</p>
<ul>
<li>subscribeOn(): 指定subscribe()订阅所发生的线程，即 call() 执行的线程。或者叫做事件产生的线程。</li>
<li>observeOn(): 指定Observer所运行在的线程，即onNext()执行的线程。或者叫做事件消费的线程。</li>
</ul>
<p><br></p>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>RxJava中有大量的操作符，比如创建操作符、变换操作符、过滤操作符等等。</p>
<p><br></p>
<h2 id="Observable-just"><a href="#Observable-just" class="headerlink" title="Observable.just()"></a>Observable.just()</h2><p>Just操作符是创建一个将参数依次发送出来的Observable。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/2046763-6c0e1adc83123ed6.png" alt="Image"><br><br></p>
<h2 id="Observable-from"><a href="#Observable-from" class="headerlink" title="Observable.from()"></a>Observable.from()</h2><p>将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/2046763-38826a6ab94d1cd9.png" alt="Image"><br><br></p>
<h2 id="Observable-create"><a href="#Observable-create" class="headerlink" title="Observable.create()"></a>Observable.create()</h2><p>create()方法创建了一个Observable，且在这个Observable中有个OnSubscribe。</p>
<p><br></p>
<h2 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe()"></a>subscribe()</h2><p>这个是将观察者（Observer）与被观察者(Observable)联系到一起的操作，也就是产生一种订阅(Subcribe)关系。</p>
<ul>
<li>首先创建过程也就是create()方法中创建了一个Observable，并有一个onSubscribe属性；</li>
<li>其次在订阅过程也就是subscribe()方法中，调用了create()方法中创建的Observable的onSubscribe属性的call方法；</li>
<li>最后这个call回调的就是代码中创建的Subscriber的onNext/onCompleted/onError方法。</li>
</ul>
<p><br></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map操作符对原始Observable发射的每一项数据应用一个你选择的函数，然后返回一个发射这些结果的Observable。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/map.png" alt="Image"><br>这是一对一的转换，就是一个单独的数据转成另一个单独的数据。<br><br></p>
<h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h2><p>FlatMap操作符使用一个指定的函数对原始Observable发射的每一项数据执行变换操作，这个函数返回一个本身也发射数据的Observable，然后FlatMap合并这些Observables发射的数据，最后将合并后的结果当做它自己的数据序列发射。<br><img src="http://ob5qdb9lc.bkt.clouddn.com/flatmap_2.png" alt="Image"><br>与Map相比较，FlatMap是能进行一对多的转换。</p>
<p><br></p>
<h1 id="FuncX与ActionX"><a href="#FuncX与ActionX" class="headerlink" title="FuncX与ActionX"></a>FuncX与ActionX</h1><p><br></p>
<h2 id="ActionX"><a href="#ActionX" class="headerlink" title="ActionX"></a>ActionX</h2><p>RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。</p>
<ul>
<li>Action0 就是把 onCompleted() 作为参数传入 subscribe() 。</li>
<li>Action1 就是把 onNext() 与 onError() 作为参数传入 subscribe() 。</li>
</ul>
<p><br></p>
<h2 id="FuncX"><a href="#FuncX" class="headerlink" title="FuncX"></a>FuncX</h2><p>FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。</p>
<p><br></p>
<h1 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe"></a>doOnSubscribe</h1><p>RxJava中给我们提供了另外一种操作符： doOnSubscribe ，这个操作符跟onStart方法一样，都是在 subscribe() 方法调用后且事件发送之前 执行，所以我们一样可以在这里面进行初始化的操作。而区别在于它可以指定线程。</p>
<p>默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。</p>
<p>如果在doOnSubscribe()之后指定了subscribeOn()，它决定了doOnSubscribe()在哪种线程中执行。</p>
<ul>
<li>doOnSubscribe()之前的subscribeOn()不会影响它。</li>
<li>doOnSubscribe()之后的subscribeOn()，且是最近的才会影响它。</li>
</ul>
<p><br></p>
<h1 id="doOnNext"><a href="#doOnNext" class="headerlink" title="doOnNext"></a>doOnNext</h1><p>RxJava中给我们提供了一个操作符： doOnNext() ，这个操作符允许我们在每次输出一个元素之前做一些其他的事情，比如提示啊保存啊之类的操作。</p>
<p><br></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上这些只是RxJava最最基本的用法，在我目前的项目中差不多就使用到了这些。其实RxJava包含了很多内容，有这数目众多的操作符和扩展类，官方给出了详细的文档<a href="http://rxjava.yuxingxin.com/" target="_blank" rel="external">RxJava Essentials 中文翻译版</a></p>
<p>参考资料：<br><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a><br><a href="http://www.jianshu.com/p/856297523728" target="_blank" rel="external">大话RxJava</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/1920x1080_4be7f3a22d45ffe.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Android性能优化</title>
    <link href="http://yoursite.com/2016/08/14/Android%E7%AC%94%E8%AE%B0-Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2016/08/14/Android笔记-Android性能优化/</id>
    <published>2016-08-14T13:50:08.000Z</published>
    <updated>2016-08-14T14:39:01.624Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/30721479_1390194907933.jpg" alt="Image"></p>
<a id="more"></a>
<p>看了很多有关Android性能优化的资料，基本上说的点都差不多。异步，内存泄漏，视图布局等等。后来发现原来Google发布了<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">Android性能优化典范的专题</a>。国人也发布了相关的翻译文档，强，无敌！</p>
<p><a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="external">Android性能优化典范 - 第1季</a><br><a href="http://hukai.me/android-performance-patterns-season-2/" target="_blank" rel="external">Android性能优化典范 - 第2季</a><br><a href="http://hukai.me/android-performance-patterns-season-3/" target="_blank" rel="external">Android性能优化典范 - 第3季</a><br><a href="http://hukai.me/android-performance-patterns-season-4/" target="_blank" rel="external">Android性能优化典范 - 第4季</a><br><a href="http://hukai.me/android-performance-patterns-season-5/" target="_blank" rel="external">Android性能优化典范 - 第5季</a></p>
<p>细化与补充：<br><a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇</a><br><a href="http://hukai.me/android-performance-compute/" target="_blank" rel="external">Android性能优化之运算篇</a><br><a href="http://hukai.me/android-performance-memory/" target="_blank" rel="external">Android性能优化之内存篇</a><br><a href="http://hukai.me/android-performance-battery/" target="_blank" rel="external">Android性能优化之电量篇</a><br><a href="http://hukai.me/android-performance-oom/" target="_blank" rel="external">Android内存优化之OOM篇</a></p>
<p>PS:今天Wings夺得TI6总冠军，看到他们从最初的小弟，勤学苦练，最终凭实力问鼎西雅图。原来现实生活中也存在着梦想照进现实的例子。所以呢？努力啊!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/30721479_1390194907933.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Android启动过程</title>
    <link href="http://yoursite.com/2016/08/14/Android%E7%AC%94%E8%AE%B0-Android%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/14/Android笔记-Android启动过程/</id>
    <published>2016-08-14T12:18:37.000Z</published>
    <updated>2016-08-14T14:48:51.293Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/b3b7d0a20cf431adb6bc847b4836acaf2edd9802.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="Android启动过程"><a href="#Android启动过程" class="headerlink" title="Android启动过程"></a>Android启动过程</h1><p>当你按下电源开关后Android设备执行了以下步骤。</p>
<h2 id="启动电源以及系统启动"><a href="#启动电源以及系统启动" class="headerlink" title="启动电源以及系统启动"></a>启动电源以及系统启动</h2><p>当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。</p>
<h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2><p>引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。</p>
<p>设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qibootloader或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运营商加锁和限制的地方。</p>
<p>引导程序分两个阶段执行。</p>
<ol>
<li>检测外部的RAM以及加载对第二阶段有用的程序；</li>
<li>引导程序设置网络、内存等等。</li>
</ol>
<p>这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。</p>
<p>当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</p>
<h2 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h2><p>init是第一个进程，我们可以说它是root进程或者所有进程的父进程。init进程有两个责任，一是挂载目录，比如/sys、/dev、/proc，二是运行init.rc脚本。</p>
<ul>
<li>init进程可以在/system/core/init找到。</li>
<li>init.rc文件可以在/system/core/rootdir/init.rc找到。</li>
</ul>
<p>对于init.rc文件，Android中有特定的格式以及规则。在Android中，我们叫做Android初始化语言。<br>Android初始化语言由四大类型的声明组成，即Actions（动作）、Commands（命令）、Services（服务）、以及Options（选项）。当声明一个Service或者Action时，将隐式声明一个section，它之后跟随的Command或者Option都将属于这个section。另外，Action和Service不能重名，否则忽略为error。</p>
<ul>
<li>Action（动作）：就是在某种情况条件下触发一系列的命令，通常有一个trigger(触发器)。</li>
<li>Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。</li>
<li>Options（选项）：选项是对服务的描述。它们影响init进程如何以及何时启动服务。</li>
<li>Commands(命令)：动作的操作命令。</li>
</ul>
<p>在这个阶段你可以在设备的屏幕上看到“Android”logo了。</p>
<h2 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h2><p>在Java中，我们知道不同的虚拟机实例会为不同的应用分配不同的内存。Android应用应该尽可能快地启动，但如果Android系统为每一个应用启动不同的Dalvik虚拟机实例，就会消耗大量的内存以及时间。</p>
<p>因此，为了克服这个问题，Android系统创造了”Zygote”。Zygote让Dalvik虚拟机共享代码、低内存占用以及最小的启动时间成为可能。</p>
<p>Zygote是一个虚拟器进程，正如我们在前一个步骤所说的在系统引导的时候启动。Zygote预加载以及初始化核心库类。通常，这些核心类一般是只读的，也是Android SDK或者核心框架的一部分。在Java虚拟机中，每一个实例都有它自己的核心库类文件和堆对象的拷贝。</p>
<p>在这个阶段，你可以看到启动动画。</p>
<h2 id="系统服务或服务"><a href="#系统服务或服务" class="headerlink" title="系统服务或服务"></a>系统服务或服务</h2><p>完成了上面几步之后，运行环境请求Zygote运行系统服务。系统服务同时使用native以及java编写，系统服务可以认为是一个进程。同一个系统服务在Android SDK可以以System Services形式获得。系统服务包含了所有的System Services。</p>
<p>Zygote创建新的进程去启动系统服务。<br>核心服务：</p>
<ol>
<li>启动电源管理器；</li>
<li>创建Activity管理器；</li>
<li>启动电话注册；</li>
<li>启动包管理器；</li>
<li>设置Activity管理服务为系统进程；</li>
<li>启动上下文管理器；</li>
<li>启动系统Context Providers；</li>
<li>启动电池服务；</li>
<li>启动定时管理器；</li>
<li>启动传感服务；</li>
<li>启动窗口管理器；</li>
<li>启动蓝牙服务；</li>
<li>启动挂载服务。</li>
</ol>
<h2 id="引导完成"><a href="#引导完成" class="headerlink" title="引导完成"></a>引导完成</h2><p>一旦系统服务在内存中跑起来了，Android就完成了引导过程。在这个时候“ACTION_BOOT_COMPLETED”开机启动广播就会发出去。</p>
<p><br></p>
<h1 id="Activity启动过程"><a href="#Activity启动过程" class="headerlink" title="Activity启动过程"></a>Activity启动过程</h1><p><img src="http://ob5qdb9lc.bkt.clouddn.com/0_1313305334OkCc.gif" alt="Image"></p>
<p>在这个图中，ActivityManagerService和ActivityStack位于同一个进程中，而ApplicationThread和ActivityThread位于另一个进程中。</p>
<p>其中，ActivityManagerService是负责管理Activity的生命周期的，ActivityManagerService还借助ActivityStack是来把所有的Activity按照后进先出的顺序放在一个堆栈中；对于每一个应用程序来说，都有一个ActivityThread来表示应用程序的主进程，而每一个ActivityThread都包含有一个ApplicationThread实例，它是一个Binder对象，负责和其它进程进行通信。</p>
<ol>
<li>无论是通过Launcher来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，都通过Binder进程间通信进入到ActivityManagerService进程中，并且调用ActivityManagerService.startActivity接口；</li>
<li>ActivityManagerService调用ActivityStack.startActivityMayWait来做准备要启动的Activity的相关信息；</li>
<li>ActivityStack通知ApplicationThread要进行Activity启动调度了，这里的ApplicationThread代表的是调用ActivityManagerService.startActivity接口的进程，对于通过点击应用程序图标的情景来说，这个进程就是Launcher了，而对于通过在Activity内部调用startActivity的情景来说，这个进程就是这个Activity所在的进程了；</li>
<li>ApplicationThread不执行真正的启动操作，它通过调用ActivityManagerService.activityPaused接口进入到ActivityManagerService进程中，看看是否需要创建新的进程来启动Activity；</li>
<li>对于通过点击应用程序图标来启动Activity的情景来说，ActivityManagerService在这一步中，会调用startProcessLocked来创建一个新的进程，而对于通过在Activity内部调用startActivity来启动新的Activity来说，这一步是不需要执行的，因为新的Activity就在原来的Activity所在的进程中进行启动；</li>
<li>ActivityManagerServic调用ApplicationThread.scheduleLaunchActivity接口，通知相应的进程执行启动Activity的操作；</li>
<li>ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread通过ClassLoader导入相应的Activity类，然后把它启动起来。</li>
</ol>
<p>参考资料：<br> <a href="http://blog.csdn.net/luoshengyang/article/details/6685853" target="_blank" rel="external">Android应用程序的Activity启动过程简要介绍和学习计划</a><br> <a href="http://blog.jobbole.com/67931/" target="_blank" rel="external">Android启动过程深入解析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/b3b7d0a20cf431adb6bc847b4836acaf2edd9802.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-进程保活</title>
    <link href="http://yoursite.com/2016/08/12/Android%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB/"/>
    <id>http://yoursite.com/2016/08/12/Android笔记-进程保活/</id>
    <published>2016-08-12T12:49:12.000Z</published>
    <updated>2016-08-12T14:21:55.194Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/b03533fa828ba61e2cd4d63f4334970a304e59e3.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="进程的优先级"><a href="#进程的优先级" class="headerlink" title="进程的优先级"></a>进程的优先级</h1><h2 id="前台进程-——-Foreground-process"><a href="#前台进程-——-Foreground-process" class="headerlink" title="前台进程 —— Foreground process"></a>前台进程 —— Foreground process</h2><p>用户当前操作所必需的进程。通常在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。</p>
<ul>
<li>拥有用户正在交互的 Activity（已调用 onResume()）</li>
<li>拥有某个 Service，后者绑定到用户正在交互的 Activity</li>
<li>拥有正在“前台”运行的 Service（服务已调用 startForeground()）</li>
<li>拥有正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</li>
<li>拥有正执行其 onReceive() 方法的 BroadcastReceiver</li>
</ul>
<h2 id="可见进程-——-Visible-process"><a href="#可见进程-——-Visible-process" class="headerlink" title="可见进程 —— Visible process"></a>可见进程 —— Visible process</h2><p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>
<ul>
<li>拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）</li>
<li>拥有绑定到可见（或前台）Activity 的 Service</li>
</ul>
<h2 id="服务进程-——-Service-process"><a href="#服务进程-——-Service-process" class="headerlink" title="服务进程 —— Service process"></a>服务进程 —— Service process</h2><p>尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>
<ul>
<li>正在运行 startService() 方法启动的服务，且不属于上述两个更高类别进程的进程。</li>
</ul>
<h2 id="后台进程-——-Background-process"><a href="#后台进程-——-Background-process" class="headerlink" title="后台进程 —— Background process"></a>后台进程 —— Background process</h2><p>后台进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU 列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。</p>
<ul>
<li>对用户不可见的 Activity 的进程（已调用 Activity的onStop() 方法）</li>
</ul>
<h2 id="空进程-——-Empty-process"><a href="#空进程-——-Empty-process" class="headerlink" title="空进程 —— Empty process"></a>空进程 —— Empty process</h2><p>保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
<ul>
<li>不含任何活动应用组件的进程</li>
</ul>
<h1 id="Android-进程回收策略"><a href="#Android-进程回收策略" class="headerlink" title="Android 进程回收策略"></a>Android 进程回收策略</h1><p>系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app。</p>
<p>这套杀进程回收内存的机制就叫 Low Memory Killer ，它是基于Linux内核的 OOM Killer（Out-Of-Memory killer）机制诞生。</p>
<p>oom_adj是linux内核分配给每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。</p>
<ul>
<li>进程的oom_adj越大，表示此进程优先级越低，越容易被杀回收；越小，表示进程优先级越高，越不容易被杀回收</li>
<li>普通app进程的oom_adj&gt;=0,系统进程的oom_adj才可能&lt;0</li>
</ul>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/2.jpg" alt="Image"><br>其中红色部分代表比较容易被杀死的 Android 进程（OOM_ADJ&gt;=4）,绿色部分表示不容易被杀死的 Android 进程，其他表示非 Android 进程（纯 Linux 进程）。在 Lowmemorykiller 回收内存时会根据进程的级别优先杀死 OOM_ADJ 比较大的进程，对于优先级相同的进程则进一步受到进程所占内存和进程存活时间的影响。</p>
<p>减少进程被杀死概率无非就是想办法提高进程优先级，减少进程在内存不足等情况下被杀死的概率。</p>
<h1 id="提升进程优先级的方案"><a href="#提升进程优先级的方案" class="headerlink" title="提升进程优先级的方案"></a>提升进程优先级的方案</h1><h2 id="利用-Activity-提升权限"><a href="#利用-Activity-提升权限" class="headerlink" title="利用 Activity 提升权限"></a>利用 Activity 提升权限</h2><p>监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。注意该 Activity 需设计成用户无感知。</p>
<p>通过该方案，可以使进程的优先级在屏幕锁屏时间由4提升为最高优先级1。</p>
<h2 id="利用-Service-提升权限"><a href="#利用-Service-提升权限" class="headerlink" title="利用 Service 提升权限"></a>利用 Service 提升权限</h2><p>Android 中 Service 的优先级为4，通过 setForeground 接口可以将后台 Service 设置为前台 Service，使进程的优先级由4提升为2，从而使进程的优先级仅仅低于用户当前正在交互的进程，与可见进程优先级一致，使进程被杀死的概率大大降低。</p>
<p>从 Android2.3 开始调用 setForeground 将后台 Service 设置为前台 Service 时，必须在系统的通知栏发送一条通知，也就是前台 Service 与一条可见的通知时绑定在一起的。</p>
<p>通过实现一个内部 Service，在 LiveService 和其内部 Service 中同时发送具有相同 ID 的 Notification，然后将内部 Service 结束掉。随着内部 Service 的结束，Notification 将会消失，但系统优先级依然保持为2。</p>
<h2 id="进程死后拉活的方案"><a href="#进程死后拉活的方案" class="headerlink" title="进程死后拉活的方案"></a>进程死后拉活的方案</h2><h3 id="利用系统广播拉活"><a href="#利用系统广播拉活" class="headerlink" title="利用系统广播拉活"></a>利用系统广播拉活</h3><p>在发生特定系统事件时，系统会发出响应的广播，通过在 AndroidManifest 中“静态”注册对应的广播监听器，即可在发生响应事件时拉活。</p>
<p>缺点：</p>
<ol>
<li>广播接收器被管理软件、系统软件通过“自启管理”等功能禁用的场景无法接收到广播，从而无法自启。</li>
<li>系统广播事件不可控，只能保证发生事件时拉活进程，但无法保证进程挂掉后立即拉活。</li>
</ol>
<h3 id="利用第三方应用广播拉活"><a href="#利用第三方应用广播拉活" class="headerlink" title="利用第三方应用广播拉活"></a>利用第三方应用广播拉活</h3><p>该方案总的设计思想与接收系统广播类似，不同的是该方案为接收第三方 Top 应用广播。</p>
<p>通过反编译第三方 Top 应用，如：手机QQ、微信、支付宝、UC浏览器等，以及友盟、信鸽、个推等 SDK，找出它们外发的广播，在应用中进行监听，这样当这些应用发出广播时，就会将我们的应用拉活。</p>
<p>限制：</p>
<ol>
<li>反编译分析过的第三方应用的多少</li>
<li>第三方应用的广播属于应用私有，当前版本中有效的广播，在后续版本随时就可能被移除或被改为不外发。</li>
</ol>
<h3 id="利用系统Service机制拉活"><a href="#利用系统Service机制拉活" class="headerlink" title="利用系统Service机制拉活"></a>利用系统Service机制拉活</h3><p>将 Service 设置为 START_STICKY，利用系统机制在 Service 挂掉后自动拉活。</p>
<p>如下两种情况无法拉活：</p>
<ol>
<li>Service 第一次被异常杀死后会在5秒内重启，第二次被杀死会在10秒内重启，第三次会在20秒内重启，一旦在短时间内 Service 被杀死达到5次，则系统不再拉起。</li>
<li>进程被取得 Root 权限的管理工具或系统工具通过 forestop 停止掉，无法重启。</li>
</ol>
<h1 id="保活手段"><a href="#保活手段" class="headerlink" title="保活手段"></a>保活手段</h1><p>当前业界的Android进程保活手段主要分为 黑、白、灰 三种，其大致的实现思路如下：</p>
<ul>
<li>黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）</li>
<li>白色保活：启动前台Service</li>
<li>灰色保活：利用系统的漏洞启动前台Service</li>
</ul>
<h1 id="黑色保活"><a href="#黑色保活" class="headerlink" title="黑色保活"></a>黑色保活</h1><p>所谓黑色保活，就是利用不同的app进程使用广播来进行相互唤醒。举个3个比较常见的场景：</p>
<ul>
<li>场景1：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app</li>
<li>场景2：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。由此发散开去，就会直接触发了下面的 场景3</li>
<li>假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。</li>
</ul>
<h1 id="白色保活"><a href="#白色保活" class="headerlink" title="白色保活"></a>白色保活</h1><p>白色保活手段非常简单，就是调用系统api启动一个前台的Service进程，这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，哪怕当前的app退到了后台。如：酷狗音乐。</p>
<h1 id="灰色保活"><a href="#灰色保活" class="headerlink" title="灰色保活"></a>灰色保活</h1><p>灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的Service进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。那么如何利用系统的漏洞呢，大致的实现思路和代码如下：</p>
<ul>
<li>思路一：API &lt; 18，启动前台Service时直接传入new Notification()；</li>
<li>思路二：API &gt;= 18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理；</li>
</ul>
<p>参考资料：<br><a href="http://dev.qq.com/topic/57ac4a0ea374c75371c08ce8" target="_blank" rel="external">Android进程保活招式大全</a><br><a href="http://www.jianshu.com/p/63aafe3c12af" target="_blank" rel="external">关于 Android 进程保活，你所需要知道的一切</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/b03533fa828ba61e2cd4d63f4334970a304e59e3.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-内存泄漏</title>
    <link href="http://yoursite.com/2016/08/12/Android%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2016/08/12/Android笔记-内存泄漏/</id>
    <published>2016-08-12T11:56:40.000Z</published>
    <updated>2016-08-12T12:46:04.474Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/55729117201103111238192208337427592_012.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>Java是垃圾回收语言的一种，其优点是开发者无需特意管理内存分配，降低了应用由于局部故障(segmentation fault)导致崩溃，同时防止未释放的内存把堆栈(heap)挤爆的可能，所以写出来的代码更为安全。</p>
<p>不幸的是，在Java中仍存在很多容易导致内存泄漏的逻辑可能(logical leak)。如果不小心，你的Android应用很容易浪费掉未释放的内存，最终导致内存用光的错误抛出(out-of-memory，OOM)。</p>
<p>一般内存泄漏(traditional memory leak)的原因是：当该对象的所有引用都已经释放了，对象仍未被释放。</p>
<p>逻辑内存泄漏(logical memory leak)的原因是：当应用不再需要这个对象，当仍未释放该对象的所有引用。</p>
<p>如果持有对象的强引用，垃圾回收器是无法在内存中回收这个对象。</p>
<h1 id="Android内存泄漏"><a href="#Android内存泄漏" class="headerlink" title="Android内存泄漏"></a>Android内存泄漏</h1><p>在Android开发中，最容易引发的内存泄漏问题的是Context。比如Activity的Context，就包含大量的内存引用，例如View Hierarchies和其他资源。一旦泄漏了Context，也意味泄漏它指向的所有对象。Android机器内存有限，太多的内存泄漏容易导致OOM。</p>
<p>检测逻辑内存泄漏需要主观判断，特别是对象的生命周期并不清晰。幸运的是，Activity有着明确的生命周期，很容易发现泄漏的原因。Activity.onDestroy()被视为Activity生命的结束，程序上来看，它应该被销毁了，或者Android系统需要回收这些内存。</p>
<p>如果这个方法执行完，在堆栈中仍存在持有该Activity的强引用，垃圾回收器就无法把它标记成已回收的内存，而我们本来目的就是要回收它！</p>
<p>结果就是Activity存活在它的生命周期之外。</p>
<p>Activity是重量级对象，应该让Android系统来处理它。然而，逻辑内存泄漏总是在不经意间发生。在Android中，导致潜在内存泄漏的陷阱不外乎两种：</p>
<ul>
<li>全局进程(process-global)的static变量。这个无视应用的状态，持有Activity的强引用的怪物。</li>
<li>活在Activity生命周期之外的线程。没有清空对Activity的强引用。</li>
</ul>
<h2 id="Static-Activities"><a href="#Static-Activities" class="headerlink" title="Static Activities"></a>Static Activities</h2><p>在类中定义了静态Activity变量，把当前运行的Activity实例赋值于这个静态变量。</p>
<p>如果这个静态变量在Activity生命周期结束后没有清空，就导致内存泄漏。因为static变量是贯穿这个应用的生命周期的，所以被泄漏的Activity就会一直存在于应用的进程中，不会被垃圾回收器回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Activity activity;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStaticActivity</span><span class="params">()</span> </span>&#123;</div><div class="line">    activity = <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">View saButton = findViewById(R.id.sa_button);</div><div class="line">saButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        setStaticActivity();</div><div class="line">        nextActivity();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Static-Views"><a href="#Static-Views" class="headerlink" title="Static Views"></a>Static Views</h2><p>类似的情况会发生在单例模式中，如果Activity经常被用到，那么在内存中保存一个实例是很实用的。正如之前所述，强制延长Activity的生命周期是相当危险而且不必要的，无论如何都不能这样做。</p>
<p>特殊情况：如果一个View初始化耗费大量资源，而且在一个Activity生命周期内保持不变，那可以把它变成static，加载到视图树上(View Hierachy)，像这样，当Activity被销毁时，应当释放资源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> view;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStaticView</span><span class="params">()</span> </span>&#123;</div><div class="line">    view = findViewById(R.id.sv_button);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View svButton = findViewById(R.id.sv_button);</div><div class="line">svButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">      setStaticView();</div><div class="line">      nextActivity();</div><div class="line"> &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>  </p>
<h2 id="Inner-Classes"><a href="#Inner-Classes" class="headerlink" title="Inner Classes"></a>Inner Classes</h2><p>假设Activity中有个内部类，这样做可以提高可读性和封装性。将如我们创建一个内部类，而且持有一个静态变量的引用，那内存泄漏就离你不远了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object inner;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createInnerClass</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    inner = <span class="keyword">new</span> InnerClass();</div><div class="line">&#125;</div><div class="line"></div><div class="line">View icButton = findViewById(R.id.ic_button);</div><div class="line">icButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">     createInnerClass();</div><div class="line">     nextActivity();</div><div class="line"> &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><br>内部类的优势之一就是可以访问外部类，不幸的是，导致内存泄漏的原因，就是内部类持有外部类实例的强引用。</p>
<h2 id="Anonymous-Classes"><a href="#Anonymous-Classes" class="headerlink" title="Anonymous Classes"></a>Anonymous Classes</h2><p>相似地，匿名类也维护了外部类的引用。所以内存泄漏很容易发生，当你在Activity中定义了匿名的AsyncTsk。当异步任务在后台执行耗时任务期间，Activity不幸被销毁了，这个被AsyncTask持有的Activity实例就不会被垃圾回收器回收，直到异步任务结束。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">startAsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="keyword">new</span> AsyncTask&lt;Void, Void, Void&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line">      &#125;</div><div class="line"> &#125;.execute();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">setContentView(R.layout.activity_main);</div><div class="line">View aicButton = findViewById(R.id.at_button);</div><div class="line">aicButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">      startAsyncTask();</div><div class="line">      nextActivity();</div><div class="line"> &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>  </p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>同样道理，定义匿名的Runnable，用匿名类Handler执行。Runnable内部类会持有外部类的隐式引用，被传递到Handler的消息队列MessageQueue中，在Message消息没有被处理之前，Activity实例不会被销毁了，于是导致内存泄漏。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handleMessage(message);</div><div class="line">    &#125;</div><div class="line">&#125;.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;, Long.MAX_VALUE &gt;&gt; <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View hButton = findViewById(R.id.h_button);</div><div class="line">hButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">       createHandler();</div><div class="line">       nextActivity();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>  </p>
<h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><p>我们再次通过Thread和TimerTask来展现内存泄漏。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spawnThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">View tButton = findViewById(R.id.t_button);</div><div class="line">tButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">      spawnThread();</div><div class="line">      nextActivity();</div><div class="line"> &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>   </p>
<h2 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h2><p>只要是匿名类的实例，不管是不是在工作线程，都会持有Activity的引用，导致内存泄漏。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTimer</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;, Long.MAX_VALUE &gt;&gt; <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View ttButton = findViewById(R.id.tt_button);</div><div class="line">ttButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        scheduleTimer();</div><div class="line">        nextActivity();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Sensor-Manager"><a href="#Sensor-Manager" class="headerlink" title="Sensor Manager"></a>Sensor Manager</h2><p>通过Context.getSystemService(int name)可以获取系统服务。这些服务工作在各自的进程中，帮助应用处理后台任务，处理硬件交互。如果需要使用这些服务，可以注册监听器，这会导致服务持有了Context的引用，如果在Activity销毁的时候没有注销这些监听器，会导致内存泄漏。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">()</span> </span>&#123;</div><div class="line">   SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);</div><div class="line">   Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);</div><div class="line">   sensorManager.registerListener(<span class="keyword">this</span>, sensor, SensorManager.SENSOR_DELAY_FASTEST);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View smButton = findViewById(R.id.sm_button);</div><div class="line">smButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        registerListener();</div><div class="line">        nextActivity();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure> </p>
<h1 id="内存泄漏检测工具"><a href="#内存泄漏检测工具" class="headerlink" title="内存泄漏检测工具"></a>内存泄漏检测工具</h1><h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p>LeakCanary 是square团队开源的检测内存泄露的开源类库。你可以在 debug 包种轻松检测内存泄露。</p>
<p>工作机制：</p>
<ul>
<li>RefWatcher.watch() 创建一个 KeyedWeakReference 到要被监控的对象。</li>
<li>然后在后台线程检查引用是否被清除，如果没有，调用GC。</li>
<li>如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。</li>
<li>在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用<a href="https://github.com/square/haha" target="_blank" rel="external">HAHA</a> 解析这个文件。</li>
<li>得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄露。</li>
<li>HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄露。如果是的话，建立导致泄露的引用链。</li>
<li>引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。</li>
</ul>
<p>参考资料：<br><a href="http://blog.nimbledroid.com/2016/05/23/memory-leaks.html" target="_blank" rel="external">Eight Ways Your Android App Can Leak Memory</a><br><a href="http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="external">LeakCanary 中文使用说明</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/55729117201103111238192208337427592_012.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Android多线程</title>
    <link href="http://yoursite.com/2016/08/12/Android%E7%AC%94%E8%AE%B0-Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/12/Android笔记-Android多线程/</id>
    <published>2016-08-12T10:40:16.000Z</published>
    <updated>2016-08-12T11:52:56.365Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/a8b3c133c895d14338e284af73f082025baf07be.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="Android多线程"><a href="#Android多线程" class="headerlink" title="Android多线程"></a>Android多线程</h1><p>众所周知，Android 程序的大多数代码操作都必须执行在主线程，例如系统事件(例如设备屏幕发生旋转)，输入事件(例如用户点击滑动等)，程序回调服务，UI绘制以及闹钟事件等等。那么我们在上述事件或者方法中插入的代码也将执行在主线程。</p>
<p>一旦我们在主线程里面添加了操作复杂的代码，这些代码就很可能阻碍主线程去响应点击/滑动事件，阻碍主线程的 UI 绘制等等。我们知道，为了让屏幕的刷新帧率达到 60fps，我们需要确保 16ms 内完成单次刷新的操作。</p>
<p>一旦我们在主线程里面执行的任务过于繁重就可能导致接收到刷新信号的时候因为资源被占用而无法完成这次刷新操作，这样就会产生掉帧的现象，刷新帧率自然也就跟着下降了。</p>
<p>为了避免上面提到的掉帧问题，我们需要使用多线程的技术方案，把那些操作复杂的任务移动到其他线程当中执行，这样就不容易阻塞主线程的操作，也就减小了出现掉帧的可能性。</p>
<p>Android 系统为我们提供了若干组工具类来帮助解决这个问题。</p>
<ul>
<li>AsyncTask: 为 UI 线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</li>
<li>HandlerThread: 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</li>
<li>ThreadPool: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</li>
<li>IntentService: 适合于执行由 UI 触发的后台 Service任务，并可以把后台任务执行的情况通过一定的机制反馈给 UI。</li>
</ul>
<p>通常来说，一个线程需要经历三个生命阶段：开始，执行，结束。线程会在任务执行完毕之后结束，那么为了确保线程的存活，我们会在执行阶段给线程赋予不同的任务，然后在里面添加退出的条件从而确保任务能够执行完毕后退出。</p>
<p>在很多时候，线程不仅仅是线性执行一系列的任务就结束那么简单的，我们会需要增加一个任务队列，让线程不断的从任务队列中获取任务去进行执行，另外我们还可能在线程执行的任务过程中与其他的线程进行协作。如果这些细节都交给我们自己来处理，这将会是件极其繁琐又容易出错的事情。</p>
<p>Android 系统为我们提供了 Looper，Handler，MessageQueue 来帮助实现上面的线程任务模型(Handler机制)。</p>
<p><br></p>
<h1 id="多线程与内存"><a href="#多线程与内存" class="headerlink" title="多线程与内存"></a>多线程与内存</h1><p>增加并发的线程数会导致内存消耗的增加，平衡好这两者的关系是非常重要的。我们知道，多线程并发访问同一块内存区域有可能带来很多问题，例如读写的权限争夺问题，ABA问题等等。为了解决这些问题，我们会需要引入锁的概念。</p>
<p>在 Android 系统中也无法避免因为多线程的引入而导致出现诸如上文提到的种种问题。Android UI 对象的创建，更新，销毁等等操作都默认是执行在主线程，但是如果我们在非主线程对UI对象进行操作，程序将可能出现异常甚至是崩溃。</p>
<p>另外，在非 UI 线程中直接持有 UI 对象的引用也很可能出现问题。例如Work线程中持有某个 UI 对象的引用，在 Work 线程执行完毕之前，UI 对象在主线程中被从 ViewHierarchy 中移除了，这个时候 UI 对象的任何属性都已经不再可用了，另外对这个 UI 对象的更新操作也都没有任何意义了，因为它已经从 ViewHierarchy 中被移除，不再绘制到画面上了。</p>
<p>不仅如此，View 对象本身对所属的 Activity 是有引用关系的，如果工作线程持续保有 View 的引用，这就可能导致 Activity无法完全释放。除了直接显式的引用关系可能导致内存泄露之外，我们还需要特别留意隐式的引用关系也可能导致泄露。</p>
<p>为了解决上面的问题，我们需要谨记的原则就是：不要在任何非 UI 线程里面去持有 UI 对象的引用。系统为了确保所有的 UI 对象都只会被 UI 线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当 Activity 被销毁的时候，由该 Activity 所触发的非 UI 线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止 UI 对象被错误的使用。</p>
<p><br></p>
<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><ul>
<li>Android系统基于精简过后的linux内核，其线程的调度受时间片轮转和优先级控制等诸多因素影响。</li>
<li>Linux系统的调度器在分配time slice的时候，采用的CFS（completely fair scheduler）策略。这种策略不但会参考单个线程的优先级，还会追踪每个线程已经获取到的time slice数量，如果高优先级的线程已经执行了很长时间，但低优先级的线程一直在等待，后续系统会保证低优先级的线程也能获取更多的CPU时间。显然使用这种调度策略的话，优先级高的线程并不一定能在争取time slice上有绝对的优势，所以Android系统在线程调度上使用了cgroups的概念，cgroups能更好的凸显某些线程的重要性，使得优先级更高的线程明确的获取到更多的time slice。</li>
<li>Android将线程分为多个group，其中两类group尤其重要。一类是default group，UI线程属于这一类。另一类是background group，工作线程应该归属到这一类。background group当中所有的线程加起来总共也只能分配到5～10%的time slice，剩下的全部分配给default group，这样设计显然能保证UI线程绘制UI的流畅性。</li>
</ul>
<p><br></p>
<h1 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h1><p>一个典型的AsyncTask实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doInBackground</span><span class="params">(Object[] params)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPreExecute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPostExecute(o);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>和使用Thread()不同的是，多了几处API回调来严格规范工作线程与UI线程之间的交互。我们大部分的业务场景几乎都符合这种规范，比如去磁盘读取图片，缩放处理需要在工作线程执行，最后绘制到ImageView控件需要切换到UI线程。</p>
<p>举个例子，常遇到的一个典型的使用场景：用户切换到某个界面，触发了界面上的图片的加载操作，因为图片的加载相对来说耗时比较长，我们需要在子线程中处理图片的加载，当图片在子线程中处理完成之后，再把处理好的图片返回给主线程，交给 UI 更新到画面上。</p>
<p>AsyncTask 的出现就是为了快速的实现上面的使用场景，AsyncTask 把在主线程里面的准备工作放到 onPreExecute()方法里面进行执行，doInBackground()方法执行在工作线程中，用来处理那些繁重的任务，一旦任务执行完毕，就会调用 onPostExecute()方法返回到主线程。</p>
<p>AsyncTask 的内部实现主要就是封装了一个可以串行执行任务的 Executor 以及处理线程间消息传递的 Handler，极大的简化了异步任务的处理。</p>
<p>使用 AsyncTask 需要注意的问题有哪些呢?请关注以下几点：</p>
<ul>
<li><p>首先，默认情况下，所有的 AsyncTask 任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。假设你按照顺序启动20个 AsyncTask，一旦其中的某个 AsyncTask 执行时间过长，队列中的其他剩余 AsyncTask 都处于阻塞状态，必须等到该任务执行完毕之后才能够有机会执行下一个任务。</p>
<p>为了解决上面提到的线性队列等待的问题，我们可以使用 AsyncTask.executeOnExecutor()强制指定 AsyncTask 使用线程池并发调度任务。</p>
</li>
</ul>
<ul>
<li><p>其次，如何才能够真正的取消一个 AsyncTask 的执行呢?我们知道 AsyncTaks 有提供 cancel()的方法，但是这个方法实际上做了什么事情呢?线程本身并不具备中止正在执行的代码的能力，为了能够让一个线程更早的被销毁，我们需要在 doInBackground()的代码中不断的添加程序是否被中止的判断逻辑。<br>一旦任务被成功中止，AsyncTask 就不会继续调用 onPostExecute()，而是通过调用 onCancelled()的回调方法反馈任务执行取消的结果。</p>
</li>
<li><p>最后，使用 AsyncTask 很容易导致内存泄漏，一旦把 AsyncTask 写成 Activity 的内部类的形式就很容易因为 AsyncTask 生命周期的不确定而导致 Activity 发生泄漏。</p>
</li>
</ul>
<p><br></p>
<h1 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h1><p>在需要对多任务做更精细控制，线程切换更频繁的场景之下，Thread()和AsyncTask都会显得力不从心。HandlerThread却能胜任这些需求甚至更多。</p>
<p>HandlerThread将Handler，Thread，Looper，MessageQueue几个概念相结合。Handler是线程对外的接口，所有新的message或者runnable都通过handler post到工作线程。Looper在MessageQueue取到新的任务就切换到工作线程去执行。不同的post方法可以让我们对任务做精细的控制，什么时候执行，执行的顺序都可以控制。HandlerThread最大的优势在于引入MessageQueue概念，可以进行多任务队列管理。</p>
<p>HandlerThread背后只有一个线程，所以任务是串行执行的。串行相对于并行来说更安全，各任务之间不会存在多线程安全问题。</p>
<p>HandlerThread所产生的线程会一直存活，Looper会在该线程中持续的检查MessageQueue。这一点和Thread()，AsyncTask都不同，thread实例的重用可以避免线程相关的对象的频繁重建和销毁。</p>
<p>另外很重要的一点是，一旦我们使用了 HandlerThread，需要特别注意给 HandlerThread 设置不同的线程优先级，CPU 会根据设置的不同线程优先级对所有的线程进行调度优化。</p>
<p><br></p>
<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>Thread(),AsyncTask适合处理单个任务的场景，HandlerThread适合串行处理多任务的场景。当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择。</p>
<p>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为 CPU 只能同时执行固定数量的线程数，一旦同时并发的线程数量超过 CPU 能够同时执行的阈值，CPU 就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。</p>
<p>一旦同时并发的线程数量达到一定的量级，这个时候 CPU 在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少 64K+ 的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor 为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。</p>
<p>另外需要关注的一个问题是：Runtime.getRuntime().availableProcesser()方法并不可靠，他返回的值并不是真实的 CPU 核心数，因为 CPU 会在某些情况下选择对部分核心进行睡眠处理，在这种情况下，返回的数量就只能是激活的 CPU 核心数。</p>
<p><br></p>
<h1 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h1><p>IntentService 继承自普通 Service 同时又在内部创建了一个 HandlerThread，在 onHandlerIntent()的回调里面处理扔到 IntentService 的任务。所以 IntentService 就不仅仅具备了异步线程的特性，还同时保留了 Service 不受主页面生命周期影响的特点。</p>
<p>我们可以在 IntentService 里面通过设置闹钟间隔性的触发异步任务，例如刷新数据，更新缓存的图片或者是分析用户操作行为等等，当然处理这些任务需要小心谨慎。</p>
<p>使用 IntentService 需要特别留意以下几点：</p>
<ul>
<li>首先，因为 IntentService 内置的是 HandlerThread 作为异步线程，所以每一个交给 IntentService 的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。</li>
<li>其次，通常使用到 IntentService 的时候，我们会结合使用 BroadcastReceiver 把工作线程的任务执行结果返回给主 UI 线程。使用广播容易引起性能问题，我们可以使用 LocalBroadcastManager 来发送只在程序内部传递的广播，从而提升广播的性能。我们也可以使用 runOnUiThread() 快速回调到主 UI 线程。</li>
<li>最后，包含正在运行的 IntentService 的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li>
</ul>
<p><br></p>
<h1 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h1><p>Activity 有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在 Activity 不停的创建与销毁的过程当中，很有可能因为工作线程持有 Activity 的 View 而导致内存泄漏(因为工作线程很可能持有 View 的强引用，另外工作线程的生命周期还无法保证和 Activity 的生命周期一致，这样就容易发生内存泄漏了)。</p>
<p>Loader 的出现就是为了确保工作线程能够和 Activity 的生命周期保持一致，同时避免出现前面提到的问题。</p>
<p>LoaderManager 会对查询的操作进行缓存，只要对应 Cursor 上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader 可以直接把缓存的数据回调到 onLoadFinished()，从而避免重新查询数据。另外系统会在 Loader 不再需要使用到的时候(例如使用 Back 按钮退出当前页面)回调 onLoaderReset()方法，我们可以在这里做数据的清除等等操作。</p>
<ul>
<li>LoaderManager 来管理我们的laoder实例，获取，初始化，重启一个loader。</li>
<li>Loader 来执行我们的异步操作，有开始，完成，后台加载中等接口实现。</li>
<li>LoaderCallbacks 来执行我们的loader回调，主要是绑定分发Loader，完成加载，重置数据等。</li>
</ul>
<p>参考资料：<br><a href="http://www.androidchina.net/5238.html?sukey=3997c0719f1515202fb25b1b408e219206e39e105e1e1203c8dee51645ecddb38f3cf762488f5fdb111f656e0f2997c9" target="_blank" rel="external">Android 线程的正确使用姿势</a><br><a href="http://www.2cto.com/kf/201605/511009.html" target="_blank" rel="external">Android性能优化典范之多线程篇</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/a8b3c133c895d14338e284af73f082025baf07be.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-View绘制流程</title>
    <link href="http://yoursite.com/2016/08/11/Android%E7%AC%94%E8%AE%B0-View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/11/Android笔记-View绘制流程/</id>
    <published>2016-08-11T13:05:35.000Z</published>
    <updated>2016-08-11T14:52:14.181Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/f2deb48f8c5494eec7f266af2cf5e0fe98257eb7.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="View绘制"><a href="#View绘制" class="headerlink" title="View绘制"></a>View绘制</h1><ul>
<li>每一个View的绘制过程都必须经历三个最主要的过程，也就是measure、layout和draw。</li>
<li>整个View树的绘图流程是在ViewRootImpl类的performTraversals()方法，该函数做的执行过程主要是根据之前设置的状态，判断是否重新计算视图大小(measure)、是否重新放置视图的位置(layout)、以及是否重绘 (draw)，其核心也就是通过判断来选择顺序执行这三个方法中的哪个。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="comment">//最外层的根视图的widthMeasureSpec和heightMeasureSpec由来//lp.width和lp.height在创建ViewGroup实例时等于MATCH_PARENTint childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span></div><div class="line">    <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line">    ......</div><div class="line">    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    ......</div><div class="line">    mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</div><div class="line">    ......</div><div class="line">    mView.draw(canvas);</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> measureSpec;</div><div class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    ......</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> measureSpec;</div><div class="line">&#125;</div></pre></td></tr></table></figure>        
可以看见这个方法的注释说是用来测Root View的。上面传入参数后这个函数走的是MATCH_PARENT，使用MeasureSpec.makeMeasureSpec方法组装一个MeasureSpec，MeasureSpec的specMode等于EXACTLY，specSize等于windowSize，也就是为何根视图总是全屏的原因。</li>
</ul>
<p>其中的mView就是View对象。如下就是整个流程的大致流程图：</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/20150529090922419.png" alt="Image"></p>
<p><br></p>
<h1 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h1><h3 id="View中的measure"><a href="#View中的measure" class="headerlink" title="View中的measure"></a>View中的measure</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    ...    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>每个View控件的实际宽高都是由父视图和自身决定的。实际的测量是在onMeasure方法进行。</li>
<li>View的子类需要重写onMeasure方法，这是因为measure方法是final的，不允许重写，所以View子类只能通过重写onMeasure来实现自己的测量逻辑。</li>
<li>这个方法的两个参数都是父View传递过来的，也就是代表了父view的规格。他由两部分组成，高2位表示MODE，定义在MeasureSpec类（View的内部类）中，有三种类型，MeasureSpec.EXACTLY表示确定大小， MeasureSpec.AT_MOST表示最大大小， MeasureSpec.UNSPECIFIED不确定。低30位表示size，也就是父View的大小。对于系统Window类的DecorVIew对象Mode一般都为MeasureSpec.EXACTLY ，而size分别对应屏幕宽高。对于子View来说大小是由父View和子View共同决定的。</li>
</ul>
<h3 id="View中的onMeasure"><a href="#View中的onMeasure" class="headerlink" title="View中的onMeasure"></a>View中的onMeasure</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对于非ViewGroup的View而言，通过调用上面默认的onMeasure即可完成View的测量，当然你也可以重写onMeasure并调用setMeasuredDimension来设置任意大小的布局。</li>
<li>onMeasure默认的实现仅仅调用了setMeasuredDimension，setMeasuredDimension函数是一个很关键的函数，它对View的成员变量mMeasuredWidth和mMeasuredHeight变量赋值。</li>
<li>measure的主要目的就是对View树中的每个View的mMeasuredWidth和mMeasuredHeight进行赋值，所以一旦这两个变量被赋值意味着该View的测量工作结束。</li>
</ul>
<h3 id="getDefaultSize"><a href="#getDefaultSize" class="headerlink" title="getDefaultSize"></a>getDefaultSize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = size;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        result = size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        result = specSize;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果specMode等于AT_MOST或EXACTLY就返回specSize，这就是系统默认的规格。</li>
<li>getDefaultSize参数的widthMeasureSpec和heightMeasureSpec都是由父View传递进来的。getSuggestedMinimumWidth与getSuggestedMinimumHeight都是View的方法。</li>
</ul>
<h3 id="getSuggestedMinimumXXXXX"><a href="#getSuggestedMinimumXXXXX" class="headerlink" title="getSuggestedMinimumXXXXX"></a>getSuggestedMinimumXXXXX</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>建议的最小宽度和高度都是由View的Background尺寸与通过设置View的miniXXX属性共同决定的。</li>
</ul>
<h3 id="ViewGroup中的measureChild"><a href="#ViewGroup中的measureChild" class="headerlink" title="ViewGroup中的measureChild"></a>ViewGroup中的measureChild</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ViewGroup定义了measureChild方法对子View进行测量。</li>
<li>ViewGroup继承自View,所以也可以通过重写onMeasure实现自己的测量逻辑。</li>
</ul>
<h2 id="measure小结"><a href="#measure小结" class="headerlink" title="measure小结"></a>measure小结</h2><ul>
<li>measure过程主要就是从顶层父View向子View递归调用view.measure方法（measure中又回调onMeasure方法）的过程。</li>
<li>MeasureSpec（View的内部类）测量规格为int型，值由高2位规格模式specMode和低30位具体尺寸specSize组成。其中specMode只有三种值：<br>1.MeasureSpec.EXACTLY //确定模式，父View希望子View的大小是确定的，由specSize决定；<br>2.MeasureSpec.AT_MOST //最多模式，父View希望子View的大小最多是specSize指定的值；<br>3.MeasureSpec.UNSPECIFIED //未指定模式，父View完全依据子View的设计值来决定；</li>
<li>View的measure方法是final的，不允许重载，View子类只能重写onMeasure来完成自己的测量逻辑。</li>
<li>最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定的（LayoutParams宽高参数均为MATCH_PARENT，specMode是EXACTLY，specSize为物理屏幕大小）。</li>
<li>ViewGroup类提供了measureChild，measureChild和measureChildWithMargins方法，简化了父子View的尺寸计算。</li>
<li>View的布局大小由父View和子View共同决定。</li>
<li>使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流程之后被调用才能返回有效值。</li>
</ul>
<p><br></p>
<h1 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h1><h3 id="View中的layout"><a href="#View中的layout" class="headerlink" title="View中的layout"></a>View中的layout</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> oldL = mLeft;</div><div class="line">    <span class="keyword">int</span> oldT = mTop;</div><div class="line">    <span class="keyword">int</span> oldB = mBottom;</div><div class="line">    <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">        onLayout(changed, l, t, r, b);</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">        ListenerInfo li = mListenerInfo;</div><div class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>类似measure过程，layout调用了onLayout方法。</li>
<li>View的layout方法是可以在子类重写的。</li>
</ul>
<h3 id="View中的onLayout"><a href="#View中的onLayout" class="headerlink" title="View中的onLayout"></a>View中的onLayout</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>View中的onLayout是个空方法。</li>
</ul>
<h3 id="ViewGroup中的layout"><a href="#ViewGroup中的layout" class="headerlink" title="ViewGroup中的layout"></a>ViewGroup中的layout</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</div><div class="line">        <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</div><div class="line">            mTransition.layoutChange(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">super</span>.layout(l, t, r, b);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// record the fact that we noop'd it; request layout when transition finishes</span></div><div class="line">        mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ViewGroup的layout是不能在子类重写的。</li>
<li>所以ViewGroup中只能通过重写onLayout方法计算自己的位置。</li>
</ul>
<h3 id="ViewGroup中的onLayout"><a href="#ViewGroup中的onLayout" class="headerlink" title="ViewGroup中的onLayout"></a>ViewGroup中的onLayout</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed,</span></span></div><div class="line">        <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b);</div></pre></td></tr></table></figure>
<ul>
<li>ViewGroup中的onLayout是一个虚方法，所有ViewGroup的子类都必须重写这个方法。</li>
<li>所以在自定义ViewGroup控件中，onLayout配合onMeasure方法一起使用可以实现自定义View的复杂布局。自定义View首先调用onMeasure进行测量，然后调用onLayout方法动态获取子View和子View的测量大小，然后进行layout布局。</li>
<li>重载onLayout的目的就是安排其children在父View的具体位置，重载onLayout通常做法就是写一个for循环调用每一个子视图的layout(l, t, r, b)函数，传入不同的参数l, t, r, b来确定每个子视图在父视图中的显示位置。</li>
<li>比如LinearLayout中根据定义的mOrientation不同重写了不同的布局逻辑。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">        layoutVertical(l, t, r, b);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        layoutHorizontal(l, t, r, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="layout小结"><a href="#layout小结" class="headerlink" title="layout小结"></a>layout小结</h2><ul>
<li>layout也是从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。</li>
<li>View.layout方法可被重载，ViewGroup.layout为final的不可重载，ViewGroup.onLayout为abstract的，子类必须重载实现自己的位置逻辑。</li>
<li>measure操作完成后得到的是对每个View经测量过的measuredWidth和measuredHeight，layout操作完成之后得到的是对每个View进行位置分配后的mLeft、mTop、mRight、mBottom，这些值都是相对于父View来说的。</li>
<li>凡是layout_XXX的布局属性基本都针对的是包含子View的ViewGroup的，当对一个没有父容器的View设置相关layout_XXX属性是没有任何意义的。</li>
<li>使用View的getWidth()和getHeight()方法来获取View测量的宽高，必须保证这两个方法在onLayout流程之后被调用才能返回有效值。</li>
</ul>
<p><br></p>
<h1 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h1><h3 id="View中的draw"><a href="#View中的draw" class="headerlink" title="View中的draw"></a>View中的draw</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallSuper</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Draw traversal performs several drawing steps which must be executed</div><div class="line">     * in the appropriate order:</div><div class="line">     *</div><div class="line">     *      1. Draw the background</div><div class="line">     *      2. If necessary, save the canvas' layers to prepare for fading</div><div class="line">     *      3. Draw view's content</div><div class="line">     *      4. Draw children</div><div class="line">     *      5. If necessary, draw the fading edges and restore layers</div><div class="line">     *      6. Draw decorations (scrollbars for instance)</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">    <span class="keyword">int</span> saveCount;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">        drawBackground(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">        <span class="comment">// Step 3, draw the content</span></div><div class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// Step 4, draw the children</span></div><div class="line">        dispatchDraw(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></div><div class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class="line">        onDrawForeground(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// we're done...</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个draw过程分为了6步,第2和5步可以跳过(skip step 2 &amp; 5 if possible (common case))。</p>
<ul>
<li>第一步，对View的背景进行绘制。</li>
<li>第三步，对View的内容进行绘制。</li>
<li>第四步，对当前View的所有子View进行绘制，如果当前的View没有子View就不需要进行绘制。</li>
<li>第六步，对View的滚动条进行绘制。<br>可以看见其实任何一个View都是有（水平垂直）滚动条的，只是一般情况下没让它显示而已。</li>
</ul>
<h3 id="View中的onDraw"><a href="#View中的onDraw" class="headerlink" title="View中的onDraw"></a>View中的onDraw</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Implement this to do your drawing.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> canvas the canvas on which the background will be drawn</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>View中的onDraw是一个空方法,因为每个View的内容部分是各不相同的，所以需要由子类去实现具体逻辑。</li>
</ul>
<h3 id="View中的dispatchDraw"><a href="#View中的dispatchDraw" class="headerlink" title="View中的dispatchDraw"></a>View中的dispatchDraw</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Called by draw to draw the child views. This may be overridden</div><div class="line"> * by derived classes to gain control just before its children are drawn</div><div class="line"> * (but after its own view has been drawn).</div><div class="line"> * <span class="doctag">@param</span> canvas the canvas on which to draw the view</div><div class="line"> */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>View中的dispatchDraw也是一个空方法，注释说明了如果View包含子类需要重写他。</li>
</ul>
<h3 id="ViewGroup中的dispatchDraw"><a href="#ViewGroup中的dispatchDraw" class="headerlink" title="ViewGroup中的dispatchDraw"></a>ViewGroup中的dispatchDraw</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">int</span> flags = mGroupFlags;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</div><div class="line">        <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</div><div class="line">            <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</div><div class="line">            <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</div><div class="line">                    transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</div><div class="line">                more |= drawChild(canvas, transientChild, drawingTime);</div><div class="line">            &#125;</div><div class="line">            transientIndex++;</div><div class="line">            <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</div><div class="line">                transientIndex = -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">        <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">                ? children[childIndex] : preorderedList.get(childIndex);</div><div class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</div><div class="line">            more |= drawChild(canvas, child, drawingTime);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// there may be additional transient views after the normal views</span></div><div class="line">        <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</div><div class="line">        <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</div><div class="line">                transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</div><div class="line">            more |= drawChild(canvas, transientChild, drawingTime);</div><div class="line">        &#125;</div><div class="line">        transientIndex++;</div><div class="line">        <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</div><div class="line"></div><div class="line">    <span class="comment">// Draw any disappearing views that have animations</span></div><div class="line">    <span class="keyword">if</span> (mDisappearingChildren != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">final</span> ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> disappearingCount = disappearingChildren.size() - <span class="number">1</span>;</div><div class="line">        <span class="comment">// Go backwards -- we may delete as animations finish</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = disappearingCount; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">final</span> View child = disappearingChildren.get(i);</div><div class="line">            more |= drawChild(canvas, child, drawingTime);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ViewGroup没有重写draw，也没有重写onDraw，而是重写了dispatchDraw方法，然后调用drawChild方法。</li>
</ul>
<h3 id="ViewGroup的drawChild"><a href="#ViewGroup的drawChild" class="headerlink" title="ViewGroup的drawChild"></a>ViewGroup的drawChild</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>drawChild()方法调用了子View的draw()方法。所以说ViewGroup类已经为我们重写了dispatchDraw()的功能实现，我们一般不需要重写该方法，但可以重载父类函数实现具体的功能。</li>
</ul>
<h2 id="draw小结"><a href="#draw小结" class="headerlink" title="draw小结"></a>draw小结</h2><ul>
<li>如果该View是一个ViewGroup，则需要递归绘制其所包含的所有子View。</li>
<li>View默认不会绘制任何内容，真正的绘制都需要自己在子类中实现。</li>
<li>View的绘制是借助onDraw方法传入的Canvas类来进行的。</li>
<li>区分View动画和ViewGroup布局动画，前者指的是View自身的动画，可以通过setAnimation添加，后者是专门针对ViewGroup显示内部子视图时设置的动画，可以在xml布局文件中对ViewGroup设置layoutAnimation属性。</li>
<li>在获取画布剪切区（每个View的draw中传入的Canvas）时会自动处理掉padding，子View获取Canvas不用关注这些逻辑，只用关心如何绘制即可。</li>
<li>默认情况下子View的ViewGroup.drawChild绘制顺序和子View被添加的顺序一致，但是你也可以重写ViewGroup.getChildDrawingOrder()方法提供不同顺序。</li>
</ul>
<p>参考资料：<br><a href="http://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="external">Android应用层View绘制流程与源码分析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/f2deb48f8c5494eec7f266af2cf5e0fe98257eb7.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-设计模式</title>
    <link href="http://yoursite.com/2016/08/10/Android%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/08/10/Android笔记-设计模式/</id>
    <published>2016-08-10T14:20:29.000Z</published>
    <updated>2016-08-11T13:00:43.426Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/472309f7905298223203f251d7ca7bcb0a46d474.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="面向对象的六大原则"><a href="#面向对象的六大原则" class="headerlink" title="面向对象的六大原则"></a>面向对象的六大原则</h1><ul>
<li>单一职责原则<br>所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。通俗的说，即一个类只负责一项职责，将一组相关性很高的函数、数据封装到一个类中。</li>
<li>开闭原则<br>对于扩展是开放的，这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。<br>对于修改是关闭的，对模块行为进行扩展时，不必改动模块的源代码。通俗的说，尽量通过扩展的方式实现系统的升级维护和新功能添加，而不是通过修改已有的源代码。</li>
<li>里氏替换原则<br>使用“抽象(Abstraction)”和“多态(Polymorphism)”将设计中的静态结构改为动态结构，维持设计的封闭性。任何基类可以出现的地方，子类一定可以出现。在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li>
<li>依赖倒置原则<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合（各个模块之间相互传递的参数声明为抽象类型，而不是声明为具体的实现类）。</li>
<li>接口隔离原则<br>一个类对另一个类的依赖应该建立在最小的接口上。其原则是将非常庞大的、臃肿的接口拆分成更小的更具体的接口。</li>
<li>最少知识原则<br>就是说一个对象应当对其他对象有尽可能少的了解。<br>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，不关心被耦合或调用的类的内部实现，只负责调用你提供的方法。</li>
</ul>
<h1 id="Singleton（单例模式）"><a href="#Singleton（单例模式）" class="headerlink" title="Singleton（单例模式）"></a>Singleton（单例模式）</h1><p>作用：保证在Java应用程序中，一个类Class只有一个实例存在。</p>
<p>好处：<br>由于单例模式在内存中只有一个实例，减少了内存开销。<br>单例模式可以避免对资源的多重占用，例如一个写文件时，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。<br>单例模式可以再系统设置全局的访问点，优化和共享资源访问。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 私有构造方法，防止被实例化 */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 懒汉式：第一次调用时初始Singleton，以后就不用再生成了</span></div><div class="line">    静态方法，创建实例 */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 私有构造方法，防止被实例化 */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 懒汉式：第一次调用时初始Singleton，以后就不用再生成了</span></div><div class="line">    静态方法，创建实例 */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">         <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">         instance = <span class="keyword">new</span> Singleton();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* 持有私有静态实例，防止被引用，此处直接创建 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="comment">/* 私有构造方法，防止被实例化 */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 饿汉式：类加载时就创建了静态实例。 */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Android中的Singleton"><a href="#Android中的Singleton" class="headerlink" title="Android中的Singleton"></a>Android中的Singleton</h2><p>软键盘管理的 InputMethodManager<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InputMethodManager</span> </span>&#123;</div><div class="line">    <span class="comment">//.........</span></div><div class="line">    <span class="keyword">static</span> InputMethodManager sInstance;</div><div class="line">    <span class="comment">//.........</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputMethodManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (InputMethodManager.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);</div><div class="line">                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);</div><div class="line">                sInstance = <span class="keyword">new</span> InputMethodManager(service, Looper.getMainLooper());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> sInstance;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><br>Application并不算是单例模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Application</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>在Application源码中，其构造方法是公有的，意味着可以生出多个Application实例，但为什么Application能实现一个app只存在一个实例？<br>在ContextWrapper源码中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</div><div class="line">Context mBase;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ContextWrapper</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">    mBase = base;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</div><div class="line">    &#125;</div><div class="line">    mBase = base;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>ContextWrapper构造函数传入的base为null, 就算有多个Application实例，但是没有通过attach()绑定相关信息，没有上下文环境，即使创建了也没用。</p>
<h1 id="Factory（工厂模式）"><a href="#Factory（工厂模式）" class="headerlink" title="Factory（工厂模式）"></a>Factory（工厂模式）</h1><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。<br>对同一个接口的实现类进行管理和实例化创建。</p>
<p>假设我们有这样一个需求：</p>
<p>动物Animal，它有行为move()。有两个实现类cat和dog。为了统一管理和创建我们设计一个工厂模式。<br>同时两个子类有各自的行为，Cat有eatFish()，Dog有eatBone().</p>
<p>Animal接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Cat类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        System.out.println(<span class="string">"我是只肥猫，不爱动"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatFish</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"爱吃鱼"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Dog类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        System.out.println(<span class="string">"我是狗，跑的快"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatBone</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"爱吃骨头"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>那么现在就可以建一个工厂类（Factory.java）来对实例类进行管理和创建了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="comment">//静态工厂方法</span></div><div class="line">    <span class="comment">//多处调用，不需要实例工厂类</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title">produceCat</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title">produceDog</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</div><div class="line">    &#125;</div><div class="line"><span class="comment">//当然也可以一个方法，通过传入参数，switch实现</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br>使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Animal cat = Factory.produceCat();</div><div class="line">cat.move();</div><div class="line"><span class="comment">//-----------------------------</span></div><div class="line">Dog dog = Factory.produceDog();</div><div class="line">dog.move();</div><div class="line">dog.eatBone();</div></pre></td></tr></table></figure><br>这里实例化了Animal但不涉及到Animal的具体子类（减少了它们之间的耦合联系性），达到封装效果，也就减少错误修改的机会</p>
<p>Java面向对象的原则，封装(Encapsulation)和分派(Delegation)告诉我们：具体事情做得越多，越容易范错误。<br>一般来说，这样的普通工厂就可以满足基本需求。但是我们如果要新增一个Animal的实现类panda，那么必然要在工厂类里新增了一个生产panda的方法。就违背了闭包的设计原则（对扩展要开放对修改要关闭） ，于是有了抽象工厂模式。</p>
<h1 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory(抽象工厂)"></a>Abstract Factory(抽象工厂)</h1><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>就是把生产抽象成一个接口，每个实例类都对应一个工厂类（普通工厂只有一个工厂类），同时所有工厂类都继承这个生产接口。</p>
<p>生产接口Provider：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</div><div class="line">    <span class="function">Animal <span class="title">produce</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>每个产品都有自己的工厂<br>CatFactory：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">produce</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>DogFactory：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">produce</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>产品生产：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Provider provider = <span class="keyword">new</span> CatFactory();</div><div class="line">Animal cat =provider.produce();</div><div class="line">cat.move();</div></pre></td></tr></table></figure><br>现在我们要加入panda，直接新建一个pandaFactory就行了，这样我们系统就非常灵活，具备了动态扩展功能。</p>
<h2 id="Android中的Factory"><a href="#Android中的Factory" class="headerlink" title="Android中的Factory"></a>Android中的Factory</h2><p>AsyncTask的抽象工厂实现：<br>工厂的抽象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</div><div class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>产品的抽象（new Runnable就是其实现类）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>AsyncTask中工厂类的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br>其中sThreadFactory唯一作用是作为线程池的专业用来生产线程的工厂：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">        = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure><br>Android中的BitmapFactory中有重载的decodeXXXXXX()方法，大意就是资源的不同,但生产出的都是Bitmap。</p>
<h1 id="Adapter（适配器模式）"><a href="#Adapter（适配器模式）" class="headerlink" title="Adapter（适配器模式）"></a>Adapter（适配器模式）</h1><p>将一个类的接口转换成客户希望的另外一个接口。<br>我们经常碰到要将两个没有关系的类组合在一起使用，第一解决方案是：修改各自类的接口，但是如果我们没有源代码，或者，我们不愿意为了一个应用而修改各自的接口。 怎么办?<br>使用Adapter，在这两种接口之间创建一个混合接口。</p>
<p>模式中的角色<br>需要适配的类（Adaptee）：需要适配的类。<br>适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。<br>目标接口（Target）：客户所期待的接口。可以是具体的或抽象的类，也可以是接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 需要适配的类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"需要适配的类"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 目标接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>实现方式：<br>对象适配器（采用对象组合方式实现）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 适配器类实现标准接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</div><div class="line">    <span class="comment">// 直接关联被适配类</span></div><div class="line">    <span class="keyword">private</span> Adaptee adaptee;</div><div class="line"></div><div class="line">    <span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span> <span class="params">(Adaptee adaptee)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee = adaptee;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 这里是使用委托的方式完成特殊功能</span></div><div class="line">        <span class="keyword">this</span>.adaptee.specificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 需要先创建一个被适配类的对象作为参数</span></div><div class="line">        Target adapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</div><div class="line">        adapter.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果Target不是接口而是一个具体的类的情况，这里的Adapter直接继承Target就可以了。</p>
<p>类的适配器模式（采用继承实现）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 适配器类继承了被适配类同时实现标准接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.specificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试类</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 使用适配类</span></div><div class="line">    Target adapter = <span class="keyword">new</span> Adapter();</div><div class="line">    adapter.request();</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果Target和 Adaptee都是接口，并且都有实现类。 可以通过Adapter实现两个接口来完成适配。<br>还有一种叫PluggableAdapters,可以动态的获取几个adapters中一个。使用Reflection技术，可以动态的发现类中的Public方法。</p>
<p>优点：</p>
<ul>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li>
<li>将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码，更好的扩展性。</li>
</ul>
<p>缺点</p>
<ul>
<li>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现。如果不是必要，不要使用适配器，而是直接对系统进行重构。</li>
</ul>
<h2 id="Android中的Adapter"><a href="#Android中的Adapter" class="headerlink" title="Android中的Adapter"></a>Android中的Adapter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAdapter</span> <span class="keyword">implements</span> <span class="title">ListAdapter</span>, <span class="title">SpinnerAdapter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSetObservable mDataSetObservable = <span class="keyword">new</span> DataSetObservable();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasStableIds</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDataSetObserver</span><span class="params">(DataSetObserver observer)</span> </span>&#123;</div><div class="line">        mDataSetObservable.registerObserver(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterDataSetObserver</span><span class="params">(DataSetObserver observer)</span> </span>&#123;</div><div class="line">        mDataSetObservable.unregisterObserver(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>    
<p>ListAdapter, SpinnerAdapter都是Target ，数据是Adaptee ，采用对象组合方式。</p>
<h1 id="Chain-of-Responsibility（责任链模式）"><a href="#Chain-of-Responsibility（责任链模式）" class="headerlink" title="Chain of Responsibility（责任链模式）"></a>Chain of Responsibility（责任链模式）</h1><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<br>发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p>
<p>责任链模式的优点:<br>可以降低系统的耦合度（请求者与处理者代码分离），简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；</p>
<p>责任链模式的缺点:<br>不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。<br>每次都是从链头开始，这也正是链表的缺点。</p>
<h2 id="Android中的Chain-of-Responsibility"><a href="#Android中的Chain-of-Responsibility" class="headerlink" title="Android中的Chain of Responsibility"></a>Android中的Chain of Responsibility</h2><p>触摸、按键等各种事件的传递<br><img src="http://ob5qdb9lc.bkt.clouddn.com/20160621101505594_3.gif" alt="Image"></p>
<h1 id="Observer（观察者模式）"><a href="#Observer（观察者模式）" class="headerlink" title="Observer（观察者模式）"></a>Observer（观察者模式）</h1><p>有时被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<p>将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的（依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。）。</p>
<p>RxJava Observable类源自于经典的Gang Of Four的观察者模式。</p>
<h1 id="Builder（建造者模式）"><a href="#Builder（建造者模式）" class="headerlink" title="Builder（建造者模式）"></a>Builder（建造者模式）</h1><p>建造者模式：是将一个复杂的对象的构建与它的表示分离（同构建不同表示），使得同样的构建过程可以创建不同的表示。</p>
<p>一个人活到70岁以上，都会经历这样的几个阶段：婴儿，少年，青年，中年，老年。并且每个人在各个阶段肯定是不一样的，世界上不存在两个人在人生的这5个阶段的生活完全一样，但是活到70岁以上的人，都经历了这几个阶段是肯定的。实际上这是一个比较经典的建造者模式的例子了。</p>
<p>将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心。</p>
<p>建造者模式通常包括下面几个角色：</p>
<ul>
<li>Builder：一个抽象接口，用来规范产品对象的各个组成成分的建造。</li>
<li>ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建，在建造过程完成后，提供产品的实例。</li>
<li>Director：指导者，调用具体建造者来创建复杂对象的各个部分，不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li>
<li>Product：要创建的复杂对象。</li>
</ul>
<p>与抽象工厂的区别：在建造者模式里，有个指导者，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的建造过程。</p>
<p>优点：</p>
<ul>
<li>客户端不必知道产品内部组成的细节。</li>
<li>具体的建造者类之间是相互独立的，对系统的扩展非常有利。</li>
<li>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</li>
</ul>
<p>使用场合：</p>
<ul>
<li>创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。</li>
<li>要创建的复杂对象的算法，独立于该对象的组成部分，也独立于组成部分的装配方法时。</li>
</ul>
<h1 id="Android中的Builder"><a href="#Android中的Builder" class="headerlink" title="Android中的Builder"></a>Android中的Builder</h1><p>AlertDialog:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AlertController.AlertParams P;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTheme;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Constructor using a context for this builder and the &#123;<span class="doctag">@link</span> AlertDialog&#125; it creates.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, resolveDialogTheme(context, <span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Constructor using a context and theme for this builder and</div><div class="line">     * the &#123;<span class="doctag">@link</span> AlertDialog&#125; it creates.  The actual theme</div><div class="line">     * that an AlertDialog uses is a private implementation, however you can</div><div class="line">     * here supply either the name of an attribute in the theme from which</div><div class="line">     * to get the dialog's style (such as &#123;<span class="doctag">@link</span> android.R.attr#alertDialogTheme&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context, <span class="keyword">int</span> theme)</span> </span>&#123;</div><div class="line">        P = <span class="keyword">new</span> AlertController.AlertParams(<span class="keyword">new</span> ContextThemeWrapper(</div><div class="line">                context, resolveDialogTheme(context, theme)));</div><div class="line">        mTheme = theme;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>Builder类中部分方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setTitle</span><span class="params">(<span class="keyword">int</span> titleId)</span> </span>&#123;</div><div class="line">    P.mTitle = P.mContext.getText(titleId);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setMessage</span><span class="params">(<span class="keyword">int</span> messageId)</span> </span>&#123;</div><div class="line">    P.mMessage = P.mContext.getText(messageId);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setPositiveButton</span><span class="params">(CharSequence text, <span class="keyword">final</span> OnClickListener listener)</span> </span>&#123;</div><div class="line">    P.mPositiveButtonText = text;</div><div class="line">    P.mPositiveButtonListener = listener;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>简单建造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> AlertDialog.Builder(context)</div><div class="line">.setTitle(<span class="string">"标题"</span>)</div><div class="line">.setMessage(<span class="string">"消息框"</span>)</div><div class="line">.setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">null</span>)</div><div class="line">.show();</div></pre></td></tr></table></figure><br>Retrofit中也同样用到Bulider<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> Platform platform;</div><div class="line">        <span class="keyword">private</span> okhttp3.Call.Factory callFactory;</div><div class="line">        <span class="keyword">private</span> HttpUrl baseUrl;</div><div class="line">        <span class="keyword">private</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">private</span> List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">private</span> Executor callbackExecutor;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</div><div class="line"></div><div class="line">        Builder(Platform platform) &#123;</div><div class="line">        <span class="keyword">this</span>.platform = platform;</div><div class="line">        <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></div><div class="line">        <span class="comment">// ensures correct behavior when using converters that consume all types.</span></div><div class="line">        converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</div><div class="line">    &#125;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>简单建造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient.Builder();</div><div class="line">builder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">retrofit=<span class="keyword">new</span> Retrofit.Builder()</div><div class="line">        .baseUrl(BASE_URL)</div><div class="line">        .client(builder.build())</div><div class="line">        .addConverterFactory(GsonConverterFactory.create())</div><div class="line">        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">        .build();</div></pre></td></tr></table></figure></p>
<h1 id="Memento（备忘录模式）"><a href="#Memento（备忘录模式）" class="headerlink" title="Memento（备忘录模式）"></a>Memento（备忘录模式）</h1><p>备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。</p>
<p>备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。</p>
<p>备忘录模式所涉及的角色有三个：</p>
<ol>
<li>Originator(发起人):　负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。</li>
<li>Memento(备忘录):　负责存储Originnator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento，备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。</li>
<li>Caretaker(管理者):负责保存好备忘录Memento，不能对备忘录的内容进行操作或检查。</li>
</ol>
<h2 id="Android中的Memento"><a href="#Android中的Memento" class="headerlink" title="Android中的Memento"></a>Android中的Memento</h2><p>Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle（相当于备忘录对象）这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</div><div class="line">    Parcelable p = mFragments.saveAllState();</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</div><div class="line">    &#125;</div><div class="line">    getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mWindow != <span class="keyword">null</span>) &#123;</div><div class="line">        Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);</div><div class="line">        <span class="keyword">if</span> (windowState != <span class="keyword">null</span>) &#123;</div><div class="line">            mWindow.restoreHierarchyState(windowState);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Prototype（原型模式）"><a href="#Prototype（原型模式）" class="headerlink" title="Prototype（原型模式）"></a>Prototype（原型模式）</h1><p>原型模式，能快速克隆出一个与已经存在对象类似的另外一个我们想要的新对象。<br>工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。</p>
<p>分为深拷贝和浅拷贝。深拷贝就是把对象里面的引用的对象也要拷贝一份新的对象，并将这个新的引用对象作为拷贝的对象引用（多读两遍）。</p>
<p>一般使用原型模式有个明显的特点，就是实现cloneable的clone()方法。</p>
<h2 id="Android中的Prototype"><a href="#Android中的Prototype" class="headerlink" title="Android中的Prototype"></a>Android中的Prototype</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Intent(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>  
<p>这里Intent通过实现Cloneable接口来实现原型拷贝。<br>Intent克隆的意义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Make a clone of only the parts of the Intent that are relevant for</div><div class="line"> * filter matching: the action, data, type, component, and categories.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">cloneFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Intent(<span class="keyword">this</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Strategy（策略模式）"><a href="#Strategy（策略模式）" class="headerlink" title="Strategy（策略模式）"></a>Strategy（策略模式）</h1><p>定义：有一系列的算法，将每个算法封装起来（每个算法可以封装到不同的类中），各个算法之间可以替换，策略模式让算法独立于使用它的客户而独立变化。</p>
<p>举例：<br>一个影碟机，你往里面插什么碟子，就能放出什么电影。<br>属性动画，设置不同的插值器对象，就可以得到不同的变化曲线。<br>返回值解析，传入什么样的解析器，就可以把二进制数据转换成什么格式的数据，比如String、Json、XML。</p>
<p>策略模式其实就是多态的一个淋漓精致的体现。</p>
<h2 id="Android中的Strategy"><a href="#Android中的Strategy" class="headerlink" title="Android中的Strategy"></a>Android中的Strategy</h2><p>在android中不同Animation动画的实现，主要是依靠Interpolator(补间器，控制动画的变化速率)的不同而实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterpolator</span><span class="params">(Interpolator i)</span> </span>&#123;</div><div class="line">    mInterpolator = i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Template（模板模式）"><a href="#Template（模板模式）" class="headerlink" title="Template（模板模式）"></a>Template（模板模式）</h1><p>定义：定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定的步骤。<br>实现流程已经确定，实现细节由子类完成。</p>
<h2 id="Android中的Template"><a href="#Android中的Template" class="headerlink" title="Android中的Template"></a>Android中的Template</h2><p>生命周期对于我们都不陌生，它就是典型的Template模式，在具体流程确定的情况下，至于我们要复写生命周期那些方法，实现那些功能由继承activity的子类去具体实现。<br>关键在于必须有具体的执行流程，比如AsyncTask。</p>
<h1 id="Proxy（代理模式）"><a href="#Proxy（代理模式）" class="headerlink" title="Proxy（代理模式）"></a>Proxy（代理模式）</h1><p>定义：为其他对象提供一种代理以控制对这个对象的访问。<br>代理： 在出发点到目的地之间有一道中间层。</p>
<h2 id="Android中Proxy"><a href="#Android中Proxy" class="headerlink" title="Android中Proxy"></a>Android中Proxy</h2><p>Retrofit中也用到了Proxy。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">  Utils.validateServiceInterface(service);</div><div class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">    eagerlyValidateMethods(service);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></div><div class="line">            <span class="keyword">throws</span> Throwable &#123;</div><div class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">          &#125;</div><div class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">          OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Interpreter（解释器模式）"><a href="#Interpreter（解释器模式）" class="headerlink" title="Interpreter（解释器模式）"></a>Interpreter（解释器模式）</h1><p>定义语言的文法，并且建立一个解释器来解释该语言中的句子。<br>比如Android中通过PackageManagerService来解析AndroidManifest.xml中定义的Activity、service等属性。</p>
<h1 id="State（状态模式）"><a href="#State（状态模式）" class="headerlink" title="State（状态模式）"></a>State（状态模式）</h1><p>行为是由状态来决定的，不同状态下有不同行为。<br>注意：状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立可相互替换的。<br>体现：不同的状态执行不同的行为，当WIFI开启时，自动扫描周围的接入点，然后以列表的形式展示；当wifi关闭时则清空。</p>
<h1 id="Command（命令模式）"><a href="#Command（命令模式）" class="headerlink" title="Command（命令模式）"></a>Command（命令模式）</h1><p>我们有很多命令，把它们放在一个下拉菜单中，用户通过先选择菜单再选择具体命令，这就是Command模式。</p>
<p>本来用户(调用者)是直接调用这些命令的，在菜单上打开文档，就直接指向打开文档的代码，使用Command模式，就是在这两者之间增加一个中间者，将这种直接关系拗断，同时两者之间都隔离,基本没有关系了。</p>
<p>显然这样做的好处是符合封装的特性，降低耦合度，有利于代码的健壮性 可维护性 还有复用性。Command是将对行为进行封装的典型模式，Factory是将创建进行封装的模式。</p>
<p>android底层逻辑对事件的转发处理就用到了Command模式。</p>
<h1 id="Iterator（迭代模式）"><a href="#Iterator（迭代模式）" class="headerlink" title="Iterator（迭代模式）"></a>Iterator（迭代模式）</h1><p>提供一种方法顺序访问一个容器对象中的各个元素，而不需要暴露该对象的内部表示。<br>应用：<br>在Java中的Iterator类。<br>Android中的 Cursor。</p>
<h1 id="Composite（组合模式）"><a href="#Composite（组合模式）" class="headerlink" title="Composite（组合模式）"></a>Composite（组合模式）</h1><p>将对象以树形结构组织起来，以达成“部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。</p>
<p>Android中View的结构是树形结构，每个ViewGroup包含一系列的View，而ViewGroup本身又是View。这是Android中非常典型的组合模式。</p>
<h1 id="Flyweight（共享模式-享元模式）"><a href="#Flyweight（共享模式-享元模式）" class="headerlink" title="Flyweight（共享模式/享元模式）"></a>Flyweight（共享模式/享元模式）</h1><p>定义：避免大量拥有相同内容的小类的开销(如耗费内存)，使大家共享一个类(元类)。</p>
<p>面向对象语言的原则就是一切都是对象，但是如果真正使用起来，有时对象数可能显得很庞大，比如，字处理软件，如果以每个文字都作为一个对象，几千个字，对象数就是几千，无疑耗费内存，那么我们还是要”求同存异”，找出这些对象群的共同点，设计一个元类，封装可以被共享的类，另外，还有一些特性是取决于应用(context)，是不可共享的，这也Flyweight中两个重要概念内部状态intrinsic和外部状态extrinsic之分。</p>
<p>说白点，就是先捏一个的原始模型，然后随着不同场合和环境，再产生各具特征的具体模型，很显然，在这里需要产生不同的新对象，所以Flyweight模式中常出现Factory模式。Flyweight的内部状态是用来共享的，Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象。</p>
<p>Flyweight模式是一个提高程序效率和性能的模式，会大大加快程序的运行速度。应用场合很多：比如你要从一个数据库中读取一系列字符串，这些字符串中有许多是重复的，那么我们可以将这些字符串储存在Flyweight池(pool)中。</p>
<p>在Android线程通信中，每次获取Message时调Message.obtain()其实就是从消息池中取出可重复使用的消息，避免产生大量的Message对象。</p>
<p>参考资料：<br><a href="http://www.androidchina.net/5115.html?sukey=3997c0719f1515206fcb3e208377fb04b0d6d5bac30e6c12e922c8c935f52f6ec04d69ccd1ad82d6ea0de8db077b4ab4" target="_blank" rel="external">Android 源码中的设计模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/472309f7905298223203f251d7ca7bcb0a46d474.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-事件分发机制</title>
    <link href="http://yoursite.com/2016/08/10/Android%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/08/10/Android笔记-事件分发机制/</id>
    <published>2016-08-10T13:00:28.000Z</published>
    <updated>2016-08-11T13:02:05.636Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/5-16031Q44431.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h1><h2 id="涉及到事件响应的常用方法构成"><a href="#涉及到事件响应的常用方法构成" class="headerlink" title="涉及到事件响应的常用方法构成"></a>涉及到事件响应的常用方法构成</h2><ul>
<li>MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）</li>
<li>MotionEvent.ACTION_MOVE　：手指在屏幕上移动</li>
<li>MotionEvent.ACTION_UP　：手指离开屏幕瞬间</li>
<li>MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生</li>
</ul>
<p>Android中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。</p>
<p>android 事件响应机制是先 分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理 （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。</p>
<h2 id="涉及到的三个重要函数"><a href="#涉及到的三个重要函数" class="headerlink" title="涉及到的三个重要函数"></a>涉及到的三个重要函数</h2><ul>
<li>事件分发：public boolean dispatchTouchEvent(MotionEvent ev)　　　</li>
<li>事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)<br>　　　　　该方法为ViewGroup独有。</li>
<li>事件响应：public boolean onTouchEvent(MotionEvent ev)<br>　　　　　ViewGroup未实现，而是调用父类view的该方法。</li>
</ul>
<h2 id="View分析-源码很长，只写结论"><a href="#View分析-源码很长，只写结论" class="headerlink" title="View分析(源码很长，只写结论)"></a>View分析(源码很长，只写结论)</h2><ul>
<li>触摸控件（View）首先执行dispatchTouchEvent方法。</li>
<li>在dispatchTouchEvent方法中先执行onTouch方法，后执行onClick方法（onClick方法在onTouchEvent中执行）。</li>
<li>如果控件（View）的onTouch返回false或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是enable的情况下会调用onTouchEvent，dispatchTouchEvent返回值与onTouchEvent返回一样。</li>
<li>如果控件不是enable的设置了onTouch方法也不会执行，只能通过重写控件的onTouchEvent方法处理，dispatchTouchEvent返回值与onTouchEvent返回一样。</li>
<li>如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。</li>
<li>当dispatchTouchEvent在进行事件分发的时候，只有前一个action返回true，才会触发下一个action（也就是说dispatchTouchEvent返回true才会进行下一次action派发）。</li>
<li>onTouchEvent方法中会在ACTION_UP分支中触发onClick的监听。</li>
</ul>
<h2 id="ViewGroup分析"><a href="#ViewGroup分析" class="headerlink" title="ViewGroup分析"></a>ViewGroup分析</h2><ul>
<li>Android事件派发是先传递到最顶级的ViewGroup，再由ViewGroup递归传递到View的。</li>
<li>在ViewGroup中可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。</li>
<li>子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。</li>
<li>ViewGroup没有重写View的onTouchEvent(MotionEvent event) 方法。</li>
</ul>
<h2 id="Activity分析"><a href="#Activity分析" class="headerlink" title="Activity分析"></a>Activity分析</h2><ul>
<li>首先会触发Activity的dispatchTouchEvent方法。</li>
<li>dispatchTouchEvent方法中如果是ACTION_DOWN的情况下会接着触发onUserInteraction方法。</li>
<li>接着在dispatchTouchEvent方法中会通过Activity的rootView（id为content的FrameLayout），实质是ViewGroup，通过super.dispatchTouchEvent把touchevent派发给各个activity的子view，也就是我们再Activity.onCreat方法中setContentView时设置的view。</li>
<li>若Activity下面的子view拦截了touchEvent事件(返回true)则Activity.onTouchEvent方法就不会执行。</li>
<li>onUserInteraction方法是一个空方法,此方法是activity的方法，当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法。下拉statubar、旋转屏幕、锁屏不会触发此方法。所以它会用在屏保应用上，因为当你触屏机器就会立马触发一个事件，而这个事件又不太明确是什么，正好屏保满足此需求；或者对于一个Activity，控制多长时间没有用户点响应的时候，自己消失等。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>如果我们没有对控件里面的方法进行重写或更改返回值，而直接用super调用父类的默认实现，那么整个事件流向应该是从Activity—-&gt;ViewGroup—&gt;View从上往下调用dispatchTouchEvent方法，一直到叶子节点（View）的时候，再由View—&gt;ViewGroup—&gt;Activity从下往上调用onTouchEvent方法。<br><img src="http://ob5qdb9lc.bkt.clouddn.com/966283-d01a5845f742609712.png" alt="Image"></li>
<li>dispatchTouchEvent 和 onTouchEvent 一旦return true,事件就停止传递了，对于return true我们经常说事件被消费了，消费了的意思就是事件走到这里就是终点，不会往下传，没有谁能再收到这个事件了。</li>
<li>dispatchTouchEvent 和 onTouchEvent return false的时候事件都回传给父控件的onTouchEvent处理。事件停止往子View传递和分发同时开始往父控件回溯（父控件的onTouchEvent开始从下往上回传直到某个onTouchEvent return true），事件分发机制就像递归，return false 的意义就是递归停止然后开始回溯。</li>
<li>对于onTouchEvent return false 就比较简单了，它就是不消费事件，并让事件继续往父控件的方向从下往上流动。</li>
<li>dispatchTouchEvent、onTouchEvent、onInterceptTouchEvent<br>ViewGroup 和View的这些方法的默认实现就是会让整个事件安装U型完整走完，所以 return super.xxxxxx() 就会让事件依照U型的方向的完整走完整个事件流动路径），中间不做任何改动，不回溯、不终止，每个环节都走到。</li>
</ul>
<h2 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent"></a>onInterceptTouchEvent</h2><ul>
<li>Intercept 的意思就是拦截，每个ViewGroup每次在做分发的时候，问一问拦截器要不要拦截（也就是问问自己这个事件要不要自己来处理）如果要自己处理那就在onInterceptTouchEvent方法中 return true就会交给自己的onTouchEvent的处理，如果不拦截就是继续往子控件往下传。</li>
<li>默认是不会去拦截的，因为子View也需要这个事件，所以onInterceptTouchEvent拦截器return super.onInterceptTouchEvent()和return false是一样的，是不会拦截的，事件会继续往子View的dispatchTouchEvent传递。</li>
</ul>
<h2 id="ViewGroup的dispatchTouchEvent"><a href="#ViewGroup的dispatchTouchEvent" class="headerlink" title="ViewGroup的dispatchTouchEvent"></a>ViewGroup的dispatchTouchEvent</h2><ul>
<li>return true是终结传递。return false 是回溯到父View的onTouchEvent。</li>
<li>通过Interceptor把事件拦截下来给自己的onTouchEvent</li>
<li>ViewGroup dispatchTouchEvent方法的super默认实现就是去调用onInterceptTouchEvent。</li>
</ul>
<h2 id="View的dispatchTouchEvent"><a href="#View的dispatchTouchEvent" class="headerlink" title="View的dispatchTouchEvent"></a>View的dispatchTouchEvent</h2><ul>
<li>View类的dispatchTouchEvent（）方法默认实现就是能帮你调用View自己的onTouchEvent方法的。</li>
</ul>
<h2 id="ViewGroup和View的onTouchEvent"><a href="#ViewGroup和View的onTouchEvent" class="headerlink" title="ViewGroup和View的onTouchEvent"></a>ViewGroup和View的onTouchEvent</h2><ul>
<li>自己消费掉，事件终结，不再传给谁—–&gt;return true;</li>
<li>继续从下往上传，不消费事件，让父View也能收到到这个事件—–&gt;return false;View的默认实现是不消费的。所以super==false。</li>
</ul>
<h2 id="ACTION-MOVE-和-ACTION-UP"><a href="#ACTION-MOVE-和-ACTION-UP" class="headerlink" title="ACTION_MOVE 和 ACTION_UP"></a>ACTION_MOVE 和 ACTION_UP</h2><ul>
<li>ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传</li>
<li>如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</li>
</ul>
<p>参考资料：<br><a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解 Android 事件分发机制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/5-16031Q44431.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Handler机制</title>
    <link href="http://yoursite.com/2016/08/10/Android%E7%AC%94%E8%AE%B0-Handler%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/08/10/Android笔记-Handler机制/</id>
    <published>2016-08-10T11:37:00.000Z</published>
    <updated>2016-08-11T13:03:10.889Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/bz1080p.com_2015-03-06_05-37-47.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h1><p>Hnadler机制其实从某种意义上而言，是基于生产者-消费者模式展开的。<br>如UI线程就是消费者，在其他线程（生产者）上通过 Handler 将要执行的Callback ，迁移到UI线程上执行。</p>
<p>生产者（Work thread）需要将任务提交给缓冲区(MessageQueue)，而这个提交工作是由 post(Runnable runable) 或者 postDelayed(Runnable r, long delayMillis) 等post方法来执行。而消费者（UI thread）通过 looper 不断地从 MessageQueue 中取出任务再执行。</p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>生成和消费的内容就是Message。<br>Message部分代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * User-defined message code so that the recipient can identify</div><div class="line"> * what this message is about. Each &#123;<span class="doctag">@link</span> Handler&#125; has its own name-space</div><div class="line"> * for message codes, so you do not need to worry about yours conflicting</div><div class="line"> * with other handlers.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * arg1 and arg2 are lower-cost alternatives to using</div><div class="line"> * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</div><div class="line"> * few integer values.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * arg1 and arg2 are lower-cost alternatives to using</div><div class="line"> * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</div><div class="line"> * few integer values.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line"><span class="comment">/*package*/</span> Bundle data;</div><div class="line"></div><div class="line"><span class="comment">/*package*/</span> Handler target;</div><div class="line"></div><div class="line"><span class="comment">/*package*/</span> Runnable callback;</div><div class="line"></div><div class="line"><span class="comment">// sometimes we store linked lists of these things</span></div><div class="line"><span class="comment">/*package*/</span> Message next;</div></pre></td></tr></table></figure></p>
<ul>
<li>Message是实现了Parcelable序列化接口的。</li>
<li>what标明 Message 的类型 Id，调用者可以通过这个 what 做出相应的逻辑调整。</li>
<li>arg1 arg2 以及后面的 object 是用作额外数据传输的。</li>
<li>target 则定义了是哪一个消费者来处理哪一个 callback。因为一个 LooperThread 是允许存在多个 Handler 的，也就是多个消费者，而这些消息都被放置到一个 MessageQueue 队列中，target 就起到了区别它们的目的。callback 即实际要执行的东西。</li>
<li>Message 同时提供了 obtain() 方法，不推荐使用 new Message() 的方法，而是重复回收利用 Message，和 ThreadPool 的原理类似。</li>
</ul>
<h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MessageQueue就是存放Message的缓冲区，Android Framework 对其做了一些 JNI 的调用，来进行一些保护。<br>它是线程安全的，并提供了 Message next() 和 boolean enqueueMessage(Message msg, long when) 接口。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/IC709523.png" alt="Image"></p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>Looper 主要负责的工作是从 MessageQueue 中取出要执行的任务，也就是维护一个消息循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//This is a typical example of the implementation of a Looper thread</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> Handler mHandler;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Looper.prepare();</div><div class="line"></div><div class="line">       mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                <span class="comment">// process incoming messages here</span></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Looper.loop();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Looper源码给出了Looper运作的示例(在Looper源码注释中)。</p>
<p>通过Looper.prepare()进行相应的初始化工作，而Looper.loop()则正式开启消息循环。简单来说，Looper 使得一个普通的线程具备了消息循环的能力，也就是获取信息并消费的能力。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure><br> Looper.prepare()检查Looper是否创建，并保证其全局唯一性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;  </div><div class="line">        <span class="comment">//不断循环校验Message是否为空，不为空就派发消息</span></div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>首先检查Looper创建，如果没有就抛出异常。</p>
<p>进入消息循环，不断地从MessageQueue中获取要处理的消息，并通过方法进行消息派发。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msg.target.dispatchMessage(msg)</div></pre></td></tr></table></figure></p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler 在系统中承担的角色较为复杂，可是当做是全局的操作者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Handler 必须依附于相应的Looper线程，如果线程没有Looper 或者 Looper 没有调用 prepare 方法，会抛出new RuntimeException(“Can’t create handler inside thread that has not called Looper.prepare()”)的异常。</p>
<p>在这个构造函数里，赋值相应的 MessageQueue 和 callback。</p>
<p>callback即在 Looper Thread 要执行的任务，一般情况可以是在其他线程耗时操作执行完成后，回到Looper Thread 上要执行的UI 更新操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Callback interface you can use when instantiating a Handler to avoid</div><div class="line"> * having to implement your own subclass of Handler.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</div><div class="line"> * <span class="doctag">@return</span> True if no further handling is desired</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Handler 通过 post，postDelayed 等等方法，来将相应的 Message 发送到消息队列中去，最后通过 sendMessageAtTime() 来进行发送，进行的工作特别简单，将 Message.target 指定为自己，同时将自己加入到队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="机制总结"><a href="#机制总结" class="headerlink" title="机制总结"></a>机制总结</h2><ul>
<li>Handler 消息处理者<br>它主要有两大作用：① 处理Message。② 发送Message，并将某个Message压入到MessageQueue中。</li>
<li>Looper 轮询器<br>在 Looper里面的 loop()函数中有个死循环,它不断地从 MessageQueue 中取出一个Message,然后传给Handler进行处理,如此循环往复。假如队列为空,那么它会进入休眠。</li>
<li>MessageQueue 消息队列<br>消息队列中含有多个Message，每个Message中包含了具体的调用信息。</li>
<li>在每一个Application启动的时候，会给这个Application分配一个 ActivityThread ，就是我们所说的UI 线程。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/bz1080p.com_2015-03-06_05-37-47.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Intent和Binder</title>
    <link href="http://yoursite.com/2016/08/09/Android%E7%AC%94%E8%AE%B0-Intent%E5%92%8CBinder/"/>
    <id>http://yoursite.com/2016/08/09/Android笔记-Intent和Binder/</id>
    <published>2016-08-09T13:32:49.000Z</published>
    <updated>2016-08-12T12:48:28.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/1008240.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h1><p>Intent 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p>
<ul>
<li>启动 Activity</li>
<li>启动服务</li>
<li>发送广播</li>
</ul>
<h2 id="Intent-类型"><a href="#Intent-类型" class="headerlink" title="Intent 类型"></a>Intent 类型</h2><p>Intent 分为两种类型：</p>
<ol>
<li>显式 Intent ：按名称（完全限定类名）指定要启动的组件。通常，您会在自己的应用中使用显式 Intent 来启动组件，这是因为您知道要启动的 Activity 或服务的类名。例如，启动新 Activity 以响应用户操作，或者启动服务以在后台下载文件。</li>
<li>隐式 Intent ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理它。例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。</li>
</ol>
<p>创建显式 Intent 启动 Activity 或服务时，系统将立即启动 Intent 对象中指定的应用组件。</p>
<p>创建隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent 过滤器进行比较，从而找到要启动的相应组件。Intent如果 Intent 与 Intent 过滤器匹配，则系统将启动该组件，并将其传递给对象。如果多个 Intent 过滤器兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</p>
<p>为了确保应用的安全性，启动 Service 时，请始终使用显式 Intent，且不要为服务声明 Intent 过滤器。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 bindService()，系统会抛出异常。</p>
<h2 id="构建-Intent"><a href="#构建-Intent" class="headerlink" title="构建 Intent"></a>构建 Intent</h2><p>Intent 对象携带了 Android 系统用来确定要启动哪个组件的信息（例如，准确的组件名称或应当接收该 Intent 的组件类别），以及收件人组件为了正确执行操作而使用的信息（例如，要采取的操作以及要处理的数据）。</p>
<p>Intent 中包含的主要信息如下：</p>
<h3 id="组件名称"><a href="#组件名称" class="headerlink" title="组件名称"></a>组件名称</h3><p>要启动的组件名称。这是可选项，但也是构建显式 Intent 的一项重要信息，这意味着 Intent 应当仅传递给由组件名称定义的应用组件。如果没有组件名称，则 Intent 是隐式的，且系统将根据其他 Intent 信息（例如，以下所述的操作、数据和类别）决定哪个组件应当接收 Intent。因此，如需在应用中启动特定的组件，则应指定该组件的名称。</p>
<h3 id="操作-action"><a href="#操作-action" class="headerlink" title="操作(action)"></a>操作(action)</h3><p>指定要执行的通用操作（例如，“ACTION_VIEW”或“ACTION_SEND”）的字符串。对于广播 Intent，这是指已发生且正在报告的操作。操作在很大程度上决定了其余 Intent 的构成，特别是数据和 extra 中包含的内容。</p>
<h3 id="数据-data"><a href="#数据-data" class="headerlink" title="数据(data)"></a>数据(data)</h3><p>引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。提供的数据类型通常由 Intent 的操作决定。例如，如果操作是 ACTION_EDIT，则数据应包含待编辑文档的 URI。</p>
<p>要仅设置数据 URI，请调用 setData()。要仅设置 MIME 类型，请调用 setType()。如有必要，可以使用 setDataAndType() 同时显式设置二者。</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>一个包含应处理 Intent 组件类型的附加信息的字符串。您可以将任意数量的类别描述放入一个 Intent 中，但大多数 Intent 均不需要类别。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CATEGORY_BROWSABLE</div></pre></td></tr></table></figure><br>目标 Activity 允许本身通过 Web 浏览器启动，以显示链接引用的数据，如图像或电子邮件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CATEGORY_LAUNCHER</div></pre></td></tr></table></figure><br>该 Activity 是任务的初始 Activity，在系统的应用启动器中列出。</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的附加数据。</p>
<p>您可以使用各种 putExtra() 方法添加附加数据，每种方法均接受两个参数：键名和值。您还可以创建一个包含所有附加数据的 Bundle 对象，然后使用 putExtras() 将 Bundle 插入 Intent 中。</p>
<p>例如，使用 ACTION_SEND创建用于发送电子邮件的 Intent 时，可以使用 EXTRA_EMAIL 键指定“目标”收件人，并使用 EXTRA_SUBJECT 键指定“主题”。</p>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>在 Intent 类中定义的、充当 Intent 元数据的标志。标志可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个 任务 ），以及启动之后如何处理（例如，它是否属于最近的 Activity 列表）。</p>
<h2 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h2><p>要公布应用可以接收哪些隐式 Intent，请在清单文件中使用 <intent-filter> 元素为每个应用组件声明一个或多个 Intent 过滤器。每个 Intent 过滤器均根据 Intent 的操作、数据和类别指定自身接受的 Intent 类型。仅当隐式 Intent 可以通过 Intent 过滤器之一传递时，系统才会将该 Intent 传递给应用组件。</intent-filter></p>
<p>应用组件应当为自身可执行的每个独特作业声明单独的过滤器。例如，图像库应用中的一个 Activity 可能会有两个过滤器，分别用于查看图像和编辑图像。 当 Activity 启动时，它将检查 Intent 并根据 Intent 中的信息决定具体的行为（例如，是否显示编辑器控件）。每个 Intent 过滤器均由应用清单文件中的 &lt; intent-filter &gt; 元素定义，并嵌套在相应的应用组件（例如，&lt; activity &gt; 元素）中。在 &lt; intent-filter &gt; 内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p>
<h3 id="lt-action-gt"><a href="#lt-action-gt" class="headerlink" title="&lt; action &gt;"></a>&lt; action &gt;</h3><p>在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。</p>
<h3 id="lt-data-gt"><a href="#lt-data-gt" class="headerlink" title="&lt; data &gt;"></a>&lt; data &gt;</h3><p>使用一个或多个指定 数据 URI（scheme、host、port、path 等）各个方面和 MIME 类型的属性，声明接受的数据类型。</p>
<h3 id="lt-category-gt"><a href="#lt-category-gt" class="headerlink" title="&lt; category &gt;"></a>&lt; category &gt;</h3><p>在 name 属性中，声明接受的 Intent 类别。该值必须是操作的文本字符串值，而不是类常量。</p>
<p>注意：为了接收隐式 Intent，必须将 CATEGORY_DEFAULT 类别包括在 Intent 过滤器中。方法 startActivity() 和 startActivityForResult() 将按照已申明 [CATEGORY_DEFAULT]) 类别的方式处理所有 Intent。 如果未在 Intent 过滤器中声明此类别，则隐式 Intent 不会解析为你的 Activity。</p>
<h2 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h2><p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是从应用本身的进程中执行的一样。</p>
<p>待定 Intent 的主要用例包括：</p>
<ul>
<li>声明用户使用您的通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li>
<li>声明用户使用您的 应用小工具执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li>
<li>声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。</li>
</ul>
<p>由于每个 Intent 对象均设计为由特定类型的应用组件进行处理（Activity、Service 或 BroadcastReceiver），因此还必须基于相同的考虑因素创建PendingIntent。</p>
<p>使用待定 Intent 时，应用不会使用调用（如 startActivity()）执行该 Intent。相反，通过调用相应的创建器方法创建 PendingIntent时，必须声明所需的组件类型：</p>
<ul>
<li>PendingIntent.getActivity()，适用于启动 Activity 的 Intent。</li>
<li>PendingIntent.getService()，适用于启动 Service 的 Intent。</li>
<li>PendingIntent.getBroadcast()，适用于启动 BroadcastReceiver 的 Intent。</li>
</ul>
<h2 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h2><p>当系统收到隐式 Intent 以启动 Activity 时，它根据以下三个方面将该 Intent 与 Intent 过滤器进行比较，搜索该 Intent 的最佳 Activity：</p>
<ul>
<li>Intent 操作</li>
<li>Intent 数据（URI 和数据类型）</li>
<li>Intent 类别</li>
</ul>
<h3 id="操作测试-Action-Test"><a href="#操作测试-Action-Test" class="headerlink" title="操作测试(Action Test)"></a>操作测试(Action Test)</h3><ul>
<li>要指定接受的 Intent 操作， Intent 过滤器既可以不声明任何 &lt; action &gt; 元素，也可以声明多个此类元素。</li>
<li>要通过此过滤器，Intent 中指定的操作必须与过滤器中列出的某一操作匹配。</li>
<li>如果该过滤器未列出任何操作，则 Intent 没有任何匹配项，因此所有 Intent 均无法通过测试。但是，如果 Intent 未指定操作，则会通过测试（只要过滤器至少包含一个操作）。</li>
</ul>
<h3 id="类别测试-Category-Test"><a href="#类别测试-Category-Test" class="headerlink" title="类别测试(Category Test)"></a>类别测试(Category Test)</h3><ul>
<li>要指定接受的 Intent 类别， Intent 过滤器既可以不声明任何 &lt; category &gt;元素，也可以声明多个此类元素。</li>
<li>若要 Intent 通过类别测试，则 Intent 中的每个类别均必须与过滤器中的类别匹配。</li>
<li>反之则未必然，Intent 过滤器声明的类别可以超出 Intent 中指定的数量，且 Intent仍会通过测试。</li>
<li>因此，不含类别的 Intent 应当始终会通过此测试，无论过滤器中声明何种类别均是如此。</li>
<li>Android 会自动将 CATEGORY_DEFAULT 类别应用于传递给 startActivity()<br>和 startActivityForResult() 的所有隐式 Intent。因此，如需 Activity 接收隐式 Intent，则必须 “android.intent.category.DEFAULT” 的类别包括在其 Intent 过滤器中。</li>
</ul>
<h3 id="数据测试-Data-Test"><a href="#数据测试-Data-Test" class="headerlink" title="数据测试(Data Test)"></a>数据测试(Data Test)</h3><ul>
<li>要指定接受的 Intent 数据， Intent 过滤器既可以不声明任何 <data> 元素，也可以声明多个此类元素。</data></li>
<li>数据测试会将 Intent 中的 URI 和 MIME 类型与过滤器中指定的 URI 和 MIME 类型进行比较。</li>
<li>仅当过滤器未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</li>
<li>对于包含 URI、但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与过滤器的 URI 格式匹配、且过滤器同样未指定 MIME 类型时，才会通过测试。</li>
<li>仅当过滤器列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型、但不含 URI 的 Intent 才会通过测试。</li>
<li>仅当 MIME 类型与过滤器中列出的类型匹配时，包含 URI 和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与过滤器中的 URI 匹配，或者如果 Intent 具有 content: 或 file: URI 且过滤器未指定 URI，则 Intent 会通过测试的 URI 部分。换而言之，如果过滤器仅列出 MIME 类型，则假定组件支持 content: 和 file: 数据。</li>
</ul>
<h1 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1><p>首先Binder是Android系统进程间通信(IPC)方式之一。</p>
<p>Binder使用Client－Server通信方式。Binder框架定义了四个角色：Server,Client,ServiceManager以及Binder驱动。其中Server,Client,ServiceManager运行于用户空间，驱动运行于内核空间。Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信。</p>
<p>Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给ServiceManager，通知ServiceManager注册一个名字为XX的Binder，它位于Server中。</p>
<p>驱动为这个穿过进程边界的Binder创建位于内核中的实体结点以及ServiceManager对实体的引用，将名字以及新建的引用打包给ServiceManager。</p>
<p>ServiceManager收数据包后，从中取出名字和引用填入一张查找表中。但是一个Server若向ServiceManager注册自己Binder就必须通过0这个引用和ServiceManager的Binder通信。</p>
<p>Server向ServiceManager注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Clent也利用保留的0号引用向ServiceManager请求访问某个Binder：我申请名字叫XX的Binder的引用。</p>
<p>ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder引用，将该引用作为回复发送给发起请求的Client。</p>
<p>当然，不是所有的Binder都需要注册给ServiceManager广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。由于这个Binder没有向ServiceManager注册名字，所以是匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。</p>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>一个Binder服务器就是一个Binder类的对象。当创建一个Binder对象后，内部就会开启一个线程，这个线程用户接收binder驱动发送的消息，收到消息后，会执行相关的服务代码。</p>
<h2 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h2><p>当服务端成功创建一个Binder对象后，Binder驱动也会相应创建一个mRemote对象，该对象的类型也是Binder类，客户就可以借助这个mRemote对象来访问远程服务。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端要想访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binde对象的服务了。</p>
<p>客户是通过Binder驱动来调用服务端的相关服务。首先，在服务端创建一个Binder对象，接着客户端通过获取Binder驱动中Binder对象的引用来调用服务端的服务。在Binder机制中正是借着Binder驱动将不同进程间的组件bind(粘连)在一起，实现通信。</p>
<h1 id="Android跨进程通讯"><a href="#Android跨进程通讯" class="headerlink" title="Android跨进程通讯"></a>Android跨进程通讯</h1><p>Linux内核实际上没有从一个用户空间到另一个用户空间直接拷贝的函数，需要先用copy_from_user()拷贝到内核空间，再用copy_to_user()拷贝到另一个用户空间。为了实现用户空间到用户空间的拷贝，mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。</p>
<p>最底层的是Android的ashmen(Anonymous shared memory)机制，它负责辅助实现内存的分配，以及跨进程所需要的内存共享。AIDL(android interface definition language)对Binder的使用进行了封装，可以让开发者方便的进行方法的远程调用。Intent是最高一层的抽象，方便开发者进行常用的跨进程调用。</p>
<p>使用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次内存数据：一次从输入文件到共享内存区，另一次从共享内存到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域，而是保持共享区域，直到通信完成为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除内存映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<p>进程通讯方式:</p>
<ol>
<li>AIDL</li>
<li>Messenger(对AIDL进行了封装)</li>
<li>Broadcast</li>
<li>ContentProvider</li>
<li>Socket</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/1008240.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-四大组件</title>
    <link href="http://yoursite.com/2016/08/09/Android%E7%AC%94%E8%AE%B0-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2016/08/09/Android笔记-四大组件/</id>
    <published>2016-08-09T11:41:26.000Z</published>
    <updated>2016-08-09T13:18:18.497Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/c995d143ad4bd1135967435e58afa40f4bfb0537.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h1><p>所谓的四大组件，只是让你的APP告诉操作系统，自己要怎样运行而已，跟怎样设计自己的APP，压根没有关系。</p>
<p>传统的应用通过一个main方法，告诉操作系统：“嘿哥们，main方法就是我的入口，请从这个方法开始运行我。”而Android却给了你四个选择，每一个组件都是让操作系统运行你的APP的一种入口。</p>
<p>好了，操作系统要运行你的APP了，于是它调用你的main方法，然后你的应用就开始运行了，你可以做任何你想做的事情，直到你认为自己完成任务为止。请注意，这里要求你定义main方法，并不是要求你去做什么事，或是完成一个叫做main的功能，main方法所有的作用仅仅是提供一个APP运行入口而已。</p>
<p>但是在Android的世界，我们决定，我们不要一个明确的main方法作为APP的入口。因为我们需要让系统对APP怎样运行有更多的控制权。尤其是，我们希望构建一个这样的系统，在该系统中，用户永远不需要考虑开启和停止一个APP，而把这些事交给系统去管理。所以，系统需要知道更多的每个APP的内部运行情况，以便能够在需要的时候，以定义好的方式启动APP，即使该APP当时并不在运行。</p>
<p>这个系统所需要了解的每个APP的内部运行情况，其实就是Manifest.xml文件中的内容。</p>
<p>为了达到这一点，我们将一个APP的main方法分解成几种系统可以与之交互的形式。这几种形式就是Activity,BroadcastReceiver,Service和ContentProvider APIs，广大的Android开发者都很熟悉它们。</p>
<p>这些类好像在告诉你，你的APP内部应当怎样工作，但这是一种误解！事实上，这些类只是定义你的APP需要怎样与系统交互（以及系统怎样协调你的APP与其他APP进行交互）。这种与系统的交互一旦开始，系统就不再关心你的APP内部是怎样运行了。</p>
<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><p>这是一个APP与用户交互的入口。</p>
<h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><h3 id="任务栈是什么"><a href="#任务栈是什么" class="headerlink" title="任务栈是什么"></a>任务栈是什么</h3><p>任务栈Task，是一种用来放置Activity实例的容器，他是以栈的形式进行盛放，也就是所谓的先进后出，主要有2个基本操作：压栈和出栈，其所存放的Activity是不支持重新排序的，只能根据压栈和出栈操作更改Activity的顺序。</p>
<p>启动一个Application的时候，系统会为它默认创建一个对应的Task，用来放置根Activity。默认启动Activity会放在同一个Task中，新启动的Activity会被压入启动它的那个Activity的栈中，并且显示它。当用户按下回退键时，这个Activity就会被弹出栈，按下Home键回到桌面，再启动另一个应用，这时候之前那个Task就被移到后台，成为后台任务栈，而刚启动的那个Task就被调到前台，成为前台任务栈，Android系统显示的就是前台任务栈中的Top实例Activity。</p>
<h3 id="任务栈的作用"><a href="#任务栈的作用" class="headerlink" title="任务栈的作用"></a>任务栈的作用</h3><p>以往基于应用（application）的程序开发中，程序具有明确的边界，一个程序就是一个应用，一个应用为了实现功能可以采用开辟新线程甚至新进程来辅助，但是应用与应用之间不能复用资源和功能。而Android引入了基于组件开发的软件架构，虽然我们开发android程序，仍然使用一个apk工程一个Application的开发形式，但是对于Aplication的开发就用到了Activity、service等四大组件，其中的每一个组件，都是可以被跨应用复用的，这就是android的神奇之处。</p>
<p>虽然组件可以跨应用被调用，但是一个组件所在的进程必须是在组件所在的Aplication进程中。由于android强化了组件概念，弱化了Aplication的概念，所以在android程序开发中，A应用的A组件想要使用拍照或录像的功能就可以不用去针对Camera类进行开发，直接调用系统自带的摄像头应用（称其B应用）中的组件（称其B组件）就可以了，但是这就引发了一个新问题，A组件运行在A应用中，B组件运行在B应用中，自然都不在同一个进程中，那么从B组件中返回的时候，如何实现正确返回到A组件呢？</p>
<p>Task就是来负责实现这个功能的，它是从用户角度来理解应用而建立的一个抽象概念。因为用户所能看到的组件就是Activity，所以Task可以理解为实现一个功能而负责管理所有用到的Activity实例的栈。</p>
<h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><ul>
<li>默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。应用场景：绝大多数Activity。</li>
</ul>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><ul>
<li><p>栈顶复用模式，如果要开启的activity在任务栈的顶部已经存在，就不会创建新的实例，而是调用 onNewIntent() 方法。避免栈顶的activity被重复的创建。</p>
</li>
<li><p>应用场景：在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。</p>
</li>
</ul>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><ul>
<li><p>栈内复用模式， activity只会在任务栈里面存在一个实例。如果要激活的activity，在任务栈里面已经存在，就不会创建新的activity，而是复用这个已经存在的activity，调用 onNewIntent() 方法，并且清空这个activity任务栈上面所有的activity。</p>
</li>
<li><p>应用场景：大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，都应该使用将主界面Activity上所有的Activity移除的方式来让主界面Activity处于栈顶，而不是往栈顶新加一个主界面Activity的实例，通过这种方式能够保证退出应用时所有的Activity都能报销毁。</p>
</li>
<li><p>在跨应用Intent传递时，如果系统中不存在singleTask Activity的实例，那么将创建一个新的Task，然后创建SingleTask Activity的实例，将其放入新的Task中。</p>
</li>
</ul>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><ul>
<li><p>单一实例模式，整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。</p>
</li>
<li><p>应用场景：呼叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。建议谨慎使用。</p>
</li>
</ul>
<h3 id="设置Intent的Flag"><a href="#设置Intent的Flag" class="headerlink" title="设置Intent的Flag"></a>设置Intent的Flag</h3><p>系统提供了两种方式来设置一个Activity的启动模式，除了在AndroidManifest文件中设置以外，还可以通过Intent的Flag来设置一个Activity的启动模式，下面我们在简单介绍下一些Flag。</p>
<h4 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h4><ul>
<li>使用一个新的Task来启动一个Activity，但启动的每个Activity都将在一个新的Task中。该Flag通常使用在从Service中启动Activity的场景，由于Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。</li>
</ul>
<h4 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h4><ul>
<li>使用singletop模式启动一个Activity，与指定android：launchMode=“singleTop”效果相同。</li>
</ul>
<h4 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h4><ul>
<li>使用SingleTask模式来启动一个Activity，与指定android：launchMode=“singleTask”效果相同。</li>
</ul>
<h4 id="FLAG-ACTIVITY-NO-HISTORY"><a href="#FLAG-ACTIVITY-NO-HISTORY" class="headerlink" title="FLAG_ACTIVITY_NO_HISTORY"></a>FLAG_ACTIVITY_NO_HISTORY</h4><ul>
<li>Activity使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。</li>
</ul>
<h3 id="LaunchMode与StartActivityForResult"><a href="#LaunchMode与StartActivityForResult" class="headerlink" title="LaunchMode与StartActivityForResult"></a>LaunchMode与StartActivityForResult</h3><ul>
<li>在5.0之前，当启动一个Activity时，系统将首先检查Activity的launchMode，如果为A页面设置为SingleInstance或者B页面设置为singleTask或者singleInstance,则会在LaunchFlags中加入FLAG_ACTIVITY_NEW_TASK标志，而如果含有FLAG_ACTIVITY_NEW_TASK标志的话，onActivityResult将会立即接收到一个cancle的信息</li>
<li>而5.0之后这个方法做了修改，修改之后即便启动的页面设置launchMode为singleTask或singleInstance，onActivityResult依旧可以正常工作，也就是说无论设置哪种启动方式，StartActivityForResult和onActivityResult()这一组合都是有效的。所以如果你目前正好基于5.0做相关开发，不要忘了向下兼容。</li>
</ul>
<h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><p><img src="http://ob5qdb9lc.bkt.clouddn.com/1685558-d3176065dcf72d21.png" alt="Image"></p>
<ul>
<li>启动Activity: onCreate()—&gt;onStart()—&gt;onResume()，Activity进入运行状态。</li>
<li>Activity退居后台: 当前Activity转到新的Activity界面或按Home键回到主屏： onPause()—&gt;onStop()，进入停滞状态。</li>
<li>Activity返回前台: onRestart()—&gt;onStart()—&gt;onResume()，再次回到运行状态。</li>
<li>Activity退居后台，且系统内存不足， 系统会杀死这个后台状态的Activity（此时这个Activity引用仍然处在任务栈中，只是这个时候引用指向的对象已经为null），若再次回到这个Activity,则会走onCreate()–&gt;onStart()—&gt;onResume()(将重新走一次Activity的初始化生命周期)</li>
<li>锁屏：onPause()-&gt;onStop()</li>
<li>解锁：onStart()-&gt;onResume()</li>
</ul>
<p>如果一个Activity在用户可见时才处理某个广播，不可见时注销掉，那么应该在哪两个生命周期的回调方法去注册和注销BroadcastReceiver呢？</p>
<ul>
<li>Activity 的可见生命周期发生在 onStart调用与 onStop调用之间。在这段时间，用户可以在屏幕上看到 Activity 并与其交互。我们可以在 onStart中注册一个 BroadcastReceiver以监控影响 UI 的变化，并在用户无法再看到您显示的内容时在 onStop中将其取消注册。</li>
</ul>
<p>如果有一些数据在Activity跳转时（或者离开时）要保存到数据库，那么你认为是在onPause好还是在onStop执行这个操作好呢？</p>
<ul>
<li>onPause较容易被触发，所以我们在做BroadcastReceiver注销时放在onStop要好些。onPause时Activity界面仍然是可见的，如弹出一个Dialog时。但在保存数据时，放在onPause去做可以保证数据存储的有效性，如果放在onStop去做，在某些情况下Activity走完onPause后有可能还没顺利走到onStop就被系统回收了。</li>
<li>但要注意在onPause中要非常迅速地执行完所需操作，不然会影响到下一个Activity的生命周期函数的调用。</li>
</ul>
<p>Activity A启动Activity B时，两个Activity生命周期的变化。</p>
<ul>
<li>当一个 Activity 启动另一个 Activity 时，它们都会发生生命周期转变。第一个 Activity 暂停然后停止（但如果它在后台仍然可见，则不会停止，比如B是半透明的），系统会创建另一个 Activity。 如果这两个Activity 共用保存数据到文件或者数据库，必须要注意，在创建第二个 Activity 前，第一个 Activity 不会完全停止。更确切地说，启动第二个 Activity 的过程与停止第一个 Activity 的过程存在重叠。</li>
</ul>
<p>以下是当 Activity A 启动 Activity B 时一系列操作的发生顺序：</p>
<ol>
<li>Activity A 的 onPause方法执行。</li>
<li>Activity B 的 onCreate、onStart和 onResume方法依次执行。</li>
<li>然后，如果 Activity A 在屏幕上不再可见，则其 onStop方法执行。</li>
</ol>
<h2 id="自定义View的状态是如何保存的？"><a href="#自定义View的状态是如何保存的？" class="headerlink" title="自定义View的状态是如何保存的？"></a>自定义View的状态是如何保存的？</h2><p>先看一下Activity的状态如何保存的：</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/1685558-8eaf71b2bbf765b9.png" alt="Image"></p>
<p>注：无法保证系统会在销毁Activity前一定调用onSaveInstanceState，例如用户使用“返回” 按退出 Activity 时，因为用户的行为是在显式关闭 Activity，所以不会调用onSaveInstanceState。</p>
<p>Activity类的onSaveInstanceState默认实现会恢复Activity的状态，默认实现会为布局中的每个View调用相应的 onSaveInstanceState方法，让每个View都能保存自身的信息。</p>
<p>这里需要注意一个细节：想要保存View的状态，需要在XML布局文件中提供一个唯一的ID（android:id），如果没有设置这个ID的话，View控件的onSaveInstanceState是不会被调用的。</p>
<h2 id="两个Activity之间如何传递参数？"><a href="#两个Activity之间如何传递参数？" class="headerlink" title="两个Activity之间如何传递参数？"></a>两个Activity之间如何传递参数？</h2><p>大多数时候，我们也就传递一些简单的int，String类型的数据，实际中也有看到传递List和Bitmap的。</p>
<p>自定义对象可以实现Parcelable接口或继承Serializable来传递。</p>
<p>Serializalbe会使用反射，序列化和反序列化过程需要大量I/O操作，Parcelable自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在Native内存中，效率要快很多。</p>
<p>Intent中的Bundle是在使用Binder机制进行数据传递的，能使用的Binder的缓冲区是有大小限制的（有些手机是2M），而一个进程默认有16个binder线程，所以一个线程能占用的缓冲区就更小了（以前做过测试，大约一个线程可以占用128KB）</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context提供了一个应用的运行环境，通过这个上下文应用才可以访问资源，才能完成和其他组件、服务的交互。它就是一个调用者和具体实现的桥接。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/74d2f7b1-47ae-4637-85a7-4fe0e464daa1.png" alt="Image"></p>
<p>Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper。</p>
<p>Activity在创建的时候会new一个ContextImpl对象并在attach方法中关联它，Application和Service也差不多。ContextWrapper的方法内部都是转调ContextImpl的方法。</p>
<p>Application（或者Service）和Activity都可以调用Context的startActivity方法，那么在这两个地方调用startActivity有区别吗？</p>
<ul>
<li>在Application（或者Service）需要给Intent设置Intent.FLAG_ACTIVITY_NEW_TASK才能正常启动Activity</li>
</ul>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>当由于各种各样的原因需要APP在后台运行时，Service就是一个这样的入口。</p>
<p>Service是一个专门在后台处理长时间任务的Android组件，它没有UI。它有两种启动方式，startService和bindService。</p>
<h2 id="启动式服务（Started-Service）"><a href="#启动式服务（Started-Service）" class="headerlink" title="启动式服务（Started Service）"></a>启动式服务（Started Service）</h2><ul>
<li>应用组件通过 startService()方法来启动服务，一旦启动，服务会在后台运行，即使启动该服务的组件被销毁；</li>
<li>启动式服务不会向启动它的组件返回任何结果，也就是说，启动式服务不能与组件进行交互；</li>
<li>启动式服务一旦被启动，就会一直运行，直到它使用 stopSelf() 方法停止服务或在其他应用组件中使用 stopService() 方法停止服务。</li>
</ul>
<h3 id="启动式服务的生命周期"><a href="#启动式服务的生命周期" class="headerlink" title="启动式服务的生命周期"></a>启动式服务的生命周期</h3><p> onCreate() –&gt; onStartCommand() –&gt; onDestroy()</p>
<ol>
<li>onCreate()：第一次启动服务时调用，此后不再调用；</li>
<li>onStartCommand()：每次启动服务时调用；</li>
<li>onDestroy()：停止服务时调用。</li>
</ol>
<h2 id="绑定式服务（Bound-Service）"><a href="#绑定式服务（Bound-Service）" class="headerlink" title="绑定式服务（Bound Service）"></a>绑定式服务（Bound Service）</h2><ul>
<li>应用组将通过 bindService() 方法来绑定服务，服务只有在应用组件绑定它的时间内运行；</li>
<li>绑定式服务可以和绑定它的组件进行交互，甚至是执行进程间通信（IPC）；</li>
<li>多个应用组件可以绑定同一个服务，服务只在组件绑定它的时候运行，当所有的这些应用组件都使用 unbindService() 方法解绑服务（即没有组件跟服务绑定）时，服务会被销毁。</li>
</ul>
<h3 id="绑定式服务的生命周期"><a href="#绑定式服务的生命周期" class="headerlink" title="绑定式服务的生命周期"></a>绑定式服务的生命周期</h3><p>onCreate() –&gt; onBind() –&gt; onUnbind() –&gt; onDestroy()</p>
<ol>
<li>onCreate()：第一次启动服务时调用，此后不再调用；</li>
<li>onBind()：第一次绑定服务时调用，此后不再调用；</li>
<li>onUnbind()：解绑服务时调用</li>
<li>onDestroy()：解绑服务时调用。</li>
</ol>
<h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><ul>
<li>IntentService 继承自 Service，它使用一个 WorkerThread 来处理异步请求，每次处理一个请求；</li>
<li>IntentService 内部开启了一个子线程，专门用于执行耗时操作；</li>
<li>当所有请求处理完毕时，IntentService 会自己停止服务；</li>
<li>要使用 IntentService，必须自定义一个类，继承自 IntentService，实现 onHandleIntent() 方法，并需要有一个无参的构造方法且调用 super(String name)；</li>
<li>onHandleIntent() 方法运行在子线程当中，如果多次启动服务（即开启多个子线程），则各个子线程会依次排队执行，当所有的子线程执行完毕，IntentService 会自动停止服务，因此 IntentService 适合用来执行单线程操作。</li>
</ul>
<h1 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h1><p>这是一种让系统在正常的用户流（userflow）之外，传递事件给APP的机制。最重要的是，因为这是另一个被精心定义的APP的入口，即使APP当前并不在运行，系统也可以将broadcasts传递给APP。</p>
<h2 id="普通广播-Normal-Broadcast"><a href="#普通广播-Normal-Broadcast" class="headerlink" title="普通广播 (Normal Broadcast)"></a>普通广播 (Normal Broadcast)</h2><p>普通广播对于接收者来说是异步的，每个接收者都可以接收到广播，接收者不会相互干扰，也因此，接收者无法终止广播。</p>
<h2 id="有序广播-Ordered-Broadcast"><a href="#有序广播-Ordered-Broadcast" class="headerlink" title="有序广播 (Ordered Broadcast)"></a>有序广播 (Ordered Broadcast)</h2><p>有序广播每次只将广播发送给优先级较高的接收者，优先级高的接收者可以决定是将广播发送给优先级低的接收者，还是终止这个广播。</p>
<h2 id="粘性广播-Sticky-Broadcast"><a href="#粘性广播-Sticky-Broadcast" class="headerlink" title="粘性广播 (Sticky Broadcast)"></a>粘性广播 (Sticky Broadcast)</h2><p>Sticky简单说就是，在发送广播时Reciever还没有被注册，但它注册后还是可以收到在它之前发送的那条广播。</p>
<h2 id="静态注册和动态注册的区别"><a href="#静态注册和动态注册的区别" class="headerlink" title="静态注册和动态注册的区别"></a>静态注册和动态注册的区别</h2><ol>
<li>静态注册是在 AndroidManifest.xml 中注册，动态注册是在代码中注册；</li>
<li>静态注册是常驻型的，即使应用没有启动时也能接收广播；而动态注册的广播的生命周期受到其用来注册的 Activity 或 Service 的影响，当其用来注册的 Activity 或 Service 关闭时其广播也就失效了；</li>
<li>动态注册的广播在 Activity 或 Service 被销毁时必须解除注册，而静态注册的关闭则不用；</li>
<li>动态注册的优先级要比静态注册的优先级高。</li>
</ol>
<h2 id="BroadcastReceiver的生命周期"><a href="#BroadcastReceiver的生命周期" class="headerlink" title="BroadcastReceiver的生命周期"></a>BroadcastReceiver的生命周期</h2><p>Receiver也是有生命周期的，而且很短，当它的onReceive方法执行完成后，它的生命周期就结束了。</p>
<p>这时BroadcastReceiver已经不处于active状态，被系统杀掉的概率极高，也就是说如果你在onReceive去开线程进行异步操作或者打开Dialog都有可能在没达到你要的结果时进程就被系统杀掉。</p>
<p>因为这个进程可能只有这个Receiver这个组件在运行，当Receiver也执行完后就是一个empty进程，是最容易被系统杀掉的。</p>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><p>最后，ContentProvider是一个专用的办法，用来将你的APP的数据公开到其他地方。人们通常会将它们当作对数据库的抽象，因为有许多的API和支持库就是这样使用ContentProvider的。但是从系统设计的角度，这并不是ContentProvider的初衷。</p>
<p>对于系统来说，ContentProvider实际上是一个入口，用于获取一个APP内部的公开的被命名的数据项（data items），每个数据项都被一个URI scheme所标识。这样，APP就可以决定怎样将自己的数据项映射到一个URI scheme，怎样将这个URI scheme公开给其他APP或者系统，好让APP或者系统使用这个URI scheme来获取自己内部的数据。</p>
<h2 id="ContentProvider接口方法运行在哪个线程中呢？"><a href="#ContentProvider接口方法运行在哪个线程中呢？" class="headerlink" title="ContentProvider接口方法运行在哪个线程中呢？"></a>ContentProvider接口方法运行在哪个线程中呢？</h2><ol>
<li>ContentProvider和调用者在同一个进程，ContentProvider的方法（query/insert/update/delete等）和调用者在同一线程中；</li>
<li>ContentProvider和调用者在不同的进程，ContentProvider的方法会运行在它自身所在进程的一个Binder线程中。</li>
</ol>
<p>一个应用进程有16个Binder线程去和远程服务进行交互，而每个线程可占用的缓存空间是128KB这样，超过会报异常。ContentResolver虽然是通过Binder进程间通信机制打通了应用程序之间共享数据的通道，但Content Provider组件在不同应用程序之间传输数据是基于匿名共享内存机制来实现的。</p>
<p>参考资料：<br><a href="http://www.jianshu.com/p/07b87084337f" target="_blank" rel="external">关于Android四大组件最权威最深刻最准确的解读</a><br><a href="http://www.jianshu.com/p/2a9fcf3c11e4" target="_blank" rel="external">我打赌你一定没搞明白的Activity启动模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/c995d143ad4bd1135967435e58afa40f4bfb0537.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>操作系统笔记-Linux的IPC，内存管理</title>
    <link href="http://yoursite.com/2016/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-Linux%E7%9A%84IPC%EF%BC%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2016/08/08/操作系统笔记-Linux的IPC，内存管理/</id>
    <published>2016-08-08T12:24:14.000Z</published>
    <updated>2016-08-08T13:26:03.749Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/7.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="linux的IPC"><a href="#linux的IPC" class="headerlink" title="linux的IPC"></a>linux的IPC</h1><h3 id="管道（Pipe）及有名管道（Named-Pipe）"><a href="#管道（Pipe）及有名管道（Named-Pipe）" class="headerlink" title="管道（Pipe）及有名管道（Named Pipe）"></a>管道（Pipe）及有名管道（Named Pipe）</h3><p>管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p>
<h3 id="信号量（Signal）"><a href="#信号量（Signal）" class="headerlink" title="信号量（Signal）"></a>信号量（Signal）</h3><p>信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；</p>
<h3 id="报文（Message）队列（消息队列）"><a href="#报文（Message）队列（消息队列）" class="headerlink" title="报文（Message）队列（消息队列）"></a>报文（Message）队列（消息队列）</h3><p>消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</p>
<h3 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h3><p>主要作为进程间以及同一进程不同线程之间的同步手段。</p>
<h3 id="套接口（Socket）"><a href="#套接口（Socket）" class="headerlink" title="套接口（Socket）"></a>套接口（Socket）</h3><p>更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h3 id="进程的简单介绍"><a href="#进程的简单介绍" class="headerlink" title="进程的简单介绍"></a>进程的简单介绍</h3><p>进程是占有资源的最小单位，这个资源当然包括内存。在现代操作系统中，每个进程所能访问的内存是互相独立的（一些交换区除外）。而进程中的线程所以共享进程所分配的内存空间。<br>在操作系统的角度来看，进程=程序+数据+PCB(进程控制块)。</p>
<h3 id="没有内存抽象"><a href="#没有内存抽象" class="headerlink" title="没有内存抽象"></a>没有内存抽象</h3><p>在早些的操作系统中，并没有引入内存抽象的概念。程序直接访问和操作的都是物理内存。比如当执行如下指令时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov reg1,<span class="number">1000</span></div></pre></td></tr></table></figure><br>这条指令会毫无想象力的将物理地址1000中的内容赋值给寄存器。不难想象，这种内存操作方式使得操作系统中存在多进程变得完全不可能，比如MS-DOS，你必须执行完一条指令后才能接着执行下一条。如果是多进程的话，由于直接操作物理内存地址，当一个进程给内存地址1000赋值后，另一个进程也同样给内存地址赋值，那么第二个进程对内存的赋值会覆盖第一个进程所赋的值，这回造成两条进程同时崩溃。</p>
<h3 id="内存抽象"><a href="#内存抽象" class="headerlink" title="内存抽象"></a>内存抽象</h3><p>为了解决直接操作内存带来的各种问题，引入的地址空间(Address Space),这允许每个进程拥有自己的地址。这还需要硬件上存在两个寄存器，基址寄存器(base register)和界址寄存器(limit register),第一个寄存器保存进程的开始地址，第二个寄存器保存上界，防止内存溢出。在内存抽象的情况下，当执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov reg1,<span class="number">20</span></div></pre></td></tr></table></figure><br>这时，实际操作的物理地址并不是20，而是根据基址和偏移量算出实际的物理地址进程操作，此时操作的实际地址可能是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov reg1,<span class="number">16245</span></div></pre></td></tr></table></figure><br>在这种情况下，任何操作虚拟地址的操作都会被转换为操作物理地址。而每一个进程所拥有的内存地址是完全不同的，因此也使得多进程成为可能。<br>但此时还有一个问题，通常来说，内存大小不可能容纳下所有并发执行的进程。因此，交换(Swapping)技术应运而生。交换的基本思想是，将闲置的进程交换出内存，暂存在硬盘中，待执行时再交换回内存。</p>
<h3 id="进程内存是动态变化的"><a href="#进程内存是动态变化的" class="headerlink" title="进程内存是动态变化的"></a>进程内存是动态变化的</h3><p>实际情况下，进程往往会动态增长，因此创建进程时分配的内存就是个问题了，如果分配多了，会产生内部碎片，浪费了内存，而分配少了会造成内存溢出。一个解决方法是在进程创建的时候，比进程实际需要的多分配一点内存空间用于进程的增长。一种是直接多分配一点内存空间用于进程在内存中的增长，另一种是将增长区分为数据段和栈（用于存放返回地址和局部变量）。</p>
<h3 id="空间不足的解决方案"><a href="#空间不足的解决方案" class="headerlink" title="空间不足的解决方案"></a>空间不足的解决方案</h3><p>当预留的空间不够满足增长时，操作系统首先会看相邻的内存是否空闲，如果空闲则自动分配，如果不空闲，就将整个进程移到足够容纳增长的空间内存中，如果不存在这样的内存空间，则会将闲置的进程置换出去。</p>
<h3 id="内存的管理策略"><a href="#内存的管理策略" class="headerlink" title="内存的管理策略"></a>内存的管理策略</h3><p>当允许进程动态增长时，操作系统必须对内存进行更有效的管理，操作系统使用如下两种方法之一来得知内存的使用情况，分别为1)位图(bitmap) 2)链表<br>使用位图，将内存划为多个大小相等的块，比如一个32K的内存1K一块可以划为32块，则需要32位（4字节）来表示其使用情况，使用位图将已经使用的块标为1，位使用的标为0.而使用链表，则将内存按使用或未使用分为多个段进行链接</p>
<p>使用位图表示内存简单明了，但一个问题是当分配内存时必须在内存中搜索大量的连续0的空间，这是十分消耗资源的操作。相比之下，使用链表进行此操作将会更胜一筹。还有一些操作系统会使用双向链表，因为当进程销毁时，邻接的往往是空内存或是另外的进程。使用双向链表使得链表之间的融合变得更加容易。<br>还有，当利用链表管理内存的情况下，创建进程时分配什么样的空闲空间也是个问题。通常情况下有如下几种算法来对进程创建时的空间进行分配。</p>
<ul>
<li>临近适应算法(Next fit)—从当前位置开始，搜索第一个能满足进程要求的内存空间</li>
<li>最佳适应算法(Best fit)—搜索整个链表，找到能满足进程要求最小内存的内存空间</li>
<li>最大适应算法(Wrost fit)—找到当前内存中最大的空闲空间</li>
<li>首次适应算法(First fit) —从链表的第一个开始，找到第一个能满足进程要求的内存空间</li>
</ul>
<h3 id="虚拟内存-Virtual-Memory"><a href="#虚拟内存-Virtual-Memory" class="headerlink" title="虚拟内存(Virtual Memory)"></a>虚拟内存(Virtual Memory)</h3><p>虚拟内存是现代操作系统普遍使用的一种技术。前面所讲的抽象满足了多进程的要求，但很多情况下，现有内存无法满足仅仅一个大进程的内存要求(比如很多游戏，都是10G+的级别)。在早期的操作系统曾使用覆盖(overlays)来解决这个问题，将一个程序分为多个块，基本思想是先将块0加入内存，块0执行完后，将块1加入内存。依次往复，这个解决方案最大的问题是需要程序员去程序进行分块，这是一个费时费力让人痛苦不堪的过程。后来这个解决方案的修正版就是虚拟内存。</p>
<p>虚拟内存的基本思想是，每个进程有用独立的逻辑地址空间，内存被分为大小相等的多个块,称为页(Page).每个页都是一段连续的地址。对于进程来看,逻辑上貌似有很多内存空间，其中一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)，还有一些没加载在内存中的对应在硬盘上。</p>
<h3 id="进程内存空间"><a href="#进程内存空间" class="headerlink" title="进程内存空间"></a>进程内存空间</h3><p>Linux采用虚拟内存管理技术，每个进程都有各自独立的进程地址空间(即4G的线性虚拟空间)，无法直接访问物理内存。这样起到保护操作系统，并且让用户程序可使用比实际物理内存更大的地址空间。</p>
<ul>
<li>4G进程地址空间被划分两部分，内核空间和用户空间。用户空间从0到3G，内核空间从3G到4G；</li>
<li>用户进程通常情况只能访问用户空间的虚拟地址，不能访问内核空间虚拟地址。只有用户进程进行系统调用(代表用户进程在内核态执行)等情况可访问到内核空间；</li>
<li>用户空间对应进程，所以当进程切换，用户空间也会跟着变化；</li>
<li>内核空间是由内核负责映射，不会跟着进程变化；内核空间地址有自己对应的页表，用户进程各自有不同进程页表。</li>
</ul>
<h3 id="Windows内存管理"><a href="#Windows内存管理" class="headerlink" title="Windows内存管理"></a>Windows内存管理</h3><p>Windows 内存管理方式主要分为：页式管理，段式管理，段页式管理。</p>
<ul>
<li>页式管理的优点是没有外碎片，每个内碎片不超过页的大小。缺点是,程序全部装入内存，要求有相应的硬件支持。</li>
<li>段式管理优点是可以分别编写和编译，可以针对不同类型的段采用不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。缺点是会产生碎片。</li>
<li>段页式管理是段式管理与页式管理方案结合而成的所以具有他们两者的优点。但反过来说，由于管理软件的增加，复杂性和开销也就随之增加了。</li>
</ul>
<p>分页存储管理基本思想：</p>
<ul>
<li>用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</li>
</ul>
<p>分段存储管理基本思想：</p>
<ul>
<li>将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</li>
</ul>
<p>段页式存储管理基本思想：</p>
<ul>
<li>分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。</li>
<li>在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。</li>
<li>段页式系统中，作业的地址结构包含三部分的内容：段号 页号 页内位移量</li>
<li>程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。</li>
<li>为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。</li>
</ul>
<hr>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="http://blog.jobbole.com/95499/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">浅谈操作系统对内存的管理</a><br><a href="http://gityuan.com/2015/10/30/kernel-memory/" target="_blank" rel="external">Linux内存管理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/7.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统笔记" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP笔记-Cookie与Session、Socket、访问网页</title>
    <link href="http://yoursite.com/2016/08/08/TCP-IP%E7%AC%94%E8%AE%B0-Cookie%E4%B8%8ESession%E3%80%81Socket%E3%80%81%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5/"/>
    <id>http://yoursite.com/2016/08/08/TCP-IP笔记-Cookie与Session、Socket、访问网页/</id>
    <published>2016-08-08T10:56:04.000Z</published>
    <updated>2016-08-08T12:10:59.861Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/d554b4c564c5acac_1322227437_2062812989.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是当你浏览某网站时，网站存储在你机器上的一个小文本文件，它可以记录你的用户ID，密码、浏览过的网页、停留的时间等信息，当你再次来到该网站时，网站通过读取Cookie，得知你的相关信息，就可以做出相应的动作，例如在页面显示欢迎你的标语，或者让你不用输入ID、密码就直接登录等。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 存储在服务器端，一般放在服务器的内存中。Session 对象存储特定用户会话所需的信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。</p>
<h2 id="Cookie的设置与发送过程"><a href="#Cookie的设置与发送过程" class="headerlink" title="Cookie的设置与发送过程"></a>Cookie的设置与发送过程</h2><p>一个cookie的设置以及发送过程分为以下四步：</p>
<ol>
<li>客户端发送一个http请求到服务器端;</li>
<li>服务器端发送一个http响应到客户端，其中包含Set-Cookie头部;</li>
<li>客户端发送一个http请求到服务器端，其中包含Cookie头部;</li>
<li>服务器端发送一个http响应到客户端。</li>
</ol>
<h2 id="如何防止session超时？"><a href="#如何防止session超时？" class="headerlink" title="如何防止session超时？"></a>如何防止session超时？</h2><p>导致这个问题的关键词有两个：一个是「长时间」，一个是「未操作」。　</p>
<p>如果用户未操作的「长时间」超过了服务器配置的session超时时间，并导致session失效，那么我们延长session的超时时间，让用户原来的「长时间」与超时时间相比，变得不「长」，不就可以解决了吗？　　</p>
<p>如果用户是长时间「未操作」导致session失效，那么我们想办法产生「操作」，让用户每隔一小段时间就「操作」一次，与服务器产生交互，那么session自然也不会失效。</p>
<h2 id="Cookie-和Session-的区别与应用"><a href="#Cookie-和Session-的区别与应用" class="headerlink" title="Cookie 和Session 的区别与应用"></a>Cookie 和Session 的区别与应用</h2><p>Cookie和session由于实现手段不同，因此也各有优缺点和各自的应用场景：</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>Cookie的典型应用场景是Remember Me服务，即用户的账户信息通过cookie的形式保存在客户端，当用户再次请求匹配的URL的时候，账户信息会被传送到服务端，交由相应的程序完成自动登录等功能。当然也可以保存一些客户端信息，比如页面布局以及搜索历史等等。</p>
<p>Session的典型应用场景是用户登录某网站之后，将其登录信息放入session，在以后的每次请求中查询相应的登录信息以确保该用户合法。当然还是有购物车等等经典场景；</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Cookie将信息保存在客户端，如果不进行加密的话，无疑会暴露一些隐私信息，安全性很差，一般情况下敏感信息是经过加密后存储在cookie中，但很容易就会被窃取。而session只会将信息存储在服务端，如果存储在文件或数据库中，也有被窃取的可能，只是可能性比cookie小了太多。</p>
<p>Session安全性方面比较突出的是存在会话劫持的问题，这是一种安全威胁。总体来讲，session的安全性要高于cookie。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Cookie存储在客户端，消耗的是客户端的I/O和内存，而session存储在服务端，消耗的是服务端的资源。但是session对服务器造成的压力比较集中，而cookie很好地分散了资源消耗，就这点来说，cookie是要优于session的；<br>但是Cookie会增加网络流量。</p>
<h3 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h3><p>Cookie可以通过设置有效期使其较长时间内存在于客户端，而session一般只有比较短的有效期（也可以通过用户主动销毁session或关闭浏览器后引发超时）；</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Cookie的处理在开发中没有session方便。而且cookie在客户端是有数量和大小的限制的，而session的大小却只以硬件为限制，能存储的数据无疑大了很多。</p>
<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h2 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket"></a>什么是Socket</h2><p>我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。</p>
<p>能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p>
<h2 id="使用TCP"><a href="#使用TCP" class="headerlink" title="使用TCP"></a>使用TCP</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"ip"</span>, 端口);</div><div class="line"></div><div class="line">InputStream is = socket.getInputStream();</div><div class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(is);</div><div class="line"></div><div class="line">OutputStream os = socket.getOutputStream();</div><div class="line">DataInputStream dos = <span class="keyword">new</span> DataOutputStream(os);</div></pre></td></tr></table></figure>    
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(端口);</div><div class="line">Socket socket = serverSocket.accept();</div><div class="line"><span class="comment">//获取流的方式与客户端一样</span></div></pre></td></tr></table></figure>      
<h3 id="读取输入流"><a href="#读取输入流" class="headerlink" title="读取输入流"></a>读取输入流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">do&#123;</div><div class="line">    <span class="keyword">int</span> count = is.read(buffer);</div><div class="line">    <span class="keyword">if</span>(count &lt;= <span class="number">0</span>)&#123; <span class="keyword">break</span>; &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">// 对buffer保存或者做些其他操作</span></div><div class="line">    &#125;</div><div class="line">&#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>     
<h2 id="使用UDP"><a href="#使用UDP" class="headerlink" title="使用UDP"></a>使用UDP</h2><p>客户端和服务器端一样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(端口);</div><div class="line">InetAddress serverAddress = InetAddress.getbyName(<span class="string">"ip"</span>);</div><div class="line"><span class="comment">//发送</span></div><div class="line">DatagramPackage packet = <span class="keyword">new</span> DatagramPacket(buffer, length, host, port);</div><div class="line">socket.send(packet);</div><div class="line"><span class="comment">//接收</span></div><div class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, <span class="number">1024</span>);</div><div class="line">Socket.receive(packet);</div></pre></td></tr></table></figure></p>
<h1 id="访问网页的过程"><a href="#访问网页的过程" class="headerlink" title="访问网页的过程"></a>访问网页的过程</h1><h2 id="1-在浏览器里输入网址"><a href="#1-在浏览器里输入网址" class="headerlink" title="1.在浏览器里输入网址"></a>1.在浏览器里输入网址</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">facebook.com</div></pre></td></tr></table></figure>
<h2 id="2-浏览器查找域名的IP地址"><a href="#2-浏览器查找域名的IP地址" class="headerlink" title="2.浏览器查找域名的IP地址"></a>2.浏览器查找域名的IP地址</h2><p>DNS查找过程如下：</p>
<ul>
<li>浏览器缓存 – 浏览器会缓存DNS记录一段时间。操作系统没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。</li>
<li>系统缓存 – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname）。这样便可获得系统缓存中的记录。</li>
<li>路由器缓存 – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。</li>
<li>ISP DNS 缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。</li>
<li>递归搜索 – 你的ISP的DNS服务器从跟域名服务器开始进行递归搜索，从.com顶级域名服务器到Facebook的域名服务器。一般DNS服务器的缓存中会 有.com域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。  <h2 id="3-浏览器给web服务器发送一个HTTP请求"><a href="#3-浏览器给web服务器发送一个HTTP请求" class="headerlink" title="3. 浏览器给web服务器发送一个HTTP请求"></a>3. 浏览器给web服务器发送一个HTTP请求</h2></li>
</ul>
<p>因为像Facebook主页这样的动态页面，打开后在浏览器缓存中很快甚至马上就会过期，毫无疑问他们不能从中读取。所以，浏览器将把一下请求发送到Facebook所在的服务器。</p>
<h2 id="4-服务的永久重定向响应"><a href="#4-服务的永久重定向响应" class="headerlink" title="4. 服务的永久重定向响应"></a>4. 服务的永久重定向响应</h2><p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“HTTP://www.facebook.com/” 而非“HTTP://facebook.com/”。</p>
<p>为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像HTTP://www.igoro.com/和HTTP://igoro.com/，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有一个是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p>
<h2 id="5-浏览器跟踪重定向地址"><a href="#5-浏览器跟踪重定向地址" class="headerlink" title="5. 浏览器跟踪重定向地址"></a>5. 浏览器跟踪重定向地址</h2><p>现在，浏览器知道了 “HTTP://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求</p>
<h2 id="6-服务器“处理”请求"><a href="#6-服务器“处理”请求" class="headerlink" title="6. 服务器“处理”请求"></a>6. 服务器“处理”请求</h2><p>服务器接收到获取请求，然后处理并返回一个响应。</p>
<h2 id="7-服务器发回一个HTML响应"><a href="#7-服务器发回一个HTML响应" class="headerlink" title="7. 服务器发回一个HTML响应"></a>7. 服务器发回一个HTML响应</h2><h2 id="8-浏览器开始显示HTML"><a href="#8-浏览器开始显示HTML" class="headerlink" title="8. 浏览器开始显示HTML"></a>8. 浏览器开始显示HTML</h2><p>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了：</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/image6.png" alt="Image"></p>
<h2 id="9-浏览器发送请求获取嵌入在HTML中的对象"><a href="#9-浏览器发送请求获取嵌入在HTML中的对象" class="headerlink" title="9. 浏览器发送请求获取嵌入在HTML中的对象"></a>9. 浏览器发送请求获取嵌入在HTML中的对象</h2><p>在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。<br>下面是几个我们访问facebook.com时需要重获取的几个URL：</p>
<ul>
<li>图片<br>HTTP://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif<br>HTTP://static.ak.fbcdn.net/rsrc.php/zBS5C/hash/7hwy7at6.gif</li>
<li>CSS 式样表<br>HTTP://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css<br>HTTP://static.ak.fbcdn.net/rsrc.php/zANE1/hash/cvtutcee.css</li>
<li>JavaScript 文件<br>HTTP://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js<br>HTTP://static.ak.fbcdn.net/rsrc.php/z6R9L/hash/cq2lgbs8.js<br>…</li>
</ul>
<p>这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…</p>
<p>但不像动态页面那样，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取。服务器的响应中包含了静态文件保存的期限信息，所以浏览器知道要把它们缓存多长时间。还有，每个响应都可能包含像版本号一样工作的ETag头（被请求变量的实体值），如果浏览器观察到文件的版本 ETag信息已经存在，就马上停止这个文件的传输。</p>
<p>“fbcdn.net”在地址中代表什么？答案是”Facebook内容分发网络”。Facebook利用内容分发网络 （CDN）分发像图片，CSS表和JavaScript文件这些静态文件。所以，这些文件会在全球很多CDN的数据中心中留下备份。</p>
<p>静态内容往往代表站点的带宽大小，也能通过CDN轻松的复制。通常网站会使用第三方的CDN。例如，Facebook的静态文件由最大的 CDN提供商Akamai来托管。举例来讲，当你试着ping static.ak.fbcdn.net的时候，可能会从某个akamai.net服务器上获得响应。有意思的是，当你同样再ping一次的时候，响应的服务器可能就不一样，这说明幕后的负载平衡开始起作用了。</p>
<h2 id="10-浏览器发送异步（AJAX）请求"><a href="#10-浏览器发送异步（AJAX）请求" class="headerlink" title="10. 浏览器发送异步（AJAX）请求"></a>10. 浏览器发送异步（AJAX）请求</h2><p>在Web 2.0伟大精神的指引下，页面显示完成后客户端仍与服务器端保持着联系。</p>
<p>以 Facebook聊天功能为例，它会持续与服务器保持联系来及时更新你那些亮亮灰灰的好友状态。为了更新这些头像亮着的好友状态，在浏览器中执行的 JavaScript代码会给服务器发送异步请求。这个异步请求发送给特定的地址，它是一个按照程式构造的获取或发送请求。还是在Facebook这个例子中，客户端发送给HTTP://www.facebook.com/ajax/chat/buddy_list.php一个发布请求来获取你好友里哪个 在线的状态信息。</p>
<p>Facebook聊天功能提供了关于AJAX一个有意思的问题案例：把数据从服务器端推送到客户端。因为HTTP是一个请求-响应协议，所 以聊天服务器不能把新消息发给客户。取而代之的是客户端不得不隔几秒就轮询下服务器端看自己有没有新消息。</p>
<p>这些情况发生时,长轮询是个减轻服务器负载挺有趣的技术。如果当被轮询时服务器没有新消息，它就不理这个客户端。而当尚未超时的情况下收到了该客户的新消息，服务器就会找到未完成的请求，把新消息做为响应返回给客户端。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/d554b4c564c5acac_1322227437_2062812989.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="TCP/IP笔记" scheme="http://yoursite.com/categories/TCP-IP%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP笔记-Http协议</title>
    <link href="http://yoursite.com/2016/08/08/TCP-IP%E7%AC%94%E8%AE%B0-Http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2016/08/08/TCP-IP笔记-Http协议/</id>
    <published>2016-08-08T09:55:49.000Z</published>
    <updated>2016-08-11T13:04:25.680Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/14593.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTTP通信过程包括从客户端发往服务器端的请求及从服务端返回客户端的响应。<br>用于HTTP协议交互的信息被称为HTTP报文，请求端的HTTP报文是请求报文，响应端的HTTP报文是响应报文。<br>HTTP报文本身是由多行数据构成的字符串文本。</p>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/85c019ab-1fc3-48c5-84d7-bd9545aa24f2.png" alt="Image"></p>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>响应报文基本上是由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/5b438c2b-5933-4b97-9d15-ffcebcfc950a.png" alt="Image"></p>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>HTTP方法指定请求的资源按期望产生某种行为。</p>
<ul>
<li>GET：获取资源<br>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的是文本资源，那就保持原样返回；如果是像CGI（Common Gateway Interface，通用网管接口）那样的程序，则返回执行后的结果。</li>
<li>POST：传输实体的主体<br>POST方法用来传输实体的主体。<br>虽然用GET方法也能传输实体的主体，但是一般不用GET方法进行传输，而是用POST方法。虽说两者功能很像，但是POST的主要目的不是获取响应的主体内容。</li>
<li>HEAD：获取报文首部<br>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。</li>
<li>OPTIONS：询问支持的方法<br>OPTIONS方法用来查询针对请求的URI制定的资源支持的方法。</li>
<li>PUT：传输文件<br>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求的URI制定的位置。<br>但是鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题。因此一般的Web网站不采用该方法。若配合Web应用程序的验证机制，或者架构设计采用REST标准的同类Web网站，可能使用PUT方法。</li>
<li>DELETE：删除文件<br>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。<br>但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的。</li>
</ul>
<h2 id="HTTP请求URI指定方式"><a href="#HTTP请求URI指定方式" class="headerlink" title="HTTP请求URI指定方式"></a>HTTP请求URI指定方式</h2><p>当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URI包含在内。指定请求URI的方式有以下几种：</p>
<ul>
<li>URI为完整的请求URI<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET http:<span class="comment">//hackr.jp/index.html HTTP/1.1</span></div></pre></td></tr></table></figure>   </li>
<li>在首部字段Host中写明网络域名或IP地址<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GET /index.html HTTP/<span class="number">1.1</span></div><div class="line">Host:hackr.jp</div></pre></td></tr></table></figure>   </li>
<li>如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求URI<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OPTIONS * HTTP/<span class="number">1.1</span> （查询HTTP服务器端支持的HTTP方法种类）</div></pre></td></tr></table></figure>   
<h2 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h2>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。<br>状态码如200 OK，以3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种。</li>
</ul>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/592a62d1-6e36-4d98-b7ba-9a042e241053.png" alt="Image"></p>
<h2 id="HTTP-1-1与HTTP-1-0的比较"><a href="#HTTP-1-1与HTTP-1-0的比较" class="headerlink" title="HTTP 1.1与HTTP 1.0的比较"></a>HTTP 1.1与HTTP 1.0的比较</h2><p>一个WEB站点每天可能要接收到上百万的用户请求，为了提高系统的效率，HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</p>
<p>每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能。</p>
<p>为了克服HTTP 1.0的这个缺陷，HTTP1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<p>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p>
<p>不仅如此，HTTP 1.1还通过增加更多的请求头(请求首部字段)和响应头(响应首部字段)来改进和扩充HTTP1.0的功能。例如，由于HTTP1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。</p>
<p>在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。</p>
<p>HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。</p>
<p>HTTP 协议老的标准是HTTP/1.0，目前最通用的标准是HTTP/1.1。HTTP/1.1是在HTTP/1.0基础上的升级，增加了一些功能，全面兼容 HTTP/1.0。HTTP/1.0不支持文件断点续传，目前的Web服务器绝大多数都采用了HTTP/1.1。</p>
<p>RANGE:bytes是HTTP/1.1新增内容，HTTP/1.0每次传送文件都是从文件头开始，即0字节处开始。RANGE:bytes=XXXX表示要求服务器从文件XXXX字节处开始传送，这就是我们平时所说的断点续传！</p>
<h2 id="两种-HTTP-请求方法：GET-和-POST"><a href="#两种-HTTP-请求方法：GET-和-POST" class="headerlink" title="两种 HTTP 请求方法：GET 和 POST"></a>两种 HTTP 请求方法：GET 和 POST</h2><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。<br>GET - 从指定的资源请求数据。<br>POST - 向指定的资源提交要被处理的数据</p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p><img src="http://ob5qdb9lc.bkt.clouddn.com/72ce40bb-9548-4015-bdf5-2cc2af361426.png" alt="Image"></p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p><img src="http://ob5qdb9lc.bkt.clouddn.com/eb086ed6-08ed-4e3f-8814-d0ca1090039c.png" alt="Image"></p>
<h3 id="比较GET-和-POST"><a href="#比较GET-和-POST" class="headerlink" title="比较GET 和 POST"></a>比较GET 和 POST</h3><p><img src="http://ob5qdb9lc.bkt.clouddn.com/8b4c18ba-01c6-41a9-b1db-d2bdf663d784.png" alt="Image"></p>
<h2 id="HTTP-长连接和短连接"><a href="#HTTP-长连接和短连接" class="headerlink" title="HTTP 长连接和短连接"></a>HTTP 长连接和短连接</h2><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发送端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p>
<p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>
<p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p>
<p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Connection:keep-alive</div></pre></td></tr></table></figure><br>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>
<p>模拟一下长连接的情况，client 向 server 发起连接，server 接受 client 连接，双方建立连接。Client 与 server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将永远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。</p>
<p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p>
<ul>
<li>客户主机依然正常运行，并从服务器可达。客户的 TCP 响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的 TCP 都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li>
</ul>
<p>短连接的操作步骤是：<br>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p>
<p>长连接的操作步骤是：<br>建立连接——数据传输…（保持连接）…数据传输——关闭连接</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/14593.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="TCP/IP笔记" scheme="http://yoursite.com/categories/TCP-IP%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP笔记-TCP/IP网络模型</title>
    <link href="http://yoursite.com/2016/08/07/TCP-IP%E7%AC%94%E8%AE%B0-TCP-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2016/08/07/TCP-IP笔记-TCP-IP网络模型/</id>
    <published>2016-08-07T13:33:24.000Z</published>
    <updated>2016-08-07T14:54:38.625Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/maxresdefault%20%281%29.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="OSI七层与TCP-IP五层网络架构"><a href="#OSI七层与TCP-IP五层网络架构" class="headerlink" title="OSI七层与TCP/IP五层网络架构"></a>OSI七层与TCP/IP五层网络架构</h1><p>OSI七层模型称为开放式系统互联参考模型，是一个逻辑上的定义，一个规范，解释了协议相互之间应该如何相互作用。<br>TCP/IP协议是美国国防部发明的，是让互联网称为目前这个样子的标准之一。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/28171557-35956e615787467ca35cc61f3d97da1f.jpg" alt="Image"></p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h3><p>TFTP（Trivial File TransferProtocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。TFTP是一个传输文件的简单协议，它基于UDP协议而实现，但是我们也不能确定有些TFTP协议是基于其它传输协议完成的。</p>
<p>此协议设计的时候是进行小文件传输的。因此它不具备通常的FTP的许多功能，它只能从文件服务器上获得或写入文件，不能列出目录，不进行认证，它传输8位数据。传输中有三种模式：netascii，这是8位的ASCII码形式，另一种是octet，这是8位源数据类型；最后一种mail已经不再支持，它将返回的数据直接返回给用户而不是保存为文件。</p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。</p>
<p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。</p>
<p>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。</p>
<h3 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h3><p>简单网络管理协议（SNMP），由一组网络管理的标准组成，包含一个应用层协议（application layer protocol）、数据库模型（database schema）和一组资源对象。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</p>
<p>该协议是互联网工程工作小组（IETF，Internet Engineering Task Force）定义的internet协议簇的一部分。SNMP的目标是管理互联网Internet上众多厂家生产的软硬件平台，因此SNMP受Internet标准网络管理框架的影响也很大。SNMP已经出到第三个版本的协议，其功能较以前已经大大地加强和改进了。</p>
<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。</p>
<p>在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。</p>
<p>SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<p>DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。</p>
<h3 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h3><p>Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p>
<p>在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。</p>
<p>在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p>
<p>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。</p>
<p>TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<p>UDP协议全称是用户数据报协议 ，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。UDP协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP仍然不失为一项非常实用和可行的网络传输层协议。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>网络之间互连的协议（IP）是Internet Protocol的外语缩写，网络之间互连的协议也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。IP地址具有唯一性，根据用户性质的不同，可以分为5类。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/97427414-0717-461c-9291-597b75dd743e.jpg" alt="Image"></p>
<ol>
<li>A类IP地址<br>一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围1.0.0.1-126.255.255.254,可用的A类网络有126个，每个网络能容纳1677214个主机。</li>
<li>B类IP地址<br>一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围128.1.0.1-191.255.255.254,可用的B类网络有16384个，每个网络能容纳65534主机 。</li>
<li>C类IP地址<br>一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围192.0.1.1-223.255.255.254,C类网络可达2097152个，每个网络能容纳254个主机。</li>
<li>D类地址用于多点广播（Multicast）。<br>D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。<br>地址范围224.0.0.1-239.255.255.254</li>
<li>E类IP地址<br>以“1111”开始，为将来使用保留。<br>E类地址保留，仅作实验和开发用。</li>
</ol>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。</p>
<p>这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它是一个非常重要的协议，它对于网络安全具有极其重要的意义。</p>
<p>它是TCP/IP协议族的一个子协议，属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。</p>
<p>ICMP报文在IP帧结构的首部协议类型字段（Protocol 8bit)的值=1。我们在网络中经常会使用到ICMP协议，比如我们经常使用的用于检查网络通不通的Ping命令（Linux和Windows中均有），这个“Ping”的过程实际上就是ICMP协议工作的过程。还有其他的网络命令如跟踪路由的Tracert命令也是基于ICMP协议的。</p>
<h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>RIP（Routing Information Protocol，路由信息协议）是一种基于距离矢量的路由协议，以路由条数作为计数单位的路由协议。适合用于比较小型的网络环境。RIP协议主要用于一个AS（自治系统）内的路由信息的传递，每30秒发送一次路由信息更新，RIP协议提供跳跃计数（hop count）作为尺度来衡量路由距离，跳跃计数是一个包到达目标所必须经过的路由器的数目，RIP最多支持的跳跃数为15。  </p>
<h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>OSPF(Open Shortest Path First开放式最短路径优先）是一个内部网关协议(Interior Gateway Protocol，简称IGP），用于在单一自治系统（autonomous system,AS）内决策路由。是对链路状态路由协议的一种实现，隶属内部网关协议（IGP），故运作于自治系统内部。<br>著名的迪克斯加算法(Dijkstra)被用来计算最短路径树。OSPF分为OSPFv2和OSPFv3两个版本,其中OSPFv2用在IPv4网络，OSPFv3用在IPv6网络。OSPFv2是由RFC 2328定义的，OSPFv3是由RFC 5340定义的。与RIP相比，OSPF是链路状态协议，而RIP是距离矢量协议。IETF为了满足建造越来越大基于IP网络的需要，形成了一个工作组，专门用于开发开放式的链路状态路由协议，以便用在大型、异构的I P网络中。</p>
<h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议。 BGP 构建在 EGP 的经验之上。 BGP 系统的主要功能是和其他的 BGP 系统交换网络可达信息。网络可达信息包括列出的自治系统（AS）的信息。这些信息有效地构造了 AS 互联的拓朴图并由此清除了路由环路，同时在 AS 级别上可实施策略决策。</p>
<h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>Internet 组管理协议称为IGMP协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p>
<h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><p>反向地址转换协议（RARP：Reverse Address Resolution Protocol） 反向地址转换协议（RARP）允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。网络管理员在局域网网关路由器里创建一个表以映射物理地址（MAC）和与其对应的 IP 地址。当设置一台新的机器时，其 RARP 客户机程序需要向路由器上的 RARP 服务器请求相应的 IP 地址。假设在路由表中已经设置了一个记录，RARP 服务器将会返回 IP 地址给机器，此机器就会存储起来以便日后使用。</p>
<h1 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h1><p>TCP/IP模型，最基本的internet协议，由网络层的IP和传输层的TCP构成，指TCP/IP协议簇。</p>
<h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><p>TCP:传输控制协议，提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控，全双工操作和多路复用。是一个全双工、面向连接、可靠的并且是精确控制的协议。<br>主要是用在那些实时性不强，但要求不能出错的应用，比如网页浏览，文件的下载，邮件的收发等场合。</p>
<p>UDP:用户数据报协议，是面向非连接的协议，是一个不可靠的传输协议，不排序所要发送的数据段，不关心这些数据到达目的方的顺序，所以网络开销比TCP小得多。<br>主要用在实时性强，允许出错的场合，比如即时通信，视频，语音等方面。   </p>
<h2 id="TCP报文格式（基于字节流）"><a href="#TCP报文格式（基于字节流）" class="headerlink" title="TCP报文格式（基于字节流）"></a>TCP报文格式（基于字节流）</h2><p>源端口号（2字节）    目的端口号（2字节）<br>TCP报文中的源端口号同目的端口号同IP数据报中的源IP与目的IP确定一条TCP连接。</p>
<p>数据序号（4字节） sequence number<br>用来标识TCP发端向TCP收端发送的数据字节流</p>
<p>确认序号（4字节）acknowledgement number<br>期望收到对方的下一个报文段的数据的第一个字节的序号</p>
<p>首部长度（4位）<br>指出报文数据距TCP报文的起始处有多远</p>
<p>标志位（12位）<br>reserved(6位)  保留今后使用，目前置0处理</p>
<p>URG(紧急标志)  URG=1时，表明紧急指针字段有效。它告诉系统此报文有紧急数据，应尽快传送。</p>
<p>ACK(确认标志) ACK=1时，确认号序号字段才有效，ACK=0，确认序号无效。</p>
<p>PSH(推送标志)PSH=1，接收方就尽快地交付给接收方应用进程，而不再等待整个缓存都填满了后再向上交付。</p>
<p>RST(复位标志)RST=1，表明TCP连接中出现了严重差错，必须释放连接，然后再重新建立运输连接。</p>
<p>SYN(同步标志)SYN=1，就表明这是一个连接请求或者连接接收报文。</p>
<p>FIN(终止标志)FIN=1，表明此报文段的发送端的数据已发送完毕，要求释放连接。</p>
<p>窗口大小(2字节) 控制对方发送的数据量。</p>
<p>检验和(2字节) 包括首部和数据两部分，由发送端计算存储，接收端验证。</p>
<p>紧急指针(2字节) 紧急指针指出本报文段中紧急数据的最后一个字节的序号。</p>
<p>选项字段(0~40字节)把附加信息传递给终点。</p>
<h2 id="TCP三次握手，四次挥手"><a href="#TCP三次握手，四次挥手" class="headerlink" title="TCP三次握手，四次挥手"></a>TCP三次握手，四次挥手</h2><p><img src="http://ob5qdb9lc.bkt.clouddn.com/jellythinkTCP4111.png" alt="Image"></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol>
<li>客户端发送SYN=1，随机（当开启TCP会话时，初始序列号是随机的）产生sequence number的数据包到服务器，服务器由SYN=1知道，客户端要建立连接。</li>
<li>服务端收到请求后确认联机信息，向A发送acknowledge number=sequence number+1，SYN=1，ACK=1，随机产生sequence number的数据包。</li>
<li>客户端收到检查acknowledge number是否正确，若正确，则发送acknowledge number=sequence number+1，ACK=1的数据包。服务端收到后确认sequence number=sequence number+1，ACK=1则连接建立成功。</li>
</ol>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol>
<li>客户端发送一个FIN=1，ACK=1，sequence number，acknowledge number的数据包到服务端。</li>
<li>服务端收到这个FIN，发回一个ACK，acknowledge number=sequence number+1。</li>
<li>.服务端关闭与客户端的连接，发送一个FIN，sequence number给客户端。</li>
<li>客户端发回ACK确认，acknowledge number=sequecne number+1。</li>
</ol>
<h3 id="为什么挥手多一次"><a href="#为什么挥手多一次" class="headerlink" title="为什么挥手多一次"></a>为什么挥手多一次</h3><p>由于TCP连接是全双工的，因此每个方向都必须单独关闭。当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方被动关闭。</p>
<h3 id="TCP连接状态"><a href="#TCP连接状态" class="headerlink" title="TCP连接状态"></a>TCP连接状态</h3><ul>
<li>CLOSED：初始状态，表示TCP连接是“关闭着的”或“未打开的”。</li>
<li>LISTEN ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。</li>
<li>SYN_RCVD ：表示接收到了SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。</li>
<li>SYN_SENT ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。</li>
<li>ESTABLISHED ：表示TCP连接已经成功建立。</li>
<li>FIN_WAIT_1 ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。</li>
<li>FIN_WAIT_2 ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2是没有超时的（不像TIME_WAIT状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个FIN_WAIT_2状态将一直保持到系统重启，越来越多的FIN_WAIT_2状态会导致内核crash。</li>
<li>TIME_WAIT ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>
<li>CLOSING ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。</li>
<li>CLOSE_WAIT ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</li>
<li>LAST_ACK ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。</li>
</ul>
<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><h3 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h3><p>为了提高信道的利用率TCP协议不使用停止等待协议，而是使用连续ARQ协议，意思就是可以连续发出若干个分组然后等待确认，而不是发送一个分组就停止并等待该分组的确认。</p>
<p>TCP的两端都有发送/接收缓存和发送/接收窗口。TCP的缓存是一个循环队列，其中发送窗口可以用3个指针表示。而发送窗口的大小受TCP数据报中窗口大小的影响，TCP数据报中的窗口大小是接收端通知发送端其还可以接收多少数据，所以发送窗口根据接收的的窗口大小的值动态变化。</p>
<h3 id="TCP流量控制-1"><a href="#TCP流量控制-1" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>所谓流量控制就是让发送发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制。<br>原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。</p>
<p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送方将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p>
<p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p>
<h3 id="传输效率及Nagle算法"><a href="#传输效率及Nagle算法" class="headerlink" title="传输效率及Nagle算法"></a>传输效率及Nagle算法</h3><p>TCP的数据传输分为交互数据流和成块数据流，交互数据流一般是一些交互式应用程序的命令，所以这些数据很小，而考虑到TCP报头和IP报头的总和就有40字节，如果数据量很小的话，那么网络的利用效率就较低。</p>
<p>数据传输使用Nagle算法，Nagle算法很简单，就是规定一个TCP连接最多只能有一个未被确认的未完成的小分组。在该分组的确认到达之前不能发送其他的小分组。</p>
<p>但是也要考虑另一个问题，叫做糊涂窗口综合症。当接收方的缓存已满的时候，交互应用程序一次只从缓存中读取一个字节（这时候缓存中腾出一个字节），然后向发送方发送确认信息，此时发送方再发送一个字节（收到的窗口大小为1），这样网络的效率很低。</p>
<p>所以要解决这个问题，可以让接收方等待一段时间，使得接收缓存已有最够的空间容纳一个最长报文段，或者等到接收缓存已有一半的空间。只要这两种情况出现一种，就发送确认报文，同时发送方可以把数据积累成大的报文段发送。</p>
<p>##TCP拥塞控制<br>计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做拥塞。</p>
<p>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。</p>
<h3 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h3><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。</p>
<p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<br>当cwnd&lt; ssthresh时，使用慢开始算法。<br>当cwnd&gt; ssthresh时，改用拥塞避免算法。<br>当cwnd= ssthresh时，慢开始与拥塞避免算法任意。</p>
<p>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。</p>
<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。<br><img src="http://ob5qdb9lc.bkt.clouddn.com/ca427b8a-7b23-429a-b351-344c95a75f64.png" alt="Image"></p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。如下图：</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/8ec8322d-14e7-4324-ae9a-786f683ac6ec.png" alt="此处输入图片的描述"></p>
<p>快重传配合使用的还有快恢复算法，有以下两个要点:</p>
<ol>
<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li>
<li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。如下图：</li>
</ol>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/f6b86bd9-e909-43c5-b372-c6c868130d2a.png" alt="Image"></p>
<h3 id="随机早期检测RED"><a href="#随机早期检测RED" class="headerlink" title="随机早期检测RED"></a>随机早期检测RED</h3><p>以上的拥塞避免算法并没有和网络层联系起来，实际上网络层的策略对拥塞避免算法影响最大的就是路由器的丢弃策略。在简单的情况下路由器通常按照先进先出的策略处理到来的分组。当路由器的缓存装不下分组的时候就丢弃到来的分组，这叫做尾部丢弃策略。</p>
<p>这样就会导致分组丢失，发送方认为网络产生拥塞。更为严重的是网络中存在很多的TCP连接，这些连接中的报文段通常是复用路由路径。若发生路由器的尾部丢弃，可能影响到很多条TCP连接，结果就是这许多的TCP连接在同一时间进入慢开始状态。这在术语中称为全局同步。全局同步会使得网络的通信量突然下降很多，而在网络恢复正常之后，其通信量又突然增大很多。</p>
<p>为避免发生网路中的全局同步现象，路由器采用随机早期检测(RED:randomearly detection)。该算法要点如下：<br>使路由器的队列维持两个参数，即队列长队最小门限min和最大门限max，每当一个分组到达的时候，RED就计算平均队列长度。然后分情况对待到来的分组：</p>
<ol>
<li>平均队列长度小于最小门限——把新到达的分组放入队列排队。</li>
<li>平均队列长度在最小门限与最大门限之间——则按照某一概率将分组丢弃。</li>
<li>平均队列长度大于最大门限——丢弃新到达的分组。</li>
</ol>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/d80e4755-3a72-4714-b932-b7641b67691d.png" alt="Image"></p>
<p>以概率p随机丢弃分组，让拥塞控制只在个别的TCP连接上执行，因而避免全局性的拥塞控制。<br>RED的关键就是选择三个参数最小门限、最大门限、丢弃概率和计算平均队列长度。平均队列长度采用加权平均的方法计算平均队列长度，这和往返时间（RTT）的计算策略是一样的。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/6c9be1bd-7cdc-40c0-8705-d5691d3a8a46.png" alt="Image"></p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/ddf80591-632e-469f-a4f4-73c096273d42.png" alt="Image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/maxresdefault%20%281%29.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="TCP/IP笔记" scheme="http://yoursite.com/categories/TCP-IP%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记-多线程</title>
    <link href="http://yoursite.com/2016/08/07/Java%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/07/Java笔记-多线程/</id>
    <published>2016-08-07T12:03:54.000Z</published>
    <updated>2016-08-07T13:04:01.425Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/t01c8028393c3f209ad.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常，每一个任务称为一个线程，它是线程控制的简称，可以同时运行一个以上线程的程序称为多线程程序。</p>
<p>多进程与多线程区别：每一个进程拥有自己的一整套变量，而线程则共享数据。这是有风险的，但共享变量使线程之间的通信要比进程之间的通信更有效、更容易。此外，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>下面是在一个单独的线程执行一个任务的简单过程：</p>
<ol>
<li>将任务代码移到Runnable接口的类的run方法中，可以如下实现一个类：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    task code;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>创建一个类对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Runnable r=<span class="keyword">new</span> Runnable();</div></pre></td></tr></table></figure>  </li>
<li>由Runnable对象创建一个Thread对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread t=<span class="keyword">new</span> Thread(r);</div></pre></td></tr></table></figure>    </li>
<li>启动线程：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.start();</div></pre></td></tr></table></figure>   
</li>
</ol>
<p>不要调用Thread类或Runnable对象的Run方法。直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用Thread.start方法。这个方法将创建一个执行run方法的新线程。</p>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>当线程的run方法执行方法体中最后一条语句后，并经过有执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。</p>
<p>没有可以强制线程终止的方法，然而，interrupt方法可以用来请求终止线程。</p>
<p>当对线程调用interrupt方法时，线程的中断状态将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时检查这个标志，以判断线程是否被中断。</p>
<p>要想弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用isInterrupted方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupt())&#123;</div><div class="line">    do more work</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>但是如果线程被阻塞，就无法检测中断状态，这是产生InterruptException异常的地方。当在一个被阻塞的线程(调用sleep或wait)上调用interrupt方式时，阻塞调用将会被InterruptException异常中断。</p>
<p>没有任何语言方面的需求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。重要的线程应该处理完异常后继续执行而不理会中断。但是，普遍的情况是，线程简单地将中断作为一个终止的请求。</p>
<p>Interrupted方法是一个静态方法，它检测当前的线程是否中断。而且，调用interrupted方法会清除该线程的中断状态(将当前线程的中断状态重置为false)。isInterrupted方法是一个实例方法，可以用来检验是否有线程被中断。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程可以有6种状态：</p>
<ol>
<li>New(新创建)</li>
<li>Runnable(可运行)</li>
<li>Blocked(被阻塞)</li>
<li>Waiting(等待)</li>
<li>Timed waiting(计时等待)</li>
<li>Terminated(被终止)</li>
</ol>
<p>要想确定一个线程的当前状态，可调用getState方法。</p>
<h3 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h3><p>当用new操作符创建一个新线程时，该线程还没有开始运行。这意味着它的状态是new。当一个线程处于被创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。</p>
<h3 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h3><p>一旦调用start方法，线程处于runnable状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供的运行时间。</p>
<p>一旦一个线程开始运行，它不必始终保存运行。事实上，运行的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。</p>
<p>抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另外一个线程运行机会。当选择下一个线程是，操作系统会考虑线程的优先级。</p>
<p>协同式调度系统线程的执行时间由线程本身控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。一个线程只有在调用yield方法，或者被阻塞或等待时，线程才失去控制权。</p>
<p>在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行(这就是将这个状态称为可运行而不是运行)。</p>
<h3 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h3><p>当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。</p>
<ul>
<li>当一个线程试图获取一个内部的对象锁(而不是java.util.concurrent库中的锁)，而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。</li>
<li>当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是在等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。</li>
<li>有几个方法有一个超时参数。调用它们导致线程进入计时等待状态。这一状态将一致保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep和Object.wait、Thread.join等。</li>
</ul>
<h3 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h3><p>线程因如下两个原因之一而被终止：</p>
<ol>
<li>因为run方法正常退出而死亡。</li>
<li>因为一个没有捕获的异常终止了run方法而意外死亡。</li>
</ol>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>Java线程优先级是高度依赖系统的。当虚拟机依赖与宿主机平台的线程实现机制是，Java线程的优先级被映射到宿主机平台的优先级上。<br>如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>可以通过调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.setDaemon（<span class="keyword">true</span>）; <span class="comment">//这个方法必须在线程启动之前调用</span></div></pre></td></tr></table></figure><br>将线程转换为守护线程。守护线程的唯一是为其他线程提供服务。当只剩守护线程时，虚拟机就退出了，由于如果只剩守护线程，就没必要继续运行程序了。守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时刻甚至在一个操作中间发生中断。</p>
<h3 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h3><p>线程的run方法不能抛出任何被检测的异常，但是，不被检测的异常会导致线程终止。在这种情况下，线程就死亡了。</p>
<p>不需要任何catch子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。</p>
<p>可以为线程安装一个处理器。如果不安装默认的处理器，默认处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>根据各线程访问数据的顺序，可能会产生讹误的对象。这样一个情况通常称为竞争条件。</p>
<h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>有两种机制防止代码块受并发访问的干扰。Java语言提供一个synchronized关键字达到这一目的，并且Java SE5.0引入ReentrantLock类。synchronized关键字自动提供一个锁以及相关的“条件”，对于大多数需要显式锁的情况，这是很便利的。java.util.concurrent框架为这些继承机制提供了独立的类。用ReentrantLock保护代码块的基本结构如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">myLock.lock();</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">    ...</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">    myLock.unLock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这一结构确保任何时刻中有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。</p>
<p>锁是可以重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同方法的锁的方法。</p>
<h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>通常，线程进入临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得一个锁但是却不能做有用工作的线程。</p>
<p>一个锁对象可以有一个或多个相关的条件对象。可以使用newCondition方法获得一个条件对象。</p>
<p>等待获得锁的线程和调用await方法的线程存在本质上的不同。一旦一个线程调用await方法，它现在被阻塞了，并放弃了锁，进入该条件的等待集。当锁可用的时候，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的signalAll方法时为止。</p>
<p>signalAll方法重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们，同时，它们将试图重新进入该对象。一旦锁称为可用的，它们中的某个将从await调用返回，获得该锁并从被阻塞的地方继续执行。</p>
<p>此时，线程应该再次测试该条件。由于无法确保该条件被满足——signalAll方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检查该条件。</p>
<p>至关重要的是最终需要某个其他线程调用signAll方法。当一个线程调用await时，它没有办法重新激活自身。它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不再运行了。这导致死锁现象。如果所有其他线程被阻塞，最后一个活动线程在解除其他线程的阻塞状态之前就调用了await方法，那么它也被阻塞。没有任何线程可以解除其他线程的阻塞，那么程序就挂起了。</p>
<p>调用signalAll不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问。</p>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>锁和条件的关键之处：</p>
<ul>
<li>锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。</li>
<li>锁可以管理试图进入被保护代码段的线程。</li>
<li>锁可以拥有一个或多个相关的条件对象。</li>
<li>每个条件对象管理那些已经进入被保护的代码段但还不能运行的代码。</li>
</ul>
<p>Java中每一个对象都有一个内部锁。如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得对象的内部锁。</p>
<p>内部锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll/notify方法解除等待线程的阻塞状态。</p>
<p>将静态方法声明为synchronized也是合法的。如果调用这个方法，该方法获得相关的类内部的对象锁。</p>
<p>内部锁和条件存在一些局限。包括：</p>
<ol>
<li>不能中断一个正在试图获得锁的线程</li>
<li>视图获得锁时不能设定超时</li>
<li>每个锁仅有单一的条件，可能是不够的。</li>
</ol>
<h3 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h3><p>每一个Java对象有一个锁。线程可以调用同步方法获得锁。还有另外一种机制可以获得锁，通过进入一个同步阻塞。当线程进入如下形式的阻塞：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(obj)<span class="comment">//this is the syntax for a synchronized block</span></div><div class="line">&#123;</div><div class="line">    critical section</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>于是它获得obj的锁。</p>
<h3 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h3><ul>
<li>volatile关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另外一个线程并发更新的。</li>
<li>volatile变量不能提供原子性。</li>
</ul>
<h3 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h3><ul>
<li>还有一种情况可以安全地访问一个共享域，即这个域声明为final。</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul>
<li>假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为volatile。</li>
<li>java.util.concurrent.atomic包中有很多类使用了机器级指令(而不是使用锁)来保证其他操作的原子性。例如，AtomicInteger类提供了方法incrementAndGet和decrementAndGet，它们分别以原子方式将一个整数自增或自减。可以安全地使用AtomicInteger作为共享计数器而无须同步。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>Java编程语言没有任何东西可以避免或打破死锁现象。必须仔细设计程序以确保不会出现死锁。</li>
</ul>
<h3 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h3><p>有时要避免共享变量，使用ThreadLocal辅助类为各个线程提供各自的实例。</p>
<p>要为每个线程构造一个实例，可以使用以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormat=</div><div class="line">    <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br>要访问具体的格式化方法，可以调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String dateStamp=dateFormat.get().format(<span class="keyword">new</span> Date());</div></pre></td></tr></table></figure><br>在多个线程中生成随机数也存在类似的问题。java.util.Romdom类是线程安全的。但是如果多个线程需要等待一个共享的随机数生成器，这会很低效。<br>可以使用ThreadLocal辅助类为各个线程提供一个单独的生成器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> random=ThreadLocalRandom.current().nextInt(upperBound);</div></pre></td></tr></table></figure><br>ThreadLocalRandom.current()调用会返回特定于当前线程的Romdom类实例。</p>
<h3 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h3><p>线程在调用lock方法来获得另外一个线程的持有的锁时候，很可能发生阻塞。应该更谨慎地申请锁。tryLock方法试图申请一个锁，在成功获得锁后返回true，否则，立即返回false，而且线程可以立即离开去做其他事情。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(myLock.tryLock())</div><div class="line">    <span class="keyword">try</span>&#123;...&#125;</div><div class="line">    <span class="keyword">finally</span>&#123;myLock.unLock();&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="comment">//do something else</span></div></pre></td></tr></table></figure><br>可以调用tryLock时，使用超时参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(myLock.tryLock(<span class="number">100</span>,TimeUnit.MILLISECONDS));</div></pre></td></tr></table></figure><br>lock方法不能中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁，那么，lock方法就无法终止。<br>然而，如果调用带有超时参数的tryLock，那么如果线程在等待期间被中断，将会抛出异常。这是一个有用的特性，因为允许程序打破死锁。</p>
<h3 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读/写锁"></a>读/写锁</h3><p>java.util.concurrent.locks包定义了两个锁类：ReentrantLock类和ReentrantReadWriteLock类。如果很多线程从一个数据结构读取数据而很少线程修改其中的数据的话，后者是十分有用的。允许读者线程共享访问是合适的，写者线程依然是互斥访问的。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>对于许多多线程问题，可以通过使用一个或多个队列将其形式化。生产者线程向队列中插入元素，消费者线程则取出它们。</p>
<p>当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列导致线程阻塞。队列会自动地平衡负载。</p>
<p>java.util.concurrent包提供了阻塞队列的几个变种。默认情况下，LinkedBlockingQueue的容量是没有上边界的，但是也可以选择指定最大容量。LinkedBlockingDeque是一个双端版本。ArrayBlockingQueue在构造时需要指定容量，并且有一个可选的参数来直到是否需要公平性。PriorityBlockingQueue是一个带优先级的队列，而不是先进先出队列。</p>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><p>可以通过提供锁来保护共享数据结构，但是选择线程安全的实现作为替代可能更容易些。</p>
<h3 id="高效的映射表、集合和队列"><a href="#高效的映射表、集合和队列" class="headerlink" title="高效的映射表、集合和队列"></a>高效的映射表、集合和队列</h3><ul>
<li>java.util.concurrent包提供了映射表、有许集和队列的高效实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue。</li>
<li>这些集合使用了复杂的算法，通过允许并发访问数据结构的不同部分来使竞争极小化。</li>
<li>集合返回弱一致性的迭代器。这意味着迭代器不一定能反映出它们被构造之后的所有修改。</li>
</ul>
<h3 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h3><ul>
<li>CopyOnWriteArrayList和CopyOnWriteArrayList是线程安全的集合，其中所有的修改线程对底层数组进行复制。如果在集合上进行迭代的线程数超过修改线程数，这样的安排是很有用的。当构建一个迭代器的时候，它包含一个对当前数组的引用。如果数组后来被修改了，迭代器仍然引用旧数组，但是，集合的数组已经被替换的。因而，旧的迭代器拥有一致的视图，访问它无须任何同步开销。</li>
</ul>
<h3 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h3><p>Vertor和Hashtable类提供了线程安全的动态数组和散列表的实现。现在这些类被弃用了，取而代之的是ArrayList和HashMap类。这些类不是线程安全的，而集合库中提供了不同的机制。任何集合可以通过使用同步包装器变成线程安全的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;E&gt; synchArrayList=Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</div><div class="line">Map&lt;K,V&gt; synchHashMap=Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;K,V&gt;());</div></pre></td></tr></table></figure><br>如果在另一个线程可能进行修改时要对集合进行迭代，仍需要使用锁定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(synchHashMap)&#123;</div><div class="line">    Itertor&lt;K&gt; iter=synchHashMap.keySet().iterator();</div><div class="line">    <span class="keyword">while</span>(iter.hasNext())...;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果使用了“for each”循环必须使用同样的代码，因为循环使用了迭代器。如果在迭代过程中，别的线程修改集合，迭代器会失效，抛出异常。同步仍然是需要的，因此并发的修改可以被可靠地检测出来。</p>
<p>最好使用java.util.concurrent包中定义的集合，不使用同步包装器中的。</p>
<h2 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h2><ul>
<li>Runnable封装一个异步运行的任务，可以把它想象成为一个没有参数和返回值的异步方法，Callable域Runnable类似，但是有返回值。Callable接口是一个参数化的类型，只有一个方法call。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>          
参数类型是返回值的类型。例如Callable<integet>表示一个最终返回Integer对象的异步计算。</integet></li>
<li>Future保存异步计算的结果。可以启动一个计算，将Future对象交给某个线程，然后忘掉他。Future对象的所有者在结果计算好之后就可以获得它。</li>
</ul>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>构建一个新的线程是有一定代价的，因为涉及与操作系统的交互。如果程序中创建了大量生命周期很短的线程，应该使用线程池。一个线程池包含许多准备运行的空闲线程。将Runnable对象交给线程池，就会有一个线程调用run方法。当run方法退出 时，线程不会死亡，而是在池中准备为下一个请求线程提供服务。</p>
<p>另一个使用线程池的理由是减少并发线程的数目。创建大量线程会大大降低性能甚至使虚拟机崩溃。如果有一个会创建许多线程的算法，应该使用一个线程数“固定的”线程池以限制并发线程的总数。</p>
<p>执行器类有许多静态工厂方法用来构建线程池。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>newCachedThreadPool方法构建了一个线程池，对于每个任务，如果有空闲线程可用，立即让它执行任务，如果没有可用的空闲线程，则创建一个新线程。</li>
<li>newFixedThreadPool方法构建一个具有固定大小的线程池。如果提交的任务数多于空闲的线程数，那么把得不到服务的任务放置到队列中。当其他任务完成以后再运行它们。</li>
<li>newSingleThreadExecutor是一个退化了的大小为1的线程池：有一个线程执行提交的任务，一个接一个。</li>
</ul>
<p>当用完一个线程池的时候，调用shutdown。该方法启动该池的关闭队列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡。另一种方法是调用shutdownNow，该池取消尚开始的所有任务并试图中断正在运行的线程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/t01c8028393c3f209ad.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java笔记" scheme="http://yoursite.com/categories/Java%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记-集合</title>
    <link href="http://yoursite.com/2016/08/07/Java%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2016/08/07/Java笔记-集合/</id>
    <published>2016-08-07T11:06:30.000Z</published>
    <updated>2016-08-07T12:02:56.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/94cad1c8a786c91700b85e64ca3d70cf3bc75737.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>随着Java SE 1.2的问世，设计人员感到是推出一组功能完善的数据结构的时机了。面对一大堆相互矛盾的设计策略，他们希望让类库小且易于学习，而不像C++的STL那样复杂，但却又希望能够得到STL率先推出的”泛型算法”所具有的优点。</p>
<h2 id="Java类库中的集合接口和迭代器接口"><a href="#Java类库中的集合接口和迭代器接口" class="headerlink" title="Java类库中的集合接口和迭代器接口"></a>Java类库中的集合接口和迭代器接口</h2><p>在Java类库中，集合类的基本接口是Collection接口。这个接口有2个基本方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</div><div class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>add方法用于向集合中添加元素。如果添加元素确实改变了集合就返回true，如果集合没有发生改变就返回false。例如，如果试图向集合中添加一个对象，而这个对象在集中已经存在，这个添加请求就没有实效，因为集中不允许有重复的对象。<br>iterator方法用于返回一个实现了Iterator接口的对象。可以使用这个迭代器对象依次访问集合中的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inerator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>通过反复调用next方法，可以逐个访问集合中的每个元素。Collection接口扩展了Iterable接口。因此对于标准类库中的任何集合都可以使用“for each”循环。</p>
<p>元素被访问的顺序取决于集合类型。如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1。然而，如果访问HashSet中的元素，每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能遍历到集合中的所有元素，但却无法预知元素被访问的次序。</p>
<p>C++的标准模板库，迭代器是根据数组索引建模的。如果给定一个迭代器，就可以查看指定位置上的元素，但是，Java迭代器并不是这样操作的。查找操作与位置变更是紧密相连的。查找一个元素的唯一方法是调用next，而在执行查找操作的同时，迭代器的位置随之向前移动。</p>
<p>因此，应该将Java迭代器认为是位于两个元素之间，当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</p>
<p>Iterator接口的remove方法将会删除上次调用next方法时返回的元素。对next方法和remove方法的调用具有相互依赖性。如果调用remove之前没有调用next将是不合法的。也不能连续使用2个remove方法。</p>
<p>由于Collection与Iterator都是泛型接口，可以编写操作任何集合类型的实用方法。Java类库的设计者认为：这些实用方法中的某些方法非常有用，应该将它们提供给用户使用。contains就是一个实用方法。</p>
<p>当然，如果实现Collection接口的每一个类都要提供如此多的例行方法将是一件很烦人的事情。为了能让实现者更容易实现这个接口，Java类库提供了一个类AbstractCollection，它将基础方法size和iterator抽象化了，但是在此提供了例行方法。</p>
<h2 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>数组和数组列表都有一个重大的缺陷，这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。在数组中间的位置插入一个元素也是如此。</li>
<li>数组在连续的存储位置上存放对象引用，但链表却将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。在Java程序设计语言中，所有的链表实际上都是双向链接的——即每个结点还存放指向前驱结点的引用。</li>
<li>链表与泛型集合之间有一个重要的区别。链表是一个有序集合，每个元素的位置十分重要。LinkedList.add方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。这种依赖于位置的add方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。Set类型，其中的元素完全无序。因此在Iterator接口中就没有add方法。相反的，集合类库提供了子接口ListIterator，其中包含了add方法。另外，ListIterator接口有两个方法，可以用来反向遍历链表。</li>
<li>不要用for()循环来遍历链表。因为每次查找一个元素都要从链表的头部从新开始搜索。</li>
<li>使用链表的唯一理由是尽可能地减少在列表中插入或删除元素所付出的代价。如果列表中只有少数几个元素，就完全可以使用ArrayList。</li>
<li>List接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用get/set方法随机地访问每个元素。后者不适合链表，但对数组却很有用。ArrayList类实现了List接口，封装了一个动态再分配的对象数组。</li>
<li>在需要动态数组时，可能会使用Vector类。Vector类的所有方法都是同步的，而ArrayList方法不是同步的。</li>
<li>ArrayList扩容为原来的1.5倍，Vertor默认为原来的2倍（可以设置）。ArrayList删除元素却不会进行缩容, 遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低！</li>
<li>CopyOnWriteArrayList的核心思想是利用高并发往往是读多写少的特性，对读操作不加锁，对写操作，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用，并通过volatile保证其可见性，当然写操作的锁是必不可少的了。</li>
</ul>
<h3 id="散列集"><a href="#散列集" class="headerlink" title="散列集"></a>散列集</h3><ul>
<li>有一种数据结构可以快速地查找所需要的对象，这就是散列表。散列表为每个对象计算一个整数，称为散列码(hash code)。散列码是由对象的实例域产生的一个整数。具有不同数据域的对象将产生不同的散列码。</li>
<li>在Java中，散列表用链表数组(底层是数组结构，数组的中的每一项又是一个链表)实现。每个列表被称为桶。想要查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是这个元素的桶的索引。有时候会遇到桶被沾满的情况，这也是不可避免的。这种现象被称为散列冲突。</li>
<li>通常将桶数设置为预计元素个数的75%~150%。研究人员认为最好将桶数设置为一个素数，以防键的集聚。标准类库使用的桶数是2的幂。默认值为16。</li>
<li>如果散列表太满，就需要再散列。如果要对散列表再散列，就要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。装填因子决定何时对散列表进行再散列。如果装填因子为0.75(默认值)，而表中超过75%的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。</li>
<li>散列表可以用于实现几个重要的数据结构，set是没有重复元素的元素集合。set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。Java集合类库提供了一个HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains方法已经被重新定义，用来快速地查看某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集合中的所有元素。</li>
<li>散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。只有不关心集合中元素的顺序时才应该使用HashSet。</li>
<li>LruCache内部使用LinkedHashMap来保存缓存的值。初始化的时候传入缓存的最大值或者缓存的最大个数（如果sizeOf方法返回1的话）。如果重写来create方法，在使用get方法的时候，如果缓存不存在，就将新创建的value加入到缓存中，这样就不用再次使用put来加入缓存了（因为create不是线程安全的，所以，创建成功之后是否应该加入缓存还需要再判断一下）</li>
</ul>
<h3 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h3><ul>
<li>TreeSet类与散列集十分类似，不过它比散列集有所改进。树集是一个有序集合。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。比如插入字符串，访问添加的所有元素时会按首字母先后顺序打印。</li>
<li>排序是用树结构完成的(当前实现使用的是红黑树)。每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每一个元素。</li>
<li>将一个元素添加到树中要比添加到散列表中慢，但是与将元素添加到数组或链表的正确位置上相比还是快很多的。</li>
</ul>
<h3 id="对象的比较"><a href="#对象的比较" class="headerlink" title="对象的比较"></a>对象的比较</h3><ul>
<li>TreeSet如何知道希望元素怎样排列？在默认情况时，树集假定插入的元素实现了Comparable接口。这个接口定义了一个方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">comparaTo</span><span class="params">(T other)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>有些标准的Java平台类实现了Comparable接口自定义排列顺序。如String类，这个类的comparaTo方法依据字典序对字符串进行比较。</li>
<li>使用Comparable接口定义排列排序显然有其局限性。对于一个给定的类，只能够实现这个接口一次。如果在一个集合中需要按照部件编号进行排序，另一个集合中却要按照描述信息进行排序，该怎么办？另外，如果需要对一个类的对象进行排序，而这个类的创建者又没有费心实现Comparable接口，又怎么办？</li>
<li><p>在这种情况下，可以将Comparator对象传递给TreeSet构造器来告诉树集使用不同的比较方法。Comparator接口声明了一个带有两个显式参数的compara方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compara</span><span class="params">(T a,T b)</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>   
<p>与comparaTo方法一样，如果a位于b之前compara方法返回负值。a和b相等则返回0，否则返回正值。</p>
</li>
<li><p>这个比较器没有任何数据。它只是比较方法的持有器。有时将这种对象称为函数对象。函数对象通常“动态”定义，即定义为匿名内部类的实例。</p>
</li>
</ul>
<h3 id="队列和双端队列"><a href="#队列和双端队列" class="headerlink" title="队列和双端队列"></a>队列和双端队列</h3><ul>
<li>队列可以有效地在尾部添加一个元素，在头部删除一个元素。有两个端头的队列，即双端队列。可以有效地在头部和尾部同时添加或删除元素，不支持在队列中添加元素。</li>
<li>在Java SE6中引入了Deque接口，并由ArrayDeque和LinkedList类实现。这两个类都提供了双端队列，而且在必要时可以增加队列的长度。</li>
</ul>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><ul>
<li>优先级队列中元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用remove方法，总是会获得当前优先级队列中最小的元素。然而优先级队列并没有对所有的元素进行排序。如果用迭代的方式处理这些元素，并不需要对它们进行排序。优先级队列使用了堆的数据结构。堆是一个可自我调整的二叉树，对数执行添加(add)和删除(remove)操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</li>
<li>与TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供比较器的对象。</li>
<li>使用优先级队列的典型示例是任务调度。每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除。</li>
<li>与TreeSet中迭代不同，这里的迭代并不是按照元素的排列顺序访问的，而删除却总是删除掉剩余元素中优先级最小的元素。</li>
</ul>
<h3 id="映射表"><a href="#映射表" class="headerlink" title="映射表"></a>映射表</h3><ul>
<li>集是一个集合，它可以快速地查找现有的元素。但是要查看一个元素，需要有查找元素的精确副本。这不是一种非常通用的查找方式。通常，我们知道某些键的信息，并且想要查找与之对应的元素。映射表数据结构就是为此设计的。映射表用来存放键/值对。如果提供了键，就能够查找到值。</li>
<li>Java类库为映射提供了两个通用的实现：HashMap和TreeMap。这两个类都实现了Map接口。</li>
<li>散列映射表对键进行散列，数映射表用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键。</li>
<li>键必须是唯一的。不能对同一个键存放两个值。如果对同一个键两次调用put方法，第二个值就会取代第一个值。实际上，put将返回用这个键参数存储的上一个值。</li>
<li>集合框架并没有将映射表本身视为一个集合。映射表的视图是一组实现Collection接口的对象。它们分别是：键集、值集合和键/值对集键与键/值对形成了一个集。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span></div><div class="line">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></div><div class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></div></pre></td></tr></table></figure>    
Hashmap 是一个 最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。</li>
</ul>
<p>HashMap最多只允许一条记录的键为Null;允许多条记录的值为Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力.用synchronized修饰操作HashMap的语句块或方法。</p>
<p>Hashtable 与 HashMap类似,不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtale在写入时会比较慢。</p>
<p>TreeMap能够把它保存的记录根据键排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的，它不允许记录的键或者值为空。</p>
<p>LinkedHashMap，键和值可以为null，可以使插入的顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.在遍历的时候会比HashMap慢。也可以是基于访问顺序。</p>
<h3 id="专用集与映射表类"><a href="#专用集与映射表类" class="headerlink" title="专用集与映射表类"></a>专用集与映射表类</h3><h4 id="弱散列映射表"><a href="#弱散列映射表" class="headerlink" title="弱散列映射表"></a>弱散列映射表</h4><p>设计WeakHashMap类是为了解决一个有趣的问题。如果有一个值，对应的键已经不再使用了。假设对有一个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现这个键，所以，这个键/值对无法从映射表中删除。因为垃圾回收器跟踪活动的对象。只要映射表对象是活动的，其中的桶也是活动的，它们就不能被回收。</p>
<p>因此需要由程序负责从长期存活的映射表中删除那些无用的值。或者使用WeakHashMap完成这件事情。当对键的唯一引用来自散列表条目时，这一数据结构将与垃圾回收器协同工作一起删除键值对。</p>
<p>WeakHashMap使用弱引用保存键。WeakReference对象将引用保存到另外一个对象中，在这里就是散列表键。</p>
<p>对于这种类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某特特定对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。</p>
<p>WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，WeakHashMap将删除对应的条目。</p>
<h4 id="链接散列集和链接散列表"><a href="#链接散列集和链接散列表" class="headerlink" title="链接散列集和链接散列表"></a>链接散列集和链接散列表</h4><p>LinkedHashSet和LinedHashMap，用来记住插入元素项的顺序，这样就可以避免在散列表中项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中。链接散列表将用访问顺序，而不是插入顺序，对映射表条目进行迭代。</p>
<p>每次调用get或put，受到影响的条目将从当前位置删除，并放到条目链表的尾部(只有条目在链表中的位置会受到影响，而散列表中桶不会受影响。一个条目总位于与键散列码对应的桶中)。</p>
<p>访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。例如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取。当在表中找不到元素而表又已经满时，可以将迭代器放入表中，并将枚举的前几个元素删除掉。</p>
<h4 id="枚举集与映射表"><a href="#枚举集与映射表" class="headerlink" title="枚举集与映射表"></a>枚举集与映射表</h4><p>EnumSet是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现。如果对应的值在集中，则对应的位被置为1。EnumMap是一个键类型为枚举类型的映射表。它可以高效地用一个值数组实现。</p>
<h4 id="标识散列映射表"><a href="#标识散列映射表" class="headerlink" title="标识散列映射表"></a>标识散列映射表</h4><p>dentityHashMap，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的。这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。在两个对象进行比较时，IdentityHashMap类使用==，而不是equals。也就是说不同的键对象，即使内容相同，也被视为是不同的对象。在实现对象遍历算法(如对象序列化)时这个类非常有用，可以用来跟踪每个对象的遍历状况。</p>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>框架是一个类的集，它奠定了创造高级功能的基础。Java集合类库构成集合类的框架。它为集合的实现者定义了大量的抽象类和接口，并且对其中的类的某些机制给予描述。例如，迭代协议。<br>集合有两个基本的接口：Collection和Map。<br><img src="http://ob5qdb9lc.bkt.clouddn.com/5781777496614730124.jpg" alt="Image"></p>
<h3 id="视图包装器"><a href="#视图包装器" class="headerlink" title="视图包装器"></a>视图包装器</h3><p>用如此多的接口和抽象类来实现数量并不多的具体集合类似乎没有太大必要。通过使用视图可以获得其他的实现了集合接口和映射表接口的对象。</p>
<p>映射表类的keySet方法就是一个这样的示例。keySet返回一个实现Set接口类的对象，这个类的方法对原映射表进行操作。这种集合称为视图。视图技术在集合框架中有许多非常有用的应用。</p>
<h4 id="轻量级集包装器"><a href="#轻量级集包装器" class="headerlink" title="轻量级集包装器"></a>轻量级集包装器</h4><p>Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器。这个方法可以将数组传递给一个期望的到列表或集合变元的方法。eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Card[] cardDeck=<span class="keyword">new</span> Card[<span class="number">52</span>];</div><div class="line">...</div><div class="line">List&lt;Card&gt; cardList=Arrays.asList(cardDeck);</div></pre></td></tr></table></figure><br>返回的对象不是ArrayList。它是一个视图对象。带有底层访问数组的get和set方法。改变数组大小的所有方法都会抛出一个异常。</p>
<h4 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h4><p>可以为很多集合建立子范围，eg：想从staff列表中取出第10个~第19个元素，可以使用subList方法来获得子范围视图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List group2=staff.subList(<span class="number">10</span>,<span class="number">20</span>);</div></pre></td></tr></table></figure><br>对于有序表和映射表，可以使用排序顺序而不是元素位置建立子范围<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from,E to)</span></span></div><div class="line">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to)</span></div><div class="line">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from)</span></div></pre></td></tr></table></figure>   </p>
<h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p>Collections还有几个方法，用于产生集合的不可修改视图。eg：假设想要查看某部分代码，但又不触及某个集合的内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; staff=<span class="keyword">new</span> LinedList&lt;&gt;();</div><div class="line">...</div><div class="line">lookAt(Coolections.unmodifiableList(staff))</div></pre></td></tr></table></figure>    </p>
<h4 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h4><p>如果由多个线程访问集合，就必须确保集不会被意外破坏。类库设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。eg：Collections类的静态synchronizedMap方法可以将任何一个映射表转换成具有同步访问方法的Map：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;String,Employee&gt; map=Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String,Employee&gt;())</div></pre></td></tr></table></figure>        </p>
<h4 id="检查视图"><a href="#检查视图" class="headerlink" title="检查视图"></a>检查视图</h4><p>Java SE5.0增加了一组“检查”视图，用来对泛型类型发生问题时提供调试支持。eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; strings=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList rawList=strings;<span class="comment">//get warning only,not an error</span></div><div class="line">rawList.add(<span class="keyword">new</span> Date());<span class="comment">//now Strings contains a Date Object</span></div></pre></td></tr></table></figure><br>这个错误的add命令在运行时检测不到。只有在稍后的另外一部分代码中调用get()方法，并将结果转化为String时，这个类才会抛出异常。检查视图可以探测这类问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; safeStrings=Collenctions.checkedList(Strings,String.class);</div></pre></td></tr></table></figure><br>视图的add方法将检测插入的对象是否属于给定的类。如果不属于给定的类，就立即抛出一个异常。</p>
<h4 id="可选操作的说明"><a href="#可选操作的说明" class="headerlink" title="可选操作的说明"></a>可选操作的说明</h4><p>通常，视图有一些局限性，即可能只可以读、无法改变大小、只支持删除而不支持插入，这些与映射表的键视图情况相同。如果试图进行不恰当的操作，受限制的视图就会抛出异常。</p>
<p>在集合和迭代器接口的API文档中，许多方法描述为“可选操作”。一这看起来与接口的概念有所抵触。一个更好的解决方案是为每个只读视图和不能改变集合大小的视图建立各自独立的两个接口。不过，这将会使接口的数量成倍增长。</p>
<h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>可以使用类库中的批处理避免频繁地使用迭代器。假设希望找出两个集的交，首先建立一个新集，接着调用rerainAll方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; result=<span class="keyword">new</span> HashSet&lt;&gt;(a);</div><div class="line">result.retainAll(b);</div></pre></td></tr></table></figure><br>result中保存了既在a中出现，也在b中出现的元素。同理还有removeAll方法。</p>
<h3 id="集合与数组之间的转换"><a href="#集合与数组之间的转换" class="headerlink" title="集合与数组之间的转换"></a>集合与数组之间的转换</h3><p>由于Java平台API中大部分内容都是在集合框架创建之前设计的，所以，有时候需要在传统数组与现代的集合之间进行转换。</p>
<p>如果一个数组要转换为集合。Arrays.asList的包装器就可以实现这个目的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] values=...;</div><div class="line">HashSet&lt;String&gt; staff=<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(values));</div></pre></td></tr></table></figure><br>反过来，将集合转换为数组就有点难了。可以使用toArray方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object[] values=staff.toArray();</div></pre></td></tr></table></figure><br>但是，这样做的结果是产生一个对象数组。即使知道集合中包含一个特定类型的对象，也不能使用类型转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] values=(String[])satff.toArray();<span class="comment">//error</span></div></pre></td></tr></table></figure><br>有toArray方法返回的数组是一个Object[]数组，无法改变其类型。必须使用另外一种toArray方法，并将其设计为所希望的元素类型且长度为0的数组。也可以构造一个直到大小的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] values=staff.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</div><div class="line">staff.toArray(<span class="keyword">new</span> String[staff.size()])</div></pre></td></tr></table></figure>   </p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>泛型集合接口有一个很大的优点，即算法只需要实现一次。</p>
<h3 id="排序和混排"><a href="#排序和混排" class="headerlink" title="排序和混排"></a>排序和混排</h3><p>Collections类中的sort方法可以对实现了List接口的集合进行排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; staff=<span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">Collections.sort(staff);</div></pre></td></tr></table></figure><br>如果想按照降序对列表进行排序，可以使用一种非常方便的静态方法。这个方法将返回一个比较器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(staff，Collections.reverseOrder());</div></pre></td></tr></table></figure><br>在算法书籍中的排序算法，都是有关数组的排序算法，而且都是随机访问的方式。但是，对列表进行随机访问的效率很低。实际上，可以使用归并排序对列表进行高效的排序。然而，Java程序设计语言并不是这样实现的。它直接将所有元素转入一个数组，并使用一种归并排序的变体对数组进行排序，然后再将排序后的序列复制回列表。</p>
<p>集合类库中使用的归并排序算法比快速排序要慢一些，快速排序是通用排序算法传统选择。但是，归并排序有一个突出的优点：稳定，即不需要交换相同的元素。</p>
<p>Collections类有一个算法shuffle，功能是随机地混排列表中的元素顺序。</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>Collections类的binarySearch方法实现了二分查找算法。注意集合必须是排好序的，否则算法将返回错误的结果。如果集合没有采用Comparable接口的compareTo方法进行排序。就还要提供一个比较器对象。</p>
<p>只有采用随机访问，二分查找才有意义。如果必须利用迭代方式一次次遍历链表的一半元素来查找中间位置的元素，而分查找就完全失去了优势。因此，如果为binarySearch算法提供一个链表，它将自动地变为线性查找。</p>
<h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><p>在Collections类中还包含了几种简单有用的算法。</p>
<ul>
<li>将一个列表的元素复制到另外一个表中；</li>
<li>用一个常量填充容器；</li>
<li>逆置一个列表的元素顺序；</li>
<li>……</li>
</ul>
<h3 id="编写自己的算法"><a href="#编写自己的算法" class="headerlink" title="编写自己的算法"></a>编写自己的算法</h3><p>如果编写自己的算法(实际上，是以集合作为参数的任何方法)，应该尽可能地使用接口，而不要使用具体的实现。</p>
<h2 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h2><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable类与HashMap类的作用一样，实际上，它们拥有相同的接口。Hashtable的方法也是同步的。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>遗留集合使用Enumeration接口对元素序列进行遍历。</p>
<h3 id="属性映射表"><a href="#属性映射表" class="headerlink" title="属性映射表"></a>属性映射表</h3><p>属性映射表是一个类型非常特殊的映射表结构：</p>
<ul>
<li>键与值都是字符串</li>
<li>表可以保存到一个文件中，也可以从文件中加载</li>
<li>使用一个默认的辅助表<br>实现属性映射表的Java平台类称为Properties。<br>属性映射表通常用于程序的特殊配置选项。</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>从1.0开始，标准类库就包含了Stack类，有push和pop方法。但是，Stack类扩展为Vector类，它可以使栈使用不属于栈操作的insert和remove方法，即可以在任何地方进行插入或删除操作，而不仅仅是在栈顶。</p>
<h3 id="位集"><a href="#位集" class="headerlink" title="位集"></a>位集</h3><p>Java平台的BitSet类用于存放一个位序列。如果需要高效存储位序列(例如，标志)就可以使用位集。由于位集将位包装在字节里，所以，使用位集要比使用Boolean对象的ArrayList更加高效。</p>
<p>BitSet类提供了便于读取，设置或清除各个位的接口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/94cad1c8a786c91700b85e64ca3d70cf3bc75737.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java笔记" scheme="http://yoursite.com/categories/Java%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记-泛型</title>
    <link href="http://yoursite.com/2016/08/06/Java%E7%AC%94%E8%AE%B0-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2016/08/06/Java笔记-泛型/</id>
    <published>2016-08-06T13:46:25.000Z</published>
    <updated>2016-08-07T11:08:33.006Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ob5qdb9lc.bkt.clouddn.com/ab659IR5y5OLk.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型是我们需要的程序设计手段。使用泛型机制编写的应用程序代码要比那些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。</p>
<h2 id="为什么要使用泛型"><a href="#为什么要使用泛型" class="headerlink" title="为什么要使用泛型"></a>为什么要使用泛型</h2><p>泛型程序设计意味着编写的代码可以被不同类型的对象所重用。在Java增加泛型类之前，泛型程序设计是用继承实现的。ArrayList类只维护一个Object引用的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span>&#123;   <span class="comment">//before generic classes</span></div><div class="line">  <span class="keyword">private</span> Object[] elementData;</div><div class="line">  ...</div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;...&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这样的实现有两个问题。当获取一个值时必须进行强制类型转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList files=<span class="keyword">new</span> ArrayList();</div><div class="line">...</div><div class="line">String filename=(String)files.get(<span class="number">0</span>);</div></pre></td></tr></table></figure><br>此外，这里没有错误检查。可以向数组列表中添加任何类的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">files.add(<span class="keyword">new</span> File(<span class="string">"..."</span>));</div></pre></td></tr></table></figure><br>对于这个调用，编译和运行都不会出错。然而在其他地方，如果将get的结果强制转换为String类型，就会产生一个错误。</p>
<p>泛型提供了一个更好的解决方案：类型参数。ArrayList类有一个类型参数用来指示元素的类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; files=<span class="keyword">new</span> ArrayList&lt;String&gt;();</div></pre></td></tr></table></figure><br>类型参数的魅力在于：使得程序具有更好的可读性和安全性。</p>
<h2 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h2><p>一个泛型类就是具有一个或多个类型变量的类。下面是简单定义的Pair类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> T first;</div><div class="line">    <span class="keyword">private</span> T second;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;first=<span class="keyword">null</span>;second=<span class="keyword">null</span>;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span></span>&#123;<span class="keyword">this</span>.first=first;<span class="keyword">this</span>.second=second;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> a[a.length/<span class="number">2</span>];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">		 <span class="keyword">return</span> first;</div><div class="line">	 &#125;</div><div class="line"> 	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</div><div class="line">		 <span class="keyword">this</span>.first = first;</div><div class="line">	 &#125;</div><div class="line">	 <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</div><div class="line">		 <span class="keyword">return</span> second;</div><div class="line">	 &#125;</div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span> </span>&#123;</div><div class="line">		 <span class="keyword">this</span>.second = second;</div><div class="line">	 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Pair类引入了一个类型变量T，用&lt;&gt;括起来，并放在类名的后面。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个域和第二个域使用不同的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;</span>&#123;...&#125;</div></pre></td></tr></table></figure><br>类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> T first;</div></pre></td></tr></table></figure><br>在Java库中，使用变量E表示集合的元素类型，K和V分别表示表的关键字与值的类型。T(需要时还可以用临近的字母U和S)表示“任意类型”。</p>
<p>用具体的类型替换变量类型就可以实例化泛型实例，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt;</div></pre></td></tr></table></figure><br>泛型类可以看作普通类的工厂。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>实际上，还可以定义一个带有类型参数的简单方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</div><div class="line">      <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T getMiddle&lt;T...a&gt;</div><div class="line">       &#123;</div><div class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这个方法是在普通类中定义，而不是在泛型类中定义的。然而，这是一个泛型方法，注意，类型变量放在修饰符的后面，返回类型的前面。</p>
<p>泛型方法可以定义在普通类中，也可以定义在泛型类中。<br>当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String middle=ArrayAlg.&lt;String&gt;getMiddle&#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>&#125;;</div></pre></td></tr></table></figure><br>实际上方法调用可以省略<string>类型参数。编译器有足够的信息能推断出所调用的方法。它是names的类型与泛型类型T进行匹配并推断出T一定是String。也即是说，可以调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String middle=ArrayAlg.getMiddle(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</div></pre></td></tr></table></figure><br>几乎大多数情况下，对于泛型方法的类型引用没有问题。偶尔，编译器也会提示错误，eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> middle=ArrayAlg.getMiddle(<span class="number">3.14</span>,<span class="number">1729</span>,<span class="number">0</span>);</div></pre></td></tr></table></figure><br>错误信息会指出：解释这句代码有2种方法，而且这2种方法都是合法的。<br>简单的说，编译器将会自动打包参数为1个Double和2个Integer对象，而后寻找这些类的共同超类型。事实上，找到这2个类的超类型：Number和Comparable接口，其本身也是一个泛型类型。在这种情况下，可以采取的补救措施是将所有的参数写成double值。</string></p>
<h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>有时，类或方法需要对类型变量加以约束。eg:我们要计算数组中的最小元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</div><div class="line">       <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;</div><div class="line">           <span class="keyword">if</span>(a==<span class="keyword">null</span>||a.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">           T smallest=a[<span class="number">0</span>];</div><div class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)</div><div class="line">               <span class="keyword">if</span>(smallest.compareTo(a[i])&gt;<span class="number">0</span>) smallest=a[i];</div><div class="line">               retrun smallest;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>变量smallest类型为T，意味着它可以是任何一个类的对象。怎么才能确信T所属的类有compareTo方法呢？<br>解决这个问题的方案是将T限制为实现了Comparable接口(只含有一个方法compareTo的标准接口)的类。可以通过对类型变量T设置限定(bound)实现这一点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span>...</span></div></pre></td></tr></table></figure><br>为什么使用关键字extends而不是implements？毕竟，Comparable是一个接口。下面的符号：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;T extends BoundingType&gt;</div></pre></td></tr></table></figure><br>表示T应该是绑定类型的子类型。T和绑定类型可以是类，也可以是接口。选择关键字extends的原因是更接近子类的概念。<br>一个类型变量或通配符可以有多个限定，eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T extends Comparable &amp; Serializable</div></pre></td></tr></table></figure><br>限定类型用‘&amp;’分隔，而‘，’用来分隔类型变量。<br>在Java的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类作为限定，他必须是限定列表的第一个。</p>
<h2 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h2><p>虚拟机没有泛型类型对象——所有对象都属于普通类。</p>
<p>无论何时定义一个泛型类型，都自动提供一个相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为无限定类型(无限定类型用Object)。</p>
<p>eg：Pair<t>的原始类型如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></div><div class="line">&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123; first = <span class="keyword">null</span>; second = <span class="keyword">null</span>; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object second)</span> </span>&#123; <span class="keyword">this</span>.first = first;  <span class="keyword">this</span>.second = second; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> first; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> second; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span> </span>&#123; first = newValue; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object newValue)</span> </span>&#123; second = newValue; &#125;</div><div class="line">   <span class="keyword">private</span> Object first;</div><div class="line">   <span class="keyword">private</span> Object second;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>因为T是一个无限定的变量，所以直接用Object替换。<br>在程序中可以包含不同类型的Pair，例如Pair<string>或Pair<greoriancalendar>。<br>原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object替换。</greoriancalendar></string></t></p>
<h3 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h3><p>当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。eg:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pair&lt;Employee&gt; buddies=...;</div><div class="line">Empolyee buddy=buddies.getFirst();</div></pre></td></tr></table></figure><br>擦除getFirst的返回类型后将返回Object类型。编译器自动插入Employee的强制类型转换。也就是说，编译器把这个方法调用翻译为2条虚拟机指令：</p>
<ol>
<li>对原始方法Pair.getFirst的调用。</li>
<li>将返回的Object类型强制转换为Employee类型。</li>
</ol>
<p>当存取一个泛型域时也要插入强制类型转换。假设Pair类的first域和second域都是公有的。表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Employee buddy=buddies.first;</div></pre></td></tr></table></figure><br>也会在结果字节码中插入强制类型转换。</p>
<h3 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h3><p>类型擦除也会出现在泛型方法中。通常认为下述的泛型方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt;<span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></div></pre></td></tr></table></figure><br>是一个完整的方法族，而擦除类型之后，只剩下一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Comparable[] a)</span></span></div></pre></td></tr></table></figure><br>注意，类型参数T已经被擦除了，只留下了限定类型Comparable<br>方法擦除带来两个复杂问题。下面示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt;</span></div><div class="line">&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span></div><div class="line">  &#123;</div><div class="line">     <span class="keyword">if</span>(second.compareTo(getFirst())&gt;=<span class="number">0</span>)</div><div class="line">       <span class="keyword">super</span>.setSecond(second);</div><div class="line">   &#125;</div><div class="line">       ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>一个日期区间是一对Date对象，并且需要覆盖这个方法来确保第二个值永远不小于第一个值。这个类擦除后变成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span></div><div class="line">&#123;</div><div class="line"> ...   </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>存在另外一个从Pair继承的setSecond方法，即<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span></div></pre></td></tr></table></figure><br>考虑下面的语句序列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DateInterval interval=<span class="keyword">new</span> DateInterval(...)</div><div class="line">Pair&lt;Date&gt; pair=interval;</div><div class="line">pair.setSecond(aDate);</div></pre></td></tr></table></figure><br>这里，希望对setSecond的调用具有多态性，并调用最合适的那个方法。由于Pair引用DateInterval对象，所以应该调用DateInterval.setSecond。问题在于类型擦除与多态发生了冲突。要解决这个问题，就需要在编译器在DateInterval类中生成一个桥方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span></div><div class="line">&#123;</div><div class="line">   setSecond((Date)second;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>变量pair已经声明为类型Pair<date>，并且这个类型只有一个简单的方法叫setSecond，即setSecond(Object)。虚拟机用pair引用的对象调用这个方法。这个对象是DateInterval类型的，因而将会调用DateInterval.setSecond(Object)方法。这个方法是合成的桥方法。它调用DateInterval.setSecond(Date)。</date></p>
<p>桥方法可能会变得十分奇怪。假设DateInterval方法也覆盖了getSecond方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getSecond</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> (Date)<span class="keyword">super</span>.getSecond().clone()</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>在擦除的类型中，有两个getSecond方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">Date <span class="title">getSecond</span><span class="params">()</span><span class="comment">//defined in DateInterval</span></span></div><div class="line">Object <span class="title">getSecond</span><span class="params">()</span> <span class="comment">//overrides the method defined in Pair to call the first method</span></div></pre></td></tr></table></figure><br>不能这样编写Java代码(在这里，具有相同参数类型的两个方法是不合法的)。它们都没有参数。但是，在虚拟机中，用参数类型和返回类型确定一个方法。因此，编译器可能产生两个仅返回类型不同的方法字节码，虚拟机能够正确地处理这一情况。</p>
<p>有关Java泛型转换的事实：</p>
<ul>
<li>虚拟机中没有泛型，只有普通类和方法。</li>
<li>所有的类型参数都用它们的限定类型替换。</li>
<li>桥方法被合成用来保持多态。</li>
<li>为保持类型安全性，必要时插入强制类型转换。</li>
</ul>
<h2 id="约束和局限性"><a href="#约束和局限性" class="headerlink" title="约束和局限性"></a>约束和局限性</h2><h3 id="不能用基本类型实例化类型参数。"><a href="#不能用基本类型实例化类型参数。" class="headerlink" title="不能用基本类型实例化类型参数。"></a>不能用基本类型实例化类型参数。</h3><p>原因是类型擦除。</p>
<h3 id="运行时类型查询值适用于原始类型。"><a href="#运行时类型查询值适用于原始类型。" class="headerlink" title="运行时类型查询值适用于原始类型。"></a>运行时类型查询值适用于原始类型。</h3><p>虚拟机中的对象总有 一个特定的非泛型类型因此，所有的类型查询只产生原始类型。getClass方法总是返回原始类型。eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; stringPair=...;</div><div class="line">Pair&lt;Employee&gt; employeePair=...;</div><div class="line"><span class="keyword">if</span>(String.getClass()==employeePair.getClass())<span class="comment">//they are equal</span></div></pre></td></tr></table></figure><br>其比较结果是true，这是因为两次getClass都将返回Pair.class；</p>
<h3 id="不能创建参数化类型数组"><a href="#不能创建参数化类型数组" class="headerlink" title="不能创建参数化类型数组"></a>不能创建参数化类型数组</h3><p>不能实例化参数化类型数组，eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt;[] table=<span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];<span class="comment">//error</span></div></pre></td></tr></table></figure><br>擦除之后，table[]的类型是Pair[]，可以把它转换为Object[]；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object[] object=table;</div></pre></td></tr></table></figure><br>数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个ArrayStoreException异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object[<span class="number">0</span>]=<span class="string">"HELLO"</span>; <span class="comment">//ERROR --component type is Pair</span></div></pre></td></tr></table></figure><br>不过对于泛型类型，擦除会使这种机制无效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object[<span class="number">0</span>]=<span class="keyword">new</span> Pair&lt;Employee&gt;();</div></pre></td></tr></table></figure><br>能够通过数组存储检查，不过仍会导致一个类型错误。出于这个原因，不允许创建参数化类型数组。<br>需要说明的是，只是不允许创建这个数组，而声明类型为Pair<string>[]的变量仍是合法的。不过不能用new Pair<string>[10]初始化这个变量。</string></string></p>
<h3 id="Varargs警告"><a href="#Varargs警告" class="headerlink" title="Varargs警告"></a>Varargs警告</h3><p>上一节了解到，Java不支持泛型类型的数组。这一节讨论一个相关问题：向参数个数可变的方法传递一个泛型类型的实例。<br>下面这个简单的方法，参数个数是可变的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collect&lt;T&gt; coll,T...ts)</span></span>&#123;</div><div class="line"> <span class="keyword">for</span>(t:ts)coll.add(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>实际上ts是一个数组，包含提供的所有实参。<br>现在考虑以下调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Collection&lt;Pair&lt;String&gt;&gt; table=...;</div><div class="line">Pair&lt;String&gt; pair1=...;</div><div class="line">Pair&lt;String&gt; pair2=...;</div><div class="line">addAll(table.pair1,pair2);</div></pre></td></tr></table></figure><br>为了调用这个方法，Java虚拟机必须建立一个Pair<string>数组，这就违反了前面的规则。不过，对于这种情况，规则有所放松，你只会得到一个警告，而不是错误。</string></p>
<p>可以采用两种方法来抑制这个警告，一种方法是包含addAll调用的方法增加标注@SuppressWarning(“unchecked”)。或者在Java SE 7中，还可以用@SafeVarargs直接标注addAll方法。</p>
<h3 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h3><p>不能使用相new T(…)，new T[…]或T.class这样的表达式中的类型变量。类型擦除将T改变成Object，而且，本意肯定不希望调用new Object()。但是，可以通过反射调用Class.newInstance方法构造泛型对象。<br>不能调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">first=T.class.newInstance(); <span class="comment">//error</span></div></pre></td></tr></table></figure><br>必须像下面这样设计API以便可以支配Class对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Public <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cl)</span></span>&#123;</div><div class="line">   <span class="keyword">try</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(c1.newInstance(),c1.newInstance());&#125;</div><div class="line">   <span class="keyword">catch</span>(Exception ex)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这个方法可以按照下列方式调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; p=Pair.makePair(String.class);</div></pre></td></tr></table></figure><br>注意，Class类本身是泛型。例如，String.class是一个Class<string>的实例(事实上，它是唯一的实例)。因此，makePair方法能够推断出pair的类型。<br>不能构造一个泛型数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T[] a)&#123;</div><div class="line">    T[] mm=<span class="keyword">new</span> T[<span class="number">2</span>]...;      <span class="comment">//error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br>类型擦除会让这个方法永远构造Object[2]数组。</string></p>
<h3 id="泛型类的静态上下文中的类型变量无效"><a href="#泛型类的静态上下文中的类型变量无效" class="headerlink" title="泛型类的静态上下文中的类型变量无效"></a>泛型类的静态上下文中的类型变量无效</h3><p>不能在静态域或方法中引用类型变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> T singleInstance;<span class="comment">//error</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getSingleInstance</span><span class="params">()</span><span class="comment">//error</span></span></div><div class="line">   &#123;</div><div class="line">     <span class="keyword">if</span>(singleInstance==<span class="keyword">null</span>)</div><div class="line">     <span class="keyword">return</span> singleInstance;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>类型擦除后，只剩下SingleTon类，它只包含一个singleInstance域。因此，禁止使用带有类型变量的静态域和方法。</p>
<h3 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h3><p>既不能抛出也不能捕获泛型类对象。实际上，甚至泛型类扩展Throwable都是不合法的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;...&#125; <span class="comment">//error</span></div></pre></td></tr></table></figure><br>catch子句中不能使用类型变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(class&lt;T&gt; t)</span></span>&#123;</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    ...</div><div class="line"> &#125;<span class="keyword">catch</span>(T e)  <span class="comment">//error</span></div><div class="line">  &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>不过，在异常规范中使用类型变量是允许的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T <span class="comment">//ok</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">try</span>&#123;...&#125;</div><div class="line">   <span class="keyword">catch</span>(Throwable realCause)</div><div class="line"> &#123;   </div><div class="line">   t.initCause(realCause);</div><div class="line">   <span class="keyword">throw</span> t;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>可以消除对已检查异常的检查<br>Java异常处理的一个基本原则是：必须为所有已检查异常提供一个处理器。不过可以利用泛型消除这个限制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span>throw T</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">throw</span>(T) e;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>假设这个方法包装在类Block中，如果调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Block.&lt;RuntimeException&gt;throwAs(t);</div></pre></td></tr></table></figure><br>编译器就会认为t是一个未检查的异常。以下代码会把所以异常都转换为编译器所认为的未检查异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">   ...</div><div class="line">&#125;<span class="keyword">catch</span>(Throwable t)&#123;</div><div class="line">  Block.&lt;RuntimeException&gt;throwAs(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这有什么意义呢？正常情况下，你必须捕获线程run方法中的所有已检查的异常，把它们“包装”到未检查异常中，run方法声明就不抛出已检查异常。<br>通过使用泛型类、擦除和@SuppressWarnings标注，就能消除Java类型系统的部分基本限制。</p>
<h3 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h3><p>当泛型类型被擦除时，无法创建引发冲突的条件。eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> first.equals(value)&amp;&amp;second.equals(value);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>考虑一个Pair<string>。从概念上来讲，它有两个equals方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span>  <span class="comment">//defind in Pair&lt;T&gt;</span></span></div><div class="line"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span>  <span class="comment">//inherited form Object</span></div></pre></td></tr></table></figure><br>但是，直觉把我们引入歧途。方法擦除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> equals&lt;T&gt;</div></pre></td></tr></table></figure><br>就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span></span></div></pre></td></tr></table></figure><br>与Object.equals方法发生冲突。当然，补救的方法是重新命名引发错误的方法。<br>泛型规范说明还提到另外一个原则：“要想支持擦除的转换，就需要强制限制一个类或类型变量不能同时称为两个接口类型的子类，而这两个接口是同一接口的不同参数化。”eg：下述代码非法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt;</span>&#123;...&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendar</span> <span class="keyword">extends</span> <span class="title">Calendar</span> <span class="title">implment</span> <span class="title">Comparable</span>&lt;<span class="title">GregorianClendar</span>&gt;</span></div><div class="line">&#123;</div><div class="line">...                              <span class="comment">//error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br>GregoianCalenda会实现Comparable<calendar>和Comparable<gregoriancalendar>，这是同一接口的不同参数化。</gregoriancalendar></calendar></string></p>
<h2 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h2><p>考虑一个类和一个子类，如Employee和Manager。Pair<manager>是Pair<employee>的一个子类吗？答案是“不是！” 下面的代码不能编译成功：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Manager[] topHonchos=...;</div><div class="line">Pair&lt;Employee&gt; result=ArrayAlg.minmax(topHonchos); <span class="comment">//error</span></div></pre></td></tr></table></figure><br>minmax方法返回Pair<manager>，而不是Pair<employee>，并且这样的赋值是不合法的。<br>无论S和T有什么联系，通常，Pair<s>与Pair<t>没有什么联系。<br>泛型类可以扩展或实现其他泛型类。就这一点而言，与普通的类没有什么区别。例如，ArrayList<t>类实现List<t>接口。这意味着，一个ArrayList<manager>可以被转换为一个List<manager>。但是，一个ArrayList<manager>不是一个ArrayList<employee>或List<employee>。</employee></employee></manager></manager></manager></t></t></t></s></employee></manager></employee></manager></p>
<h2 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;? extends Employee&gt;</div></pre></td></tr></table></figure>    
<p>表示任何泛型Pair类型，它的类型参数是Employee的子类，如Pair<manager>，但不是Pair<string>。<br>假设要编写一个打印雇员对的方法，eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;Employee&gt; p)</span></span></div><div class="line">&#123;</div><div class="line">   Employee first=p.getFirst();</div><div class="line">   Employee second=p.getSeconde();</div><div class="line">   System.out.println(first.getName()+<span class="string">"and"</span>+second.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>正如前面讲到，不能将Pair<manager>传递给这个方法，这一点很受限制。解决的方法：使用通配符类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span></div></pre></td></tr></table></figure><br>类型Pair<manager>是Pair&lt;? extends Employee&gt;的子类型</manager></manager></string></manager></p>
<p>通配符的限定与类型变量限定十分类似，但是，还有一个附加的能力，即可以知道一个超类型指定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">? <span class="keyword">super</span> Manager</div></pre></td></tr></table></figure><br>这个通配符限制为Manager的所有超类型。</p>
<p>还可以使用无限定通配符，例如，Pair&lt;?&gt;，类型Pair&lt;?&gt;有方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">? getFirst()</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span></span></div></pre></td></tr></table></figure><br>etFirst的返回值只能赋值给一个Object.。setFirst方法不能调用，甚至不能用Object调用。Pair&lt;?&gt;和Pair本质的不同：可以用任意Object对象调用原始的Pair类的setObject方法。<br>为什么要使用这样脆弱的类型？它对于许多简单操作非常有用。例如，下面这个方法用来测试pair是否包含一个null引用，它不需要实际的类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> p.getFirst()=<span class="keyword">null</span>||p.getSecond()==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>通过将hasNulls转换为泛型方法，可以避免使用通配符类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;T&gt; p)</span></span></div></pre></td></tr></table></figure><br>但是，带有通配符的版本可读性更强。</p>
<h3 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h3><p>通配符不是类型变量。因此，不能在编写代码中使用“?”作为一种类型。下述代码非法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; p)</span></span>&#123;</div><div class="line">  ? t=p.getFirst;<span class="comment">//error</span></div><div class="line">  p.setFirse(p.getSecond);</div><div class="line">  p.setSecond(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>解决方案：我们可以写一个辅助方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span></span>&#123;</div><div class="line">  T t=p.getFirst;</div><div class="line">  p.setFirse(p.getSecond);</div><div class="line">  p.setSecond(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>现在swap可以调用swapHelper<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; p)</span></span>&#123;swapHelper(p);&#125;</div></pre></td></tr></table></figure><br>swapHelper参数T捕获通配符。它不知道是哪种类型的通配符，但是这是一个明确的类型，并且<t>swapHelper的定义只有在T指出类型时才有明确的含义。<br>通配符捕获只有在有许多限制的情况下才是合法的。编译器必须能够确信通配符表达的是单个、确定的类型。例如ArrayList<pair<t>&gt;中的T永远不能捕获ArrayList<pair<?>&gt;中的通配符。</pair<?></pair<t></t></p>
<h2 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h2><p>class类是泛型的。例如，String.class实际上是一个Class<string>类的对象(事实上，是唯一的对象)。<br>类型参数十分有用，这是因为它允许Clas<t>方法的返回类型更加具有针对性。</t></string></p>
<h3 id="使用Class参数进行类型匹配"><a href="#使用Class参数进行类型匹配" class="headerlink" title="使用Class参数进行类型匹配"></a>使用Class<t>参数进行类型匹配</t></h3><p>有时，匹配类型方法中的Class<t>参数的类型变量很有实用价值。eg:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; c)</span><span class="keyword">throws</span>           </span></div><div class="line">InstantiationException,IllegalAccessException</div><div class="line">&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(c.newInstance(),c.newInstance());</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">makePair(Employee.class)</div></pre></td></tr></table></figure><br>Employee.class是类型Class<employee>的一个对象。makePair方法的类型参数T同Employee匹配，并且编译器可以推断出这个方法将返回一个Pair<employee>。</employee></employee></t></p>
<h3 id="虚拟机中的泛型类型信息"><a href="#虚拟机中的泛型类型信息" class="headerlink" title="虚拟机中的泛型类型信息"></a>虚拟机中的泛型类型信息</h3><p>ava泛型的卓越特性之一是在虚拟机中泛型类型的擦除。擦除的类仍然保留一些泛型祖先的微弱记忆。例如，原始的Pai类知道源于泛型类Pair<t>，即使一个Pair类型的对象无法区分是由Pair<string>构造的还是由Pair<employee>构造的。<br>类似地，看一下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Comparable[] a)</span></span></div></pre></td></tr></table></figure><br>这是一个泛型方法的擦除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></div></pre></td></tr></table></figure><br>可以使用反射API来确定：</employee></string></t></p>
<ol>
<li>这个泛型方法有一个叫做T的类型参数</li>
<li>这个类型参数有一个子类型限定，其自身又是一个泛型类型</li>
<li>这个限定类型有一个通配符类型</li>
<li>这个通配符参数有一个超类型限定</li>
<li>这个泛型方法有一个泛型数组参数</li>
</ol>
<p>换句话说，需要重新构造实现者声明的泛型类以及方法中的所有内容。但是，不会知道对于特定的对象或方法调用，如何解释类型参数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ob5qdb9lc.bkt.clouddn.com/ab659IR5y5OLk.jpg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java笔记" scheme="http://yoursite.com/categories/Java%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
