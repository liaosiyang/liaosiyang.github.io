<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Be Level5 Coder</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-31T06:12:43.690Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写在校招之前</title>
    <link href="http://yoursite.com/2016/08/30/%E5%86%99%E5%9C%A8%E6%A0%A1%E6%8B%9B%E4%B9%8B%E5%89%8D/"/>
    <id>http://yoursite.com/2016/08/30/写在校招之前/</id>
    <published>2016-08-30T10:53:46.000Z</published>
    <updated>2016-08-31T06:12:43.690Z</updated>
    
    <content type="html"><![CDATA[<p>今天，也就是8月30的下午接到了第一个面试的电话，突然发现校招就这么来了，不觉有些感慨。<br>NPC: 9月已经到来，欢迎进入校招团队副本。请拿好武器，带好药剂，接收Boss们的制裁吧。校招感觉上就是魔兽世界里的团队副本，并且还是H难度的，对于我来说。<br>利用校招之前的空余时间，写点什么吧，就像佛丁在冰冠冰川前鼓舞将士们的话语：无论是生是死，我们都是为荣誉而战。</p>
<a id="more"></a>
<p>今天的面试是魔都某公司打来的，问的东西并不难，时间也不长，但自己的表现还是感觉不太行。<br>首先是比较紧张吧，死宅男的属性暴露无疑。一直都是一个人默默地写代码，打字聊天远远多过现实中和人说的话，所以紧张的情绪还是难以控制。<br>以前也有过面试的经历，也总是提醒过自己别紧张，看开点，但在面试时还是能清楚的听到胸腔里的咚咚声。这个问题好像真的无解了，可能还是与人交流较少有关系吧。明天找个人陪我搞下模拟面试试试，或许会有点用。</p>
<p>其次就是如何回答一个宽泛的问题，比如今天的问题Handler机制、Retrofit原理，找到回答的切入点很关键。问Handler机制直接说Handler就很难答了，切入点应该是Looper、MessageQueue。Retrofit原理应该就直接回答动态代理，而运行时注解的原理可以先放着，等深入问的时候再答，而不要一上来就什么都想说，最后又什么都说不出来或什么都轻言带过。要是开口切入点就不好，后面的话就很难接了。</p>
<p>最后比较惊喜的是面试官看了我的GitHub和个人博客，GitHub上有个人的项目，功能简单但花了2个月时间，使用到的技术也比较新，RxJava、Dagger2等都用上了，以前实习的时候做的项目都没用到。个人博客是学习的总结，再说搭建个人博客和总结知识真不是一件容易的事。这两点可以证明自己有在努力，应该可以加分吧。    </p>
<p>其实写知识总结一方面也是为了让自己能够在面试场上对答如流，因为很早之前就领会过知识在脑海中但是无法流畅地表述出来的情况。</p>
<p>一方面是知识不牢固，比如今天回答事件分发机制ViewGroup的三个相关方法居然一时脑抽，没想出来onTouchEvent用英语怎么拼，因为前面两个方法dispatchTouchEvent和onInterceptTouchEvent，感觉第三个方法快到嘴边了又老感觉不对，总感觉应该是onXXXTouchEvent的格式。</p>
<p>二是我觉得写出来应该就能代表对知识掌握起码80%吧，就能讲出来吧。现实情况还真不是这样，说话确实是门艺术，而像我这种常年生活在二次元的宅男来说，根本就没注意点这方面的天赋点啊！所以每次回答干巴巴的。所以写出来并不代表能讲出来，这给了我一个警示，功夫还不够啊！</p>
<p>就写这么多吧，总结一下就2点：</p>
<ul>
<li>赶紧找人陪我做模拟面试，很急很关键。</li>
<li>再把知识过一边，想想回答相关知识的切入点。</li>
</ul>
<p>马上校招就来了，这关系到我以后几年去哪个城市发展，能不能找到一个好的技术团队对职业的发展是很关键的。另外还是希望努力就会有收获吧。</p>
<p>如果校招顺利的话，大概会写一篇经验总结给学弟学妹们作为攻略，不顺利的话就没办法了。</p>
<p>好吧，勇士们，进攻！</p>
<p>我发现我不擅长说话，写点东西还是很乐意的嘛。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，也就是8月30的下午接到了第一个面试的电话，突然发现校招就这么来了，不觉有些感慨。&lt;br&gt;NPC: 9月已经到来，欢迎进入校招团队副本。请拿好武器，带好药剂，接收Boss们的制裁吧。校招感觉上就是魔兽世界里的团队副本，并且还是H难度的，对于我来说。&lt;br&gt;利用校招之前的空余时间，写点什么吧，就像佛丁在冰冠冰川前鼓舞将士们的话语：无论是生是死，我们都是为荣誉而战。&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="other" scheme="http://yoursite.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative笔记-ReactNative</title>
    <link href="http://yoursite.com/2016/08/24/ReactNative%E7%AC%94%E8%AE%B0%E7%AC%94%E8%AE%B0-ReactNative/"/>
    <id>http://yoursite.com/2016/08/24/ReactNative笔记笔记-ReactNative/</id>
    <published>2016-08-24T03:19:23.000Z</published>
    <updated>2016-08-31T07:32:00.024Z</updated>
    
    <content type="html"><![CDATA[<p>React Native 是最近非常火的一个话题,它可以使用前端的开发方式来开发移动端，但并不是像以前在实习公司所做的仅仅用一个WebView嵌套一样。<br>它实际上是一种Hybrid App开发方式，兼有Web App跨平台和Native App高性能的优势，并且它是由FacebooK公司开源的神器。<br>作为一名移动开发人员，我也对这项技术非常感兴趣，谁让现在搞Android的竞争太激烈，技术更新也快，说不定哪天就被淘汰了。所以还是早做准备，扩充自己的技能栈。<br>话虽这么说，但React Native毕竟是一种全新的开发方式，想要掌握没那么容易，需要很多前端开发的知识。<br>2016年余下的时间就投入给React Native吧，毕竟对于前端开发我可是很有兴趣的。</p>
<a id="more"></a>
<h1 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h1><p>React Native 使你能够基于 JavaScript 和 React 在原生平台上构建应用，提倡的是 “learn once, write anywhere”，复用代码，提高开发效率。</p>
<p>在移动端开发端，我们经常是根据服务端传来的JSON文件来传递信息，更新视图。JSON只能传递配置信息，无法表达逻辑。从本质上讲，这是因为 JSON 毕竟只是纯文本，它缺乏像编程语言那样的运行能力。</p>
<p>而 React 在前端取得突破性成功以后，JavaScript 布道者们开始试图一统三端。他们利用了移动平台能够运行 JavaScript 代码的能力，并且发挥了JavaScript 不仅仅可以传递配置信息，还可以表达逻辑信息的优点。</p>
<p>于是乎：一个基于 JavaScript，具备动态配置能力，面向前端开发者的移动端开发框架，React Native，诞生了！</p>
<p>React Native是一款用来开发真正原生、可渲染IOS和Android移动应用的JavaScript框架。基于JavaScript用户界面开发框架React而产生，但React将浏览器作为渲染平台，而React Native的渲染平台则是移动设备。</p>
<h1 id="ReactNative的优势"><a href="#ReactNative的优势" class="headerlink" title="ReactNative的优势"></a>ReactNative的优势</h1><ul>
<li>Web的开发方式远比IOS和Android更加方便和高效，Web上层出不穷的各种库和框架也远比Android和IOS的各种库和框架方便许多。</li>
<li>JavaScript语言真的要一统天下了，GitHub上使用最多的语言也是Js，Node.js正在各大公司大放光彩，前端开发规模越来越大，ES6 ES7为Js带来各种新的便捷的语法特性。(Java是最好的语言，JavaScript很像Java,排第二不过分)</li>
<li>动态UI，这一点RN有着和Web差不多的表现但是胜在性能。使用RN这种技术，由于Js天然动态性，我们可以随时下发数据和代码，随时定制我们的UI。</li>
<li>热更新，HotFix，原生的各种热更实现起来都太复杂，有的甚至需要重启app才生效。但是使用Js语言就不一样了，动态语言的一大好处就是可以随时执行，随时替换，使用RN之后，就可以做到随时运行更新我们的Js代码，实现起来会比原生的方案简单很多。</li>
<li>跨平台的开发，有了VirtualDom的概念之后，其实你一套代码做的UI，是可以被适配到多个平台的，目前已经有iOS，Android，Canvas，Mac，PC。</li>
</ul>
<h1 id="ReactNative技术栈和学习资料"><a href="#ReactNative技术栈和学习资料" class="headerlink" title="ReactNative技术栈和学习资料"></a>ReactNative技术栈和学习资料</h1><p>一个很帅的兄弟总结的：</p>
<ul>
<li>immutable.js</li>
<li>react</li>
<li>redux</li>
<li>react-redux</li>
<li>redux-thunk</li>
<li>redux-logger</li>
<li>redux-mock-store</li>
<li>react-native-router-flux</li>
<li>react-native-simple-store</li>
<li>regenerator</li>
<li>undefined</li>
<li>jest</li>
</ul>
<p><a href="https://github.com/reactnativecn/react-native-guide#react-native" target="_blank" rel="external">React-Native学习指南</a>(这本书已到手,书中是以OS X系统为基础的,不过感觉影响不大)<br><a href="http://gold.xitu.io/tag/React%20Native" target="_blank" rel="external">掘金ReactNative标签</a><br><a href="https://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="external">Facebook React Native Docs</a><br><a href="http://redux.js.org/" target="_blank" rel="external">Redux.js</a><br><a href="https://github.com/crazycodeboy/react-native-awesome#es6es7" target="_blank" rel="external">React Native Awesome</a><br><a href="https://github.com/reactnativecn/react-native-guide" target="_blank" rel="external">react-native-guide</a></p>
<p>8小时内拼工作，8小时外拼成长，干巴爹！</p>
<p>参考资料：<br><a href="http://blog.zhaiyifan.cn/2016/08/04/android-new-project-from-0-p10/" target="_blank" rel="external">从零开始的Android新项目10 - React Native &amp; Redux</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4OTc4MTM0OA==&amp;mid=2650358053&amp;idx=1&amp;sn=42c1f3691b848f571583937db1bcec1b#rd" target="_blank" rel="external">React Native 从入门到源码分析-了解RN百态</a><br><a href="https://zhuanlan.zhihu.com/p/20549882?refer=program-life" target="_blank" rel="external">谈谈我对ReactNative的看法</a><br><a href="http://dev.qq.com/topic/577e16a7640ad7b4682c64a7" target="_blank" rel="external">React Native 项目实战总结</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React Native 是最近非常火的一个话题,它可以使用前端的开发方式来开发移动端，但并不是像以前在实习公司所做的仅仅用一个WebView嵌套一样。&lt;br&gt;它实际上是一种Hybrid App开发方式，兼有Web App跨平台和Native App高性能的优势，并且它是由FacebooK公司开源的神器。&lt;br&gt;作为一名移动开发人员，我也对这项技术非常感兴趣，谁让现在搞Android的竞争太激烈，技术更新也快，说不定哪天就被淘汰了。所以还是早做准备，扩充自己的技能栈。&lt;br&gt;话虽这么说，但React Native毕竟是一种全新的开发方式，想要掌握没那么容易，需要很多前端开发的知识。&lt;br&gt;2016年余下的时间就投入给React Native吧，毕竟对于前端开发我可是很有兴趣的。&lt;/p&gt;
    
    </summary>
    
      <category term="ReactNative笔记笔记" scheme="http://yoursite.com/categories/ReactNative%E7%AC%94%E8%AE%B0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-热补丁</title>
    <link href="http://yoursite.com/2016/08/22/Android%E7%AC%94%E8%AE%B0-%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    <id>http://yoursite.com/2016/08/22/Android笔记-热补丁/</id>
    <published>2016-08-22T01:51:02.000Z</published>
    <updated>2016-09-01T07:12:07.601Z</updated>
    
    <content type="html"><![CDATA[<p>继插件化后，热补丁技术在2015年开始爆发，目前已经是非常热门的Android开发技术。其中比较著名的有淘宝的Dexposed、支付宝的AndFix以及Qzone的超级热补丁方案，还有最新的微信Tinker方案。<br>我的理解是Android热补丁就是不需要重新安装应用，而是动态地修复应用的Bug的技术，这项技术非常实用，毕竟每天都会看到一两个应用提示要求更新，而更新仅仅是修复一两个Bug,但却要下载几十M的APK文件，花费几分钟的时间安装，麻烦！</p>
<a id="more"></a>
<h1 id="为什么要热补丁"><a href="#为什么要热补丁" class="headerlink" title="为什么要热补丁"></a>为什么要热补丁</h1><p>当一个App发布之后，突然发现了一个严重bug需要进行紧急修复，这时候公司各方就会忙得焦头烂额：重新打包App、测试、向各个应用市场和渠道换包、提示用户升级、用户下载、覆盖安装。有时候仅仅是为了修改了一行代码，也要付出巨大的成本进行换包和重新发布。</p>
<p>热补丁：让应用能够在无需重新安装的情况实现更新，帮助应用快速建立动态修复能力。</p>
<p>适合使用在哪些场景：</p>
<ul>
<li>轻量而快速的升级；</li>
<li>远端调试；</li>
<li>数据统计。</li>
</ul>
<p>最近涌现出来得热补丁方案，主要包括淘宝的Dexposed、支付宝的AndFix、QQ空间的ClassLoader、微信的Tinker。</p>
<h1 id="Dexposed"><a href="#Dexposed" class="headerlink" title="Dexposed"></a>Dexposed</h1><p>DexPosed是强大而无侵入的AOP（面向切面编程）运行Android应用程序开发框架，基于开源的Xposed框架项目的工作（Xposed是修改系统框架服务的框架）。</p>
<p>AOP : 面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。简单来说，就是插代码（编译期或者运行期）。</p>
<p>Xposed通过修改Android Dalvik运行时的Zygote进程，并使用Xposed Bridge来hook方法并注入自己的代码，实现非侵入式的runtime修改。</p>
<p>应用启动的时候，都会fork zygote进程，装载class和invoke各种初始化方法，Xposed就是在这个过程中，替换了app_process，hook了各种入口级方法（比如handleBindApplication、ServerThread、ActivityThread、ApplicationPackageManager的getResourcesForApplication等），加载XposedBridge.jar提供动态hook基础。</p>
<p>hook技术 : 如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。</p>
<p>Xposed在对java方法进行hook时，先将虚拟机里面这个方法的Method属性改为nativeMethod，然后将该方法的nativeFunc指向自己实现的一个native方法，这样方法在调用时，就会调用到这个native方法，接管了控制权。</p>
<p>在这个native方法中，xposed直接调用了一个java方法，这个java方法里面对原方法进行了调用，并在调用前后插入了钩子，于是就hook住了这个方法。</p>
<p>Xposed的粒度是方法级，可以在方法前、方法后插入代码，或者直接替换方法。只能针对java方法做拦截，不支持C的方法。</p>
<p>Dexposed原理就是通过改变一个方法对象在Dalvik虚拟机中的定义来实现。具体做法就是将该方法的类型改变为Native并且将这个方法的实现链接一个通用的Native Dispatch方法上。这个Dispatch方法通过JNI回调Java端的一个统一的处理方法，最后在这个统一的处理方法中调用before、after函数实现AOP。</p>
<p>注意：android4.4之后的版本都用Art取代了Dalvik,所以要hook Android4.4以后的版本就必须去适配Art虚拟机的机制。目前官方表示，为了适配Art的dexposed_l只是beta版，所以最好不要在正式的线上产品中使用它。</p>
<p><a href="https://github.com/alibaba/dexposed" target="_blank" rel="external">alibaba/dexposed</a></p>
<h1 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a>AndFix</h1><p>同样是方法的hook，AndFix不像Dexposed从Method入手，而是以Field为切入点。</p>
<p>AndFix的原理就是方法的替换，把有bug的方法替换成补丁文件中的方法。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/principle1.jpg" alt="Image"></p>
<p>在Native层使用指针替换的方式替换bug方法，以达到修复bug的目的。</p>
<p>方法替换过程：</p>
<ul>
<li>加载补丁文件：使用虚拟机的JavaFile加载补丁文件，读取PATCH.MF得到补丁类的名称；</li>
<li>获取补丁方法：使用DexFile读取patch中的dex文件，获取后根据注解获得补丁方法；</li>
<li>获取bug方法：根据注解中获取的类名和方法名，使用ClassLoader获取到class,然后使用反射得到bug Method方法。</li>
<li>JNI层替换方法：使用c++的指针替换bug方法对象的属性来修复BUG。</li>
</ul>
<p>总的来说就是根据补丁文件找到bug方法，然后修改bug方法的指针，让它指向修复后的方法。</p>
<p>由于它并没有整体替换class, 而field在class中的相对地址在class加载时已确定，所以AndFix无法支持新增或者删除filed的情况(通过替换init与clinit只可以修改field的数值)。</p>
<p>Andfix可以支持的补丁场景相对有限，仅仅可以使用它来修复特定问题。另一方面，使用native替换将会面临比较复杂的兼容性问题。</p>
<p><a href="https://github.com/alibaba/AndFix#security" target="_blank" rel="external">alibaba/AndFix</a></p>
<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><p>Multidex方案的实现，其实就是把多个dex放进app的classloader之中，从而使得所有dex的类都能被找到。而实际上findClass的过程中，如果出现了重复的类，是会使用第一个找到的类的。</p>
<p>一个ClassLoader可以包含多个dex文件，每个dex文件是一个Element，多个dex文件排列成一个有序的数组dexElements，当找类的时候，会按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找类则返回，如果找不到从下一个dex文件继续查找。</p>
<p>理论上，如果在不同的dex中有相同的类存在，那么会优先选择排在前面的dex文件的类。</p>
<p>该热补丁方案就是从这一点出发，只要把有问题的类修复后，放到一个单独的dex，通过反射插入到dexElements数组的最前面，就可以让虚拟机加载到打完补丁的class了。</p>
<p>这种方案有一个问题，当一个类引用另一个类而这两个类不在同一个dex中时就会报错。但是本来拆分dex就是有很多类不在同一个包里，为什么不报错？</p>
<p>我们知道当一个apk在安装的时候，apk中的classes.dex会被虚拟机(dexopt)优化成odex文件，然后才会拿去执行。 虚拟机在启动的时候，会有许多的启动参数，其中一项就是verify选项，当verify选项被打开的时候，就会执行dvmVerifyClass进行类的校验，如果dvmVerifyClass校验类成功，那么这个类会被打上CLASS_ISPREVERIFIED的标志。</p>
<p>如果方法中直接引用到的类（第一层级关系，不会进行递归搜索）和clazz都在同一个dex中的话，那么这个类就会被打上CLASS_ISPREVERIFIED。</p>
<p>所以为了实现热补丁方案，所以必须从这些方法中入手，防止类被打上CLASS_ISPREVERIFIED标志。</p>
<p>最终空间的方案是往所有类的构造函数引用了一个类，而这个类会被打包成单独的hack.dex，这样当安装apk的时候，classes.dex内的类都会引用一个在不相同dex中的类，这样就防止了类被打上CLASS_ISPREVERIFIED的标志了，只要没被打上这个标志的类都可以进行打补丁操作。</p>
<p>Qzone方案好处在于开发透明，简单，但在补丁包大小与性能损耗上有一定的局限性。</p>
<p>在 art 平台，若补丁中的类出现 Field、Method 或 Interface 变化，可能会导致出现内存地址错乱的问题。为了解决这个问题需要将修改了变量、方法以及接口的类的父类以及调用这个类的所有类都加入到补丁包中。这可能会带来补丁包大小的急剧增加。</p>
<p>这里是因为在dex2oat时fast*已经将类能确定的各个地址写死。如果运行时补丁包的地址出现改变，原始类去调用时就会出现地址错乱。</p>
<p>开源实现：<br><a href="http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/" target="_blank" rel="external">Nuwa</a><br><a href="http://www.jianshu.com/p/b29a21a162ad" target="_blank" rel="external">HotFix</a><br><a href="http://blog.csdn.net/qxs965266509/article/details/49816007" target="_blank" rel="external">DroidFix</a></p>
<h1 id="Tinker"><a href="#Tinker" class="headerlink" title="Tinker"></a>Tinker</h1><p>微信的热补丁方案叫做Tinker，也算缅怀一下Dota中的地精修补匠，希望能做到无限刷新。(@LGD_MMY)</p>
<p>Tinker 的方案来源 gradle 编译的 instant run 与 buck 编译的 exopackage。它们的思想都是全量替换新的 Dex。即我们完全使用了新的 Dex，那样既不出现 Art 地址错乱的问题，在 Dalvik 也无须插桩。</p>
<p>简单来说，在编译时通过新旧两个Dex生成差异patch.dex。在运行时，将差异patch.dex重新跟原始安装包的旧Dex还原为新的Dex。</p>
<p>但是 instant run 针对的是编译期，它可以直接将最后生成的所有变化都直接拷到手机端。对于线上方案，这肯定是不可行的。所以当前核心问题是找到合适的，使补丁结果更小的差分算法。</p>
<p>微信自研了DexDiff算法，它深度利用Dex的格式来减少差异的大小。它的粒度是Dex格式的每一项，可以充分利用原本Dex的信息，而BsDiff的粒度是文件，AndFix/Qzone的粒度为class。</p>
<p>Tinker 的框架设计，它主要包括以下几部分：</p>
<ol>
<li>补丁合成；这些都在单独的 patch 进程工作，这里包括dex，so还有资源，主要完成补丁包的合成以及升级；</li>
<li>补丁的加载；如何通过反射系统加载我们合成好的 dex，so 与资源；</li>
<li>监控回调；在合成与加载过程中，出现问题及时回调；</li>
<li>版本管理；Tinker 支持补丁升级，甚至是多个补丁不停的切换。需要保证所有进程版本的一致性；</li>
<li>安全校验；无论在补丁合成还是加载，都需要有必要的安全校验。</li>
</ol>
<p>目前Tinker资料较少，只了解了大概。据说会开源，持续关注中。</p>
<p>参考资料：<br><a href="http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/" target="_blank" rel="external">各大热补丁方案分析和比较</a><br><a href="http://www.jianshu.com/p/b29a21a162ad" target="_blank" rel="external">Dalvik虚拟机原理及Xposed hook原理</a><br><a href="http://blog.csdn.net/qxs965266509/article/details/50117137" target="_blank" rel="external">Alibaba-Dexposed Bug框架原理及源码解析</a><br><a href="http://blog.csdn.net/qxs965266509/article/details/49816007" target="_blank" rel="external">Alibaba-AndFix Bug热修复框架原理及源码解析</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect" target="_blank" rel="external">安卓App热补丁动态修复技术介绍</a><br><a href="http://mp.weixin.qq.com/s?spm=a1z2e.7794127.0.0.Q7LExa&amp;__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286306&amp;idx=1&amp;sn=d6b2865e033a99de60b2d4314c6e0a25&amp;scene=0&amp;__nc=1#wechat_redirect" target="_blank" rel="external">微信Android热补丁实践演进之路</a><br><a href="http://dev.qq.com/topic/57ad7a70eaed47bb2699e68e" target="_blank" rel="external">微信热补丁Tinker的实践演进之路</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继插件化后，热补丁技术在2015年开始爆发，目前已经是非常热门的Android开发技术。其中比较著名的有淘宝的Dexposed、支付宝的AndFix以及Qzone的超级热补丁方案，还有最新的微信Tinker方案。&lt;br&gt;我的理解是Android热补丁就是不需要重新安装应用，而是动态地修复应用的Bug的技术，这项技术非常实用，毕竟每天都会看到一两个应用提示要求更新，而更新仅仅是修复一两个Bug,但却要下载几十M的APK文件，花费几分钟的时间安装，麻烦！&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android热补丁" scheme="http://yoursite.com/tags/Android%E7%83%AD%E8%A1%A5%E4%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-插件化</title>
    <link href="http://yoursite.com/2016/08/21/Android%E7%AC%94%E8%AE%B0-%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    <id>http://yoursite.com/2016/08/21/Android笔记-插件化/</id>
    <published>2016-08-21T01:59:42.000Z</published>
    <updated>2016-09-01T06:18:14.367Z</updated>
    
    <content type="html"><![CDATA[<p>最近Android插件化、热补丁等技术很火，网上陆续也发布了很多相关的资料。<br>我的理解是Android插件化就是当应用想要实现某功能，可以直接从网络上下载安装，并且这个过程可以发生在运行中的技术。(就像魔兽世界使用到的大脚插件、魔盒插件一样)<br>很多知名的Android应用已经应用到了这些技术，大致总结下吧，以后实际工作中很有可能会使用到。</p>
<a id="more"></a>
<h1 id="为什么要插件化"><a href="#为什么要插件化" class="headerlink" title="为什么要插件化"></a>为什么要插件化</h1><p>在开发应用时，随着业务规模发展到一定程度，不断地加入新功能、添加新的类库，代码在急剧的膨胀，相应的apk包的大小也急剧增加，那么就会遇到65536问题。</p>
<p>65536：超过最大方法数限制的问题，是由于DEX文件格式限制，一个DEX文件中method个数采用使用原生类型short来索引文件中的方法，也就是4个字节共计最多表达65536个method，field/class的个数也均有此限制。对于DEX文件，则是将工程所需全部class文件合并且压缩到一个DEX文件期间，也就是Android打包的DEX过程中， 单个DEX文件可被引用的方法总数（自己开发的代码以及所引用的Android框架、类库的代码）被限制为65536；</p>
<p>解决这个问题，一般有下面几种方案，一种方案是加大Proguard的力度来减小DEX的大小和方法数，但这是治标不治本的方案，随着业务代码的添加，方法数终究会到达这个限制。</p>
<p>一种比较流行的方案是插件化方案。Google提供了MultiDex方案：</p>
<ol>
<li>修改Gradle配置文件，启用MultiDex并包含MultiDex支持；</li>
<li>让应用支持多DEX文件。在官方文档中描述了三种可选方法：<br>在AndroidManifest.xml的application中声明android.support.MultiDex.MultiDexApplication；<br>如果你已经有自己的Application类，让其继承MultiDexApplication；<br>如果你的Application类已经继承自其它类，你不想/能修改它，那么可以重写attachBaseContext()方法；</li>
</ol>
<p>MultiDex的基本原理是把通过DexFile来加载Secondary DEX，并存放在BaseDexClassLoader的DexPathList中。</p>
<p>MultiDex的安装大概分为几步：</p>
<ul>
<li>打开apk这个zip包；</li>
<li>MultiDex的dex解压出来（除去Classes.dex之外的其他DEX，例如：classes2.dex， classes3.dex等等)，因为android系统在启动app时只加载了第一个Classes.dex，其他的DEX需要我们人工进行安装</li>
<li>通过反射进行安装；</li>
</ul>
<p>这三步其实都比较耗时，容易造成主线程的ANR。</p>
<p><a href="http://v.youku.com/v_show/id_XNTMzMjYzMzM2.html?firsttime=3112&amp;spm=0.0.uerCenter.5-2_5_5-2_5_DL_DD_A.y0ifrV&amp;from=y1.9-3.1" target="_blank" rel="external">《阿里技术沙龙第十六期《android插件化及动态部署——ATLAS》</a>里面说道一个App可能开发过程中，可能会有多个团队要求往这个App中加入新的业务，这样之前的协作模式难以为继，需要新的开发模式和技术解决需求问题。</p>
<p>前端可以实现在线更新持续发布，而源生的Native架构的Android需要用户重新下载安装包安装更新，插件化动态加载方案就是提供了如同前端一样的热部署能力。把业务拆分出来，组成外部的dex包。不同的团队专注于自己的业务，当需要更新时，不用下载更新整个App，而仅仅是下载对应的dex。</p>
<h1 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h1><p>真正的动态加载应该是：</p>
<ol>
<li>应用在运行的时候通过加载一些本地不存在的可执行文件实现一些特定的功能;</li>
<li>这些可执行文件是可以替换的;</li>
<li>更换静态资源（比如换启动图、换主题、或者用服务器参数开关控制广告的隐藏现实等）不属于动态加载;</li>
<li>Android中动态加载的核心思想是动态调用外部的 dex文件，极端的情况下，Android APK自身带有的Dex文件只是一个程序的入口（或者说空壳），所有的功能都通过从服务器下载最新的Dex文件完成;</li>
</ol>
<h1 id="Android动态加载的类型"><a href="#Android动态加载的类型" class="headerlink" title="Android动态加载的类型"></a>Android动态加载的类型</h1><p>Android项目中，动态加载技术按照加载的可执行文件的不同大致可以分为两种：</p>
<ul>
<li>动态加载so库:<br>动态加载so库应该就是Android最早期的动态加载了，不过so库不仅可以存放在APK文件内部，还可以存放在外部存储。</li>
<li>动态加载dex/jar/apk文件（基于ClassLoader）。</li>
</ul>
<h1 id="动态加载-so库"><a href="#动态加载-so库" class="headerlink" title="动态加载 so库"></a>动态加载 so库</h1><p>Android中NDK中其实就使用了动态加载，动态加载.so库并通过JNI调用其封装好的方法。</p>
<p>.so是由C/C++编译而成，运行在Native层，效率会比执行在虚拟机层的Java代码高很多，所以Android中经常通过动态加载.so库来完成一些对性能比较有需求的工作（比如T9搜索、或者Bitmap的解码、图片高斯模糊处理等）。</p>
<p>一般情况下我们是把so库一并打包在APK内部的，但是so库其实也是可以从外部存储文件加载的。</p>
<h1 id="动态加载dex-jar-apk文件"><a href="#动态加载dex-jar-apk文件" class="headerlink" title="动态加载dex/jar/apk文件"></a>动态加载dex/jar/apk文件</h1><p>动态加载dex/jar/apk文件其实就是动态加载.class文件，利用了Java允许运行时加载类的特性。</p>
<p>在 Android 中，ClassLoader 是一个抽象类，实际开发过程中，我们一般是使用其具体的子类 DexClassLoader、PathClassLoader 这些类加载器来加载类的，它们的不同之处是：</p>
<ul>
<li>DexClassLoader 可以加载 jar/apk/dex，可以从 SD 卡中加载未安装的 apk；</li>
<li>PathClassLoader 只能加载系统中已经安装过的 apk；</li>
</ul>
<p>PathClassLoader也有一个成员pathList，它从本质来说是一个List，运行时会从其间的每一个dex路径中查找需要加载的类。Google官方推出的MultiDex库就是用以上原理实现的。</p>
<p>我们可以使用DexClassLoader来在运行时加载一些外部的类，这个类可以从网络上下载，这样就实现了动态加载。</p>
<p>但是有Android与Java不同，有两个重要的问题需要解决。</p>
<ul>
<li>Android 中许多组件类（如 Activity、Service 等）是需要在 Manifest 文件里面注册后才能工作的（系统会检查该组件有没有注册），所以即使动态加载了一个新的组件类进来，没有注册的话还是无法工作；</li>
<li>Res 资源是 Android 开发中经常用到的，而 Android 是把这些资源用对应的 R.id 注册好，运行时通过这些 ID 从 Resource 实例中获取对应的资源。如果是运行时动态加载进来的新类，那类里面用到 R.id 的地方将会抛出找不到资源或者用错资源的异常，因为新类的资源 ID 根本和现有的 Resource 实例中保存的资源 ID 对不上；</li>
</ul>
<h1 id="代理Activity-常规"><a href="#代理Activity-常规" class="headerlink" title="代理Activity(常规)"></a>代理Activity(常规)</h1><p>主项目APK注册一个代理Activity（命名为ProxyActivity），ProxyActivity是一个普通的Activity，但只是一个空壳，自身并没有什么业务逻辑。</p>
<p>每次打开插件APK里的某一个Activity的时候，都是在主项目里使用标准的方式启动ProxyActivity，再在ProxyActivity的生命周期里同步调用插件中的Activity实例的生命周期方法，从而执行插件APK的业务逻辑。</p>
<p>这样就解决了没法在Manifest中注册的问题，那么如何在插件Activity中使用Res资源？</p>
<p>我们可以采用了反射的方法调用AssetManager的“addAssetPath”方法加载插件APK里的资源，构造出一个新的Resource实例。这样代理Activity其实有两套Res实例，一套是主项目共有的，另一套是插件APK里的。这样就防止了R.id重复了。</p>
<p>代理Activity模式的限制：</p>
<ul>
<li>需要在Manifest注册的功能都无法在插件实现，比如应用权限、LaunchMode、静态广播等；</li>
<li>宿主一个代理用的Activity难以满足插件一些特殊的Activity的需求，插件Activity的开发受限于代理Activity；</li>
<li>宿主项目和插件项目的开发都要接入共同的框架，大多时候，插件需要依附宿主才能运行，无法独立运行；</li>
</ul>
<p>实例框架：<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Apk动态加载框架</a></p>
<h1 id="动态创建Activity模式-非常规"><a href="#动态创建Activity模式-非常规" class="headerlink" title="动态创建Activity模式(非常规)"></a>动态创建Activity模式(非常规)</h1><p>动态创建Activity模式的核心是“运行时字节码操作”，先在宿主注册一个不存在的Activity，启动插件的某个Activity时都把想要启动的Activity替换成前面注册的Activity，从而使后者能正常启动。</p>
<ul>
<li>使用dexmaker动态创建一个类。</li>
<li>修改需要启动的目标Activity。</li>
</ul>
<p>开源项目：<a href="https://github.com/houkx/android-pluginmgr/" target="_blank" rel="external">android-pluginmgr</a></p>
<h1 id="代理模式与动态创建模式的区别"><a href="#代理模式与动态创建模式的区别" class="headerlink" title="代理模式与动态创建模式的区别"></a>代理模式与动态创建模式的区别</h1><p>简单地说，最大的不同是代理模式使用了一个代理的Activity，而动态创建Activity模式使用了一个通用的Activity。</p>
<p>代理模式中，使用一个代理Activity去完成本应该由插件Activity完成的工作，这个代理Activity是一个标准的Android Activity组件，具有生命周期和上下文环境（ContextWrapper和ContextCompl），但是它自身只是一个空壳，并没有承担什么业务逻辑；而插件Activity其实只是一个普通的Java对象，它没有上下文环境，但是却能正常执行业务逻辑的代码。代理Activity和不同的插件Activity配合起来，就能完成不同的业务逻辑了。</p>
<p>动态创建Activity模式，被动态创建出来的Activity类是有在主项目里面注册的，它是一个标准的Activity，它有自己的Context和生命周期，不需要代理的Activity。</p>
<p>参考资料<br><a href="http://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="external">美团Android DEX自动拆包及动态加载简介</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTcwNTE0NA==&amp;mid=400217391&amp;idx=1&amp;sn=86181541ce0164156dfab135ed99bb5c&amp;scene=0&amp;key=b410d3164f5f798e61a5d4afb759fa38371c8b119384c6163a30c28163b4d4d5f59399f2400800ec842f1d0e0ffb84af&amp;ascene=0&amp;uin=MjExMjQ&amp;pass_ticket=Nt5Jaa28jjFxcQO9o%20vQiXX%200iXG5DlZlHNW97Fk1Ew=" target="_blank" rel="external">携程Android App插件化和动态加载实践</a><br><a href="https://segmentfault.com/a/1190000004062866" target="_blank" rel="external">Android动态加载技术 简单易懂的介绍方式</a><br><a href="https://segmentfault.com/a/1190000004062972" target="_blank" rel="external">Android动态加载进阶 代理Activity模式</a><br><a href="https://segmentfault.com/a/1190000004077469" target="_blank" rel="external">Android动态加载黑科技 动态创建Activity模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近Android插件化、热补丁等技术很火，网上陆续也发布了很多相关的资料。&lt;br&gt;我的理解是Android插件化就是当应用想要实现某功能，可以直接从网络上下载安装，并且这个过程可以发生在运行中的技术。(就像魔兽世界使用到的大脚插件、魔盒插件一样)&lt;br&gt;很多知名的Android应用已经应用到了这些技术，大致总结下吧，以后实际工作中很有可能会使用到。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android插件化" scheme="http://yoursite.com/tags/Android%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-DataBinding</title>
    <link href="http://yoursite.com/2016/08/19/Android%E7%AC%94%E8%AE%B0-DataBinding/"/>
    <id>http://yoursite.com/2016/08/19/Android笔记-DataBinding/</id>
    <published>2016-08-19T01:24:20.000Z</published>
    <updated>2016-08-28T04:07:32.114Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目中试用了一下DataBinding技术，觉得还蛮好用的。这项技术是Google对于MVVM在Android上的一种实现，已经装载进Android SDK里面了，足可见Google对它的重视。<br>当前还只是测试版本，使用的人不多，但我觉得这种技术应该会成为Android主流开发技术之一。<br>Data Binding，数据绑定，是Google对MVVM在Android上的一种实现，可以直接绑定数据到xml中，并实现自动刷新。</p>
<a id="more"></a>
<h1 id="为什么要使用-Data-Binding"><a href="#为什么要使用-Data-Binding" class="headerlink" title="为什么要使用 Data Binding"></a>为什么要使用 Data Binding</h1><p>在最初学习Android的时候，我们在XML文件上定义的控件往往会给它取一个ID，然后在Activity或Fragment中使用findViewById找到它，如果要使用点击事件，那么还要setOnClickListener。这使我们的代码中有一大段都是这样的排列。</p>
<p>后来我们使用了ButterKnife，这让我们轻松多了，不必再写大段的findViewById和setOnClickListener，但是基本思想没有变，还是要在Java文件中找到XML文件中对应的控件，引用它然后使用它。</p>
<p>ButterKnife使用了注解处理器，在编译时生成了辅助代码来达到注入的目的，比如在MainActivity使用ButterKnife就会生成这样的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>$$<span class="title">ViewBinder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">MainActivity</span>&gt; <span class="keyword">implements</span> <span class="title">ViewBinder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Unbinder <span class="title">bind</span><span class="params">(<span class="keyword">final</span> Finder finder, <span class="keyword">final</span> T target, Object source)</span> </span>&#123;</div><div class="line">    InnerUnbinder unbinder = createUnbinder(target);</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> unbinder;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> InnerUnbinder&lt;T&gt; <span class="title">createUnbinder</span><span class="params">(T target)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InnerUnbinder(target);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerUnbinder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">MainActivity</span>&gt; <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> T target;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">InnerUnbinder</span><span class="params">(T target)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.target = target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">(T target)</span> </span>&#123;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>target就是MainActivity实例，ButterKnife会帮我们找到使用@BindView(R.id.xxx)标注的控件然后绑定。</p>
<p>ButterKnife帮我们省了很多的工作，但是我们想走得更远。</p>
<p>如果有一个布局文件，并有它们的 IDs，可以使用 Holdr，它可以替你可以处理布局文件，然后为他们创建 View 组件。你通过 Holder，转换 View 的 ID 到组件变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Holdr_ActivityMain holder;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">  setContentView(R.layout.activity_main);</div><div class="line">  holder = <span class="keyword">new</span> Holdr_ActivityMain(findViewById(content));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUI</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</div><div class="line">    holder.name.setText(<span class="keyword">null</span>);</div><div class="line">    holder.lastName.setText(<span class="keyword">null</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    holder.name.setText(user.getName());</div><div class="line">    holder.lastName.setText(user.getLastName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这里还有一个可能我们没有想到的麻烦、一个我们无论如何无法减少代码量的地方，它也是很简单的代码：我有一个 User 对象，我只是想把数据内容从这个 User 对象转移到 View 当中，但我们往往改了一个地方，忘了另一个地方，最终导致了产品运行崩溃。</p>
<p>使用 Data Binding，它很像 Holder 模式，而且你只要做一点点事情，其余的内容 Data Binding 会帮你完成。</p>
<h2 id="使用DataBinding"><a href="#使用DataBinding" class="headerlink" title="使用DataBinding"></a>使用DataBinding</h2><ul>
<li>首先在xml的最外层套上layout标签；</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    &lt;layout&gt;</div><div class="line">    &lt;data&gt;</div><div class="line">        &lt;variable name="user"</div><div class="line">                  type="com.android.example.User"/&gt;</div><div class="line"></div><div class="line">        &lt;variable name="presenter"</div><div class="line">                  type="com.android.example.Presenter"/&gt;          </div><div class="line">    &lt;/data&gt;</div><div class="line">    &lt;LinearLayout …&gt;</div><div class="line">        &lt;TextView android:text="@&#123;user.name&#125;"/&gt;</div><div class="line">        &lt;TextView android:text="@&#123;user.lastName&#125;"/&gt;</div><div class="line">        &lt;TextView android:onClick="@&#123;presenter.onBindService&#125;"/&gt;</div><div class="line">    &lt;/LinearLayout&gt;</div><div class="line">&lt;/layout&gt;</div></pre></td></tr></table></figure>
<ul>
<li>声明控件绑定的变量或事件；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    binding= DataBindingUtil.setContentView(<span class="keyword">this</span>,R.layout.activity_test);</div><div class="line">    binding.setEmployee(employee);</div><div class="line">    binding.setPresenter(<span class="keyword">new</span> Presenter());</div><div class="line">&#125;</div></pre></td></tr></table></figure>  
<ul>
<li>在Java代码声明绑定的变量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String lastName;</div><div class="line">    <span class="keyword">private</span> String firstName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String lastName, String firstName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Bindable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">        notifyPropertyChanged(BR.lastName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bindable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        notifyPropertyChanged(BR.firstName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>Employee类如要想实现数据变化时更新View，那就要继承了BaseObservable或实现Observable接口。</p>
</li>
<li><p>DataBinding使用 notifyPropertyChanged来进行数据改变完成通知，但我们怎么通知一个数据即将改变？我们不得不写一个 @Bindable 注解。这将会自动产生一个 BR.firstName，这个 BR 很像我们经常使用的 R 类文件，我们通过这些注解会自动生成它。</p>
</li>
<li><p>在Java代码声明绑定的事件处理者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span></span>&#123;</div><div class="line">        Snackbar.make(view,<span class="string">"点到了"</span>,Snackbar.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">｝</div></pre></td></tr></table></figure>  
</li>
</ul>
<p>这样就完成了数据绑定，当employee对象的name变量发生改变时，绑定employee对象的TextView能够感知到这种变化，从而让自己的text文本发生改变。当绑定Presenter实例TextView接收到点击事件时，Presenter里的方法处理这个点击事件。</p>
<h1 id="DataBinding工作原理"><a href="#DataBinding工作原理" class="headerlink" title="DataBinding工作原理"></a>DataBinding工作原理</h1><h3 id="1-进入并处理布局文件"><a href="#1-进入并处理布局文件" class="headerlink" title="1.进入并处理布局文件"></a>1.进入并处理布局文件</h3><p>其中的“进入”指的是，在你的程序代码正在被编译的过程中，它会找出布局文件中所有关于它的内容，获取到它所需要的信息，然后删掉它们，删掉它们的原因是如果继续存着视图系统并不认得它们。</p>
<h3 id="2-通过语法来解析这些表达式"><a href="#2-通过语法来解析这些表达式" class="headerlink" title="2.通过语法来解析这些表达式"></a>2.通过语法来解析这些表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;TextView android:visibility=<span class="string">"@user.isAdmin ? View.VISIBLE : View.GONE&#125;"</span>/&gt;</div></pre></td></tr></table></figure>  
<p>这个 user 是一个索引，之后的 View 也是个索引，另一个 View 也是个索引。它们都是索引或称标识，像是真正的对象，在这边我们真的不知道它们是什么。同样的对于 VISIBLE 和 GONE 也是如此。这里面有对象数据访问，是一个三目运算表达式，这就是目前为止我们所理解到的。而对于DataBinding库，它的工作就是从这些文件中把东西解析出来，了解里面有什么。</p>
<h3 id="在代码编译过程中解决相关依赖问题"><a href="#在代码编译过程中解决相关依赖问题" class="headerlink" title="在代码编译过程中解决相关依赖问题"></a>在代码编译过程中解决相关依赖问题</h3><p>在这一步中，例如，我们看一下 user.isAdmin，想：“这是在运行时获取到 User 类对象中的一个布尔值。”</p>
<h3 id="Data-Binding-会自动生成一些类文件"><a href="#Data-Binding-会自动生成一些类文件" class="headerlink" title="Data Binding 会自动生成一些类文件"></a>Data Binding 会自动生成一些类文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityTestBinding</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">databinding</span>.<span class="title">ViewDataBinding</span>  </span>&#123;</div><div class="line">       ...</div><div class="line">       <span class="comment">//很长的一个类在build/generated/source/apt中编译时生成</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>  
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>不用自己在Java文件中引用View对象，减少耦合。也不必给使用的每一个View取一个ID。</li>
<li>数据更新时，View的内容也会更新，而不必自己操控。</li>
<li><p>性能提升<br>当你在Android系统上使用代码findById，它实际上是对它对所有子内容说：“孩子，你能通过ID找到这个 view 吗？”那个孩子（子内容）问自己的孩子，然后找不到就去问下一个孩子，直到你找到了这个 view。然后，你的代码findViewById对于其他 View 会再重新做一次，重复的没必要的同样事情再次发生。</p>
<p>当你初始化数据绑定时，我们实际上知道在编译时我们对应的 View，所以我们有一个方法来找到我们想要的所有 View。我们只需遍历布局层次一次，就可以收集到所有的 View。这个计算只对于一个布局只发生一次。当第二次我们需要另一个其中的子 View 的时候，不需要再次遍历所有子 View，因为我们已经找到了所有的 View。</p>
</li>
<li><p>保证执行在主线程<br>这里的一个方便的是，你不必在UI线程进行通知：你可以在任何你想要的线程上进行更新。然而，我们仍然是在将在UI线程进行响应，所以你必须小心。此外，对于列表请不要这样做的！对于列表，你仍然应该在UI线程上通知，因为我们将在UI线程读取到，并且我们将需要在UI线程读取到它的长度，我们不做任何类型的同步。你可能已经知道这样对于 RecyclerView 和ListView会造成很多问题。这是因为列表本身的问题，而不是因为这些类的问题。</p>
</li>
</ul>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ul>
<li>IDE支持还不那么完善（提示、表达式）</li>
<li>报错信息不那么直接</li>
<li>重构支持不好（xml中进行重构，java代码不会自动修改）</li>
</ul>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>DataBinding没使用到的地方还有很多，我仅仅只使用了比较基础的功能。对于这个库，特别明显的感受就是Android Stuio支持还不完善，老是报莫名奇妙的错误，而错误信息都不是那么直接明了，常常需要ReBuild或Sync项目。<br>Google既然把它放在了Android SDK中，那肯定意味这MVVM是Google所提倡的开发模式。所以DataBinding技术有着广阔的发展前景，值得学习。</p>
<p>参考资料：<br><a href="https://realm.io/cn/news/data-binding-android-boyar-mount/" target="_blank" rel="external">棉花糖给 Android 带来的 Data Bindings（数据绑定库）</a><br><a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">Data Binding Library</a><br><a href="http://blog.zhaiyifan.cn/2016/06/16/android-new-project-from-0-p7/#more" target="_blank" rel="external">从零开始的Android新项目7 - Data Binding</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在项目中试用了一下DataBinding技术，觉得还蛮好用的。这项技术是Google对于MVVM在Android上的一种实现，已经装载进Android SDK里面了，足可见Google对它的重视。&lt;br&gt;当前还只是测试版本，使用的人不多，但我觉得这种技术应该会成为Android主流开发技术之一。&lt;br&gt;Data Binding，数据绑定，是Google对MVVM在Android上的一种实现，可以直接绑定数据到xml中，并实现自动刷新。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android开发框架" scheme="http://yoursite.com/tags/Android%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
      <category term="DataBinding" scheme="http://yoursite.com/tags/DataBinding/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-MVP模式</title>
    <link href="http://yoursite.com/2016/08/18/Android%E7%AC%94%E8%AE%B0-MVP%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/08/18/Android笔记-MVP模式/</id>
    <published>2016-08-18T08:03:31.000Z</published>
    <updated>2016-08-28T03:55:44.283Z</updated>
    
    <content type="html"><![CDATA[<p>现在很多的Android项目中基本都使用了这种开发模式，我自己也在最近写的项目中应用到了这种开发模式，虽然项目中会多出很多的接口和类，特别是和dagger2联用之后，但项目本身架构确实清晰多了，最主要的作用我认为是将视图逻辑和业务逻辑分离。<br>关于MVP模式看了很多资料，网上的代码各有各的实现方式，其基本思想大体是相同的。其实Android开发还有MVC模式、MVVM模式等。这些模式并没有明确的规定，都是设计的理念，方法。</p>
<a id="more"></a>
<p>MVP(Model-View-Presenter)可以算是MVC(Model-View-Controller)进化来的。</p>
<h1 id="Android-MVC"><a href="#Android-MVC" class="headerlink" title="Android MVC"></a>Android MVC</h1><p>MVC 模式的结构分为三部分，实体层的 Model，视图层的 View，以及控制层的 Controller。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/14605656357298621.jpg" alt="Image"></p>
<ul>
<li>Model: JavaBean 实体类，用于保存实例数据。</li>
<li>View:  UI 界面，用于向用户展示数据以及接收用户的输入，layout.xml里面的xml文件。</li>
<li>Controller: 用于更新 UI 界面和数据实例，activity、fragment等。</li>
</ul>
<p>当用户出发事件的时候，view层会发送指令到controller层，接着controller去通知model层更新数据，model层更新完数据以后直接显示在view层上，这就是MVC的工作原理。</p>
<ul>
<li>问题一就在于xml作为view层，控制能力实在太弱了，你想去动态的改变一个页面的背景，或者动态的隐藏/显示一个按钮，这些都没办法在xml中做，只能把代码写在activity中，造成了activity既是controller层，又是view层的这样一个窘境。</li>
<li>还有一个重要的缺陷，view层和model层是相互可知的，这意味着两层之间存在耦合，耦合对于一个大型程序来说是非常致命的，因为这表示开发，测试，维护都需要花大量的精力。</li>
</ul>
<h1 id="Android-MVP"><a href="#Android-MVP" class="headerlink" title="Android MVP"></a>Android MVP</h1><p>MVP 模式的结构也分为三部分，实体层Model，视图层的View，业务逻辑层Presenter。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/14605656371149681.jpg" alt="Image"></p>
<ul>
<li>Model:  同样是JavaBean 实体类，用于保存实例数据。</li>
<li>View: 界面展示，仅用于展示UI，activity、fragment等。</li>
<li>Presenter: 逻辑处理，自定义的类。</li>
</ul>
<p>MVP 模式的核心思想<br>MVP 把 Activity 中的 UI 逻辑抽象成 View 接口，把业务逻辑抽象成 Presenter 接口，Model 类还是原来的 Model。</p>
<h1 id="MVP的实现"><a href="#MVP的实现" class="headerlink" title="MVP的实现"></a>MVP的实现</h1><p>我大致是如下思路实现MVP的，MVP的实现方式有很多，每个人的理解可能都不一样，<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">Google官方样例</a>把View层的接口和Presenter层的接口放在一个接口Contract之中，并且页面布局都采用Activity嵌套Fragment的模式，这样基本就明示了一个View层对应一个Presenter层。网上也有很多种不同的实现方式，还可以将dagger2应用进来，将Presenter层的实例注入到View层中，通过Scope限定符可以让Presenter层与View层的生命周期一致。</p>
<h2 id="抽象View层的视图逻辑"><a href="#抽象View层的视图逻辑" class="headerlink" title="抽象View层的视图逻辑"></a>抽象View层的视图逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainView</span> <span class="keyword">extends</span> <span class="title">BaseView</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onShowRefresh</span><span class="params">(List&lt;Result&gt; results)</span></span>;     <span class="comment">//显示下拉刷新的数据</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onShowMoreAsked</span><span class="params">(List&lt;Result&gt; results)</span></span>;   <span class="comment">//显示上拉加载的数据</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onShowNoData</span><span class="params">()</span></span>;                          <span class="comment">//显示没有数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="抽象Presenter层的业务逻辑"><a href="#抽象Presenter层的业务逻辑" class="headerlink" title="抽象Presenter层的业务逻辑"></a>抽象Presenter层的业务逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainPresenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doOnRefresh</span><span class="params">()</span></span>;                                      <span class="comment">//处理下拉刷新</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doOnMoreAsked</span><span class="params">()</span></span>;                                    <span class="comment">//处理上拉加载更多</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doOnItemClick</span><span class="params">(View view, String url)</span></span>;               <span class="comment">//处理点击事件</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>  
<h2 id="实现Presenter层"><a href="#实现Presenter层" class="headerlink" title="实现Presenter层"></a>实现Presenter层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenterCompl</span> <span class="keyword">implements</span> <span class="title">MainPresenter</span> </span>&#123;</div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPresenterCompl</span><span class="params">(MainView mainView, String type)</span></span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOnRefresh</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        mainView.onShowRefresh(results);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOnMoreAsked</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        mainView.onShowMoreAsked(results);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOnItemClick</span><span class="params">(View view, String url)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>     
<p>Presenter实现类PresentCompl获得了MainView的引用，这样就可以在处理逻辑完成之后回调View层抽象出来的方法。</p>
<h2 id="View层应用Presenter层"><a href="#View层应用Presenter层" class="headerlink" title="View层应用Presenter层"></a>View层应用Presenter层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragment</span> <span class="keyword">implements</span> <span class="title">MainView</span>,...</span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span> MainPresenterCompl mainPresenter;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    RecyclerUtils.RecyclerItemClickListener.OnItemClickListener()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">            mainPresenter.doOnItemClick(view,mResults.get(position).getUrl());<span class="comment">//处理点击事件</span></div><div class="line">        &#125;</div><div class="line">    &#125;));</div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">//显示下拉刷新数据</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowRefresh</span><span class="params">(List&lt;Result&gt; results)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//显示上拉加载更多数据</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowMoreAsked</span><span class="params">(List&lt;Result&gt; results)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//下拉刷新</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</div><div class="line">        mainPresenter.doOnRefresh();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//上拉加载更多</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMoreAsked</span><span class="params">(<span class="keyword">int</span> overallItemsCount, <span class="keyword">int</span> itemsBeforeMore, <span class="keyword">int</span> maxLastVisiblePosition)</span></span>&#123;</div><div class="line">        mainPresenter.doOnMoreAsked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>  
<p>MainFragment实现了MainView的接口，并且在类中创建了MainPresenterCompl实例对象，这样就可以通过MainPresenterCompl实例对象来处理业务逻辑，通过MainView接口方法在页面上显示业务逻辑处理后的结果。</p>
<p>这样，View层的Activity、Fragment就不用再写Controller的代码，也同Model层分离，只需关注于自己的生命周期任务和展示Presenter层返回的结果。</p>
<h1 id="MVP模式的作用"><a href="#MVP模式的作用" class="headerlink" title="MVP模式的作用"></a>MVP模式的作用</h1><ul>
<li>分离了视图逻辑和业务逻辑，降低了耦合。</li>
<li>Activity 只处理生命周期的任务，代码变得更加简洁。</li>
<li>视图逻辑和业务逻辑分别抽象到了 View 和 Presenter 的接口中去，提高代码的可阅读性。</li>
<li>Presenter 被抽象成接口，可以有多种具体的实现，所以方便进行单元测试。</li>
<li>把业务逻辑抽到 Presenter 中去，避免后台线程引用着 Activity 导致 Activity 的资源无法被系统回收从而引起内存泄露和 OOM。</li>
</ul>
<p><br><br>参考资料：<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0105/3832.html" target="_blank" rel="external">Android开发中的MVP架构</a><br><a href="http://blog.zhaiyifan.cn/2015/06/01/use-mvp-to-write-nice-code/" target="_blank" rel="external">应用MVP模式写出可维护的优美Android应用</a><br><a href="http://kaedea.com/2015/10/11/android-mvp-pattern/" target="_blank" rel="external">MVP 模式简单易懂的介绍方式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在很多的Android项目中基本都使用了这种开发模式，我自己也在最近写的项目中应用到了这种开发模式，虽然项目中会多出很多的接口和类，特别是和dagger2联用之后，但项目本身架构确实清晰多了，最主要的作用我认为是将视图逻辑和业务逻辑分离。&lt;br&gt;关于MVP模式看了很多资料，网上的代码各有各的实现方式，其基本思想大体是相同的。其实Android开发还有MVC模式、MVVM模式等。这些模式并没有明确的规定，都是设计的理念，方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MVP模式" scheme="http://yoursite.com/tags/MVP%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Dagger2</title>
    <link href="http://yoursite.com/2016/08/18/Android%E7%AC%94%E8%AE%B0-Dagger2/"/>
    <id>http://yoursite.com/2016/08/18/Android笔记-Dagger2/</id>
    <published>2016-08-18T01:21:28.000Z</published>
    <updated>2016-08-28T04:36:00.380Z</updated>
    
    <content type="html"><![CDATA[<p>Dagger2是为Android和Java平台提供的一个完全静态的，在编译时进行依赖注入的框架。一开始使用的时候也不太明白依赖注入有什么好用的地方，可能是开发的项目比较小，体会不到Dagger2牛逼之处。后来才发现Dagger2真心牛逼。<br>我们在做项目时，经常需要在一个对象里去创建另一个对象的示例，这种行为是产生耦合的常见形式，对于一个大型项目来说，过多的相互依赖会导致代码难以维护，很容易就会碰到修改一个小需求需要大面积的修改各种代码。<br>我的理解是Dagger2主要作用有两点，一是依赖的类和提供依赖的类的实现方法分离，二是在Android中帮助我们实现对象生命周期管理。</p>
<a id="more"></a>
<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>就是目标类中所依赖的其他的类的初始化过程，不是通过手动编码的方式创建，而是通过技术手段可以把其他的类的已经初始化好的实例自动注入到目标类中。</p>
<p>人们在很长的一段时间里都是利用控制反转原则规定：应用程序的流程取决于在程序运行时对象图的建立。通过抽象定义的对象交互可以实现这样的动态流程。而使用依赖注入技术或者服务定位器便可以完成运行时绑定。</p>
<p>使用依赖注入可以带来以下好处：</p>
<ul>
<li>依赖的注入和配置独立于组件之外。</li>
<li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</li>
<li>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</li>
</ul>
<p>能够管理创建实例的范围是一件非常棒的事情。App中的所有对象或者协作者都不应该知道有关实例创建和生命周期的任何事情，这些都应该由我们的依赖注入框架管理的。</p>
<h1 id="Dagger2"><a href="#Dagger2" class="headerlink" title="Dagger2"></a>Dagger2</h1><p>Dagger2是Dagger1的分支，由谷歌公司接手开发，目前的版本是2.0。Dagger2是受到AutoValue项目的启发。 Dagger2解决问题的基本思想是：利用生成和写的代码混合达到看似所有的产生和提供依赖的代码都是手写的样子。</p>
<p>Dagger构建在标准的javax.inject annotation基础之上, 每一个类都很容易测试。</p>
<h2 id="Inject"><a href="#Inject" class="headerlink" title="@Inject"></a>@Inject</h2><p>来标注目标类中所依赖的其他类，同样用注解来标注所依赖的其他类的构造函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inject</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainPresenterCompl</span><span class="params">(MainView mainView, String type)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.mainView = mainView;</div><div class="line">    <span class="keyword">this</span>.context=mainView.returnContext();</div><div class="line">    <span class="keyword">this</span>.type=type;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>标注PresenterCompl类构造函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inject</span> MainPresenterCompl mainPresenter;</div></pre></td></tr></table></figure><br>在目标类中就可以注入标注所依赖的类。</p>
<p>这样我们就可以让目标类中所依赖的其他类与其他类的构造函数之间有了一种无形的联系。但是要想使它们之间产生直接的关系，还得需要一个桥梁来把它们之间连接起来。那这个桥梁就是Component了。</p>
<h2 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h2><p>Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p>
<p>其实这是一个提供参数的地方，将new Presenter所需要的参数，写到这里面来了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenterModule</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MainView mainView;</div><div class="line">    <span class="keyword">private</span> String type;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPresenterModule</span><span class="params">(MainView mainView,String type)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.mainView=mainView;</div><div class="line">        <span class="keyword">this</span>.type=type;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">MainView <span class="title">provideMainView</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> mainView;&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">String <span class="title">provideType</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> type;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>  </p>
<h2 id="Provide"><a href="#Provide" class="headerlink" title="@Provide"></a>@Provide</h2><p>在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。Module中的创建类实例方法用Provides进行标注，Component在搜索到目标类中用Inject注解标注的属性后，Component就会去Module中去查找用Provides标注的对应的创建类实例方法。</p>
<h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>Component也是一个注解类，一个类要想是Component，必须用Component注解来标注该类，并且该类是接口或抽象类。</p>
<p>Component需要引用到目标类的实例，Component会查找目标类中用Inject注解标注的属性，查找到相应的属性后会接着查找该属性对应的用Inject标注的构造函数（这时候就发生联系了），剩下的工作就是初始化该属性的实例并把实例进行赋值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(modules = MainPresenterModule.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainFragment mainFragment)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Component是注入器，它一端连接目标类，另一端连接目标类依赖实例，它把目标类依赖实例注入到目标类中。上文中的Module是一个提供类实例的类，所以Module应该是属于Component的实例端的（连接各种目标类依赖实例的端），Component的新职责就是管理好Module，Component中的modules属性可以把Module加入Component，modules可以加入多个Module。</p>
<p>Component会首先从Module维度中查找类实例，若找到就用Module维度创建类实例，并停止查找Inject维度。否则才是从Inject维度查找类实例。所以创建类实例级别Module维度要高于Inject维度。</p>
<h2 id="注入目标类"><a href="#注入目标类" class="headerlink" title="注入目标类"></a>注入目标类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DaggerMainComponent.builder()</div><div class="line">            .mainPresenterModule(<span class="keyword">new</span> MainPresenterModule(<span class="keyword">this</span>,type))</div><div class="line">            .build()</div><div class="line">            .inject(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>实际上编译的时候会生成新的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerMainComponent</span> <span class="keyword">implements</span> <span class="title">MainComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Provider&lt;MainView&gt; provideMainViewProvider;</div><div class="line">    <span class="keyword">private</span> Provider&lt;String&gt; provideTypeProvider;</div><div class="line">    <span class="keyword">private</span> Provider&lt;MainPresenterCompl&gt; mainPresenterComplProvider;</div><div class="line">    <span class="keyword">private</span> MembersInjector&lt;MainFragment&gt; mainFragmentMembersInjector;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DaggerMainComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">        initialize(builder);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.provideMainViewProvider =</div><div class="line">        MainPresenterModule_ProvideMainViewFactory.create(builder.mainPresenterModule);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.provideTypeProvider =</div><div class="line">        MainPresenterModule_ProvideTypeFactory.create(builder.mainPresenterModule);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.mainPresenterComplProvider =</div><div class="line">        MainPresenterCompl_Factory.create(provideMainViewProvider, provideTypeProvider);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.mainFragmentMembersInjector =</div><div class="line">        MainFragment_MembersInjector.create(mainPresenterComplProvider);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainFragment mainFragment)</span> </span>&#123;</div><div class="line">        mainFragmentMembersInjector.injectMembers(mainFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> MainPresenterModule mainPresenterModule;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> MainComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (mainPresenterModule == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">             MainPresenterModule.class.getCanonicalName() + <span class="string">" must be set"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DaggerMainComponent(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">mainPresenterModule</span><span class="params">(MainPresenterModule mainPresenterModule)</span> </span>&#123;</div><div class="line">             <span class="keyword">this</span>.mainPresenterModule = Preconditions.checkNotNull(mainPresenterModule);</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>由于我们要将依赖注入到fragment中，所以会得到一个注入这个成员的注入器:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragment_MembersInjector</span> <span class="keyword">implements</span> <span class="title">MembersInjector</span>&lt;<span class="title">MainFragment</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;MainPresenterCompl&gt; mainPresenterProvider;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainFragment_MembersInjector</span><span class="params">(Provider&lt;MainPresenterCompl&gt; mainPresenterProvider)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> mainPresenterProvider != <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.mainPresenterProvider = mainPresenterProvider;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MembersInjector&lt;MainFragment&gt; <span class="title">create</span><span class="params">(</span></span></div><div class="line">        Provider&lt;MainPresenterCompl&gt; mainPresenterProvider) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainFragment_MembersInjector(mainPresenterProvider);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(MainFragment instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</div><div class="line">        &#125;</div><div class="line">        instance.mainPresenter = mainPresenterProvider.get();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectMainPresenter</span><span class="params">(</span></span></div><div class="line">        MainFragment instance, Provider&lt;MainPresenterCompl&gt; mainPresenterProvider) &#123;</div><div class="line">        instance.mainPresenter = mainPresenterProvider.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这个注入器一般都会为所有fragment的注入成员提供依赖，只要我们一调用inject()方法，就可以获取需要的字段和依赖。</p>
<h2 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h2><p>Dagger2可以通过自定义Scope注解，来限定通过Module和Inject方式创建的类的实例的生命周期能够与目标类的生命周期相同。或者可以这样理解：通过自定义Scope注解可以更好的管理创建的类实例的生命周期。</p>
<p>Dagger2的Scope，除了Singleton（root），其他都是自定义的，无论你给它命名PerActivity、PerFragment，其实都只是一个命名而已，真正起作用的是inject的位置，以及dependency。</p>
<p>Scope起的更多是一个限制作用，比如不同层级的Component需要有不同的scope，注入PerActivity scope的component后activity就不能通过@Inject去获得SingleTon的实例，需要从application去暴露接口获得（getAppliationComponent获得component实例然后访问，比如全局的navigator）。</p>
<p>Scope的真正用处就在于Component的组织。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/1431999102454673.png" alt="Image"></p>
<p>ApplicationComponent负责管理整个app用到的全局类实例,那这些全局类实例应该都是单例的，那就使用@Singleton注解使其保证唯一性。</p>
<p>Activity Component: 生命周期跟Activity一样的组件。</p>
<p>@PerActivity是一个自定义的范围注解，作用是允许对象被记录在正确的组件中，当然这些对象的生命周期应该遵循activity的生命周期。</p>
<p>User Component: 继承于ActivityComponent的组件，并用@PerActivity注解。</p>
<p>User Module: 提供跟用户相关的实例。它可以提供用户用例。</p>
<h1 id="dagger2有哪些好处"><a href="#dagger2有哪些好处" class="headerlink" title="dagger2有哪些好处"></a>dagger2有哪些好处</h1><ul>
<li>增加开发效率、省去重复的简单体力劳动。<br>new一个实例的过程是一个重复的简单体力劳动，dagger2完全可以把new一个实例的工作做了，因此我们把主要精力集中在关键业务上、同时也能增加开发效率上。<br>省去写单例的方法，并且也不需要担心自己写的单例方法是否线程安全，自己写的单例是懒汉模式还是饿汉模式。因为dagger2都可以把这些工作做了。</li>
<li>更好的管理类实例。<br>每个app中的ApplicationComponent管理整个app的全局类实例，所有的全局类实例都统一交给ApplicationComponent管理，并且它们的生命周期与app的生命周期一样。<br>每个页面对应自己的Component，页面Component管理着自己页面所依赖的所有类实例。<br>因为Component，Module，整个app的类实例结构变的很清晰。</li>
<li>解耦。<br>Module的构造函数也会发生变化，发生变化后，相应的new Module的类也发生变化，这就没有达到解耦的效果。首先解耦不是说让类之间或模块之间真的一点关系都没有了，解耦达到的目的是让一个类或一个模块对与自己有关联的类或模块的影响降到最低，不是说这种影响就完全没有了，这是不可能的。</li>
</ul>
<p>参考资料：<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html" target="_blank" rel="external">详解Dagger2</a><br><a href="http://www.jianshu.com/p/cd2c1c9f68d4" target="_blank" rel="external">dagger2让你爱不释手-基础依赖注入框架篇</a><br><a href="http://www.jianshu.com/p/1d42d2e6f4a5" target="_blank" rel="external">dagger2让你爱不释手-重点概念讲解、融合篇</a><br><a href="http://www.jianshu.com/p/65737ac39c44" target="_blank" rel="external">dagger2让你爱不释手-终结篇</a><br><a href="http://www.jianshu.com/p/a23c50cb4094" target="_blank" rel="external">从零开始的Android新项目4 - Dagger2篇</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dagger2是为Android和Java平台提供的一个完全静态的，在编译时进行依赖注入的框架。一开始使用的时候也不太明白依赖注入有什么好用的地方，可能是开发的项目比较小，体会不到Dagger2牛逼之处。后来才发现Dagger2真心牛逼。&lt;br&gt;我们在做项目时，经常需要在一个对象里去创建另一个对象的示例，这种行为是产生耦合的常见形式，对于一个大型项目来说，过多的相互依赖会导致代码难以维护，很容易就会碰到修改一个小需求需要大面积的修改各种代码。&lt;br&gt;我的理解是Dagger2主要作用有两点，一是依赖的类和提供依赖的类的实现方法分离，二是在Android中帮助我们实现对象生命周期管理。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android开发框架" scheme="http://yoursite.com/tags/Android%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Dagger2" scheme="http://yoursite.com/tags/Dagger2/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Realm</title>
    <link href="http://yoursite.com/2016/08/17/Android%E7%AC%94%E8%AE%B0-Realm/"/>
    <id>http://yoursite.com/2016/08/17/Android笔记-Realm/</id>
    <published>2016-08-17T01:42:26.000Z</published>
    <updated>2016-08-28T04:17:40.838Z</updated>
    
    <content type="html"><![CDATA[<p>在使用SQLite的时候总是要自己写一层接口出来方便使用，使用了Realm之后发现简单多了，并且据说在普通操作上，Realm的速度最快要达到原始的SQLite的10倍。<br>官方介绍：Realm，为移动设备而生，替代 SQLite 和 Core Data。为你省下数周的时间和数千行的代码，帮你创造出更棒的用户体验。<br>对于我这种数据库渣写SQL语句是很头疼的问题，简单的还好，复杂的真是要命。Realm的这种简单的流式API实在是太好用了。</p>
<a id="more"></a>
<p>Realm是一个可以替代SQLite以及ORM Libraries的轻量级数据库。相比SQLite，Realm更快并且具有很多现代数据库的特性，比如支持JSON，流式api，数据变更通知，以及加密支持，这些都为安卓开发者带来了方便。</p>
<h2 id="Realm类"><a href="#Realm类" class="headerlink" title="Realm类"></a>Realm类</h2><ul>
<li>Realm类可以对你的持久化对象进行存储和事务管理，可以用来创建RealmObjects实例。领域内的对象可以在任何时间查询和读取。</li>
<li>创建，修改和删除等操作必须被包含在一个完整的事务里面。</li>
<li>该事务确保多个实例（在多个线程）可以在一个一致的状态和保证事务在ACID前提下，访问相同的对象。</li>
<li>当一个Realm实例操作完成后，切记不要忘记调用close()方法。否则会导致本地资源无法释放，引起OOM。</li>
<li>Realm实例不能在不同的线程间访问操作。确切的说，你必须在每个要使用的线程上打开一个实例。每个线程都会使用引用计数来自动缓存Realm实例，所以只要引用计数不达到零，调用getInstance(RealmConfiguration)方法将会返回缓存的Realm实例，应该算是一个轻量级的操作。</li>
<li>对于UI线程来说，打开和关闭Realm实例，应当放在onCreate/onDestroy或者onStart/onStop方法中，在不同的线程间，Realm实例使用Handler机制来调整他的状态。也就是说，Realm实例在线程中，如果没有Looper，是不能收到更新通知的，除非手动调用waitForChange()方法。</li>
</ul>
<h2 id="数据库事务四大特性"><a href="#数据库事务四大特性" class="headerlink" title="数据库事务四大特性"></a>数据库事务四大特性</h2><p>数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分割的工作单位。<br>数据库事务的四大特性(简称ACID)是：</p>
<ol>
<li>原子性(Atomicity)<br>事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。<br>例如银行取款事务分为2个步骤(1)存折减款(2)提取现金。不可能存折减款，却没有提取现金。2个步骤必须同时完成或者都不完成。</li>
<li>一致性(Consistency)<br>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。<br>例如完整性约束a+b=10，一个事务改变了a，那么b也应随之改变。</li>
<li>分离性(亦称独立性Isolation)<br>分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。</li>
<li>持久性(Durability)<br>持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用起来也很方便，比如我们想要缓存用户的信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPo</span> <span class="keyword">extends</span> <span class="title">RealmObject</span> </span>&#123;</div><div class="line">    <span class="meta">@PrimaryKey</span></div><div class="line">    <span class="keyword">public</span> String id;</div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">    <span class="keyword">public</span> String headerUrl;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> updateTime;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这样就对应了一个表，其主键为id，另外有3列name, headerUrl, 以及updateTime。</p>
<p>如果想要查询，只需要：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UserPo user = getRealm().where(UserPo.class)</div><div class="line">    .equalTo(<span class="string">"id"</span>, userId)</div><div class="line">    .findFirst();</div></pre></td></tr></table></figure><br>如果要写入一条记录：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">User user = <span class="keyword">new</span> UserPo();</div><div class="line">user.setName(userInfoEntity.getNickName());</div><div class="line">user.setId(userInfoEntity.getUserId());</div><div class="line">user.setHeaderUrl(userInfoEntity.getHeaderImageUrl());</div><div class="line">user.setUpdateTime(System.currentTimeMillis());</div><div class="line"></div><div class="line">getRealm().beginTransaction();</div><div class="line">getRealm().copyToRealmOrUpdate(user);</div><div class="line">getRealm().commitTransaction();</div></pre></td></tr></table></figure><br>如果想要直接和Retrofit一起应用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 结合 Realm, Retrofit 和 RxJava (使用了Retrolambda以简化符号)的例子。</span></div><div class="line"><span class="comment">// 读取所有Person，然后与从GitHub获取的最新状态merge到一起</span></div><div class="line">Realm realm = Realm.getDefaultInstance();</div><div class="line">GitHubService api = retrofit.create(GitHubService.class);</div><div class="line">realm.where(Person.class).isNotNull(<span class="string">"username"</span>).findAllAsync().asObservable()</div><div class="line">    .filter(persons.isLoaded)</div><div class="line">    .flatMap(persons -&gt; Observable.from(persons))</div><div class="line">    .flatMap(person -&gt; api.user(person.getGithubUserName())</div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(user -&gt; showUser(user));</div></pre></td></tr></table></figure></p>
<h2 id="异步查询"><a href="#异步查询" class="headerlink" title="异步查询"></a>异步查询</h2><p>可以使用后台线程进行查询。</p>
<p>Realm 的大部分查询都非常快——快到可以使用在UI线程中而感觉不到延迟。但如果需要进行非常复杂的查询或者在大量数据中进行查询，那么使用后台线程进行查询将会是一个不错的主意。</p>
<h3 id="创建异步查询"><a href="#创建异步查询" class="headerlink" title="创建异步查询"></a>创建异步查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RealmResults&lt;User&gt; result = realm.where(User.class)</div><div class="line">                          .equalTo(<span class="string">"name"</span>, <span class="string">"John"</span>)</div><div class="line">                          .or()</div><div class="line">                          .equalTo(<span class="string">"name"</span>, <span class="string">"Peter"</span>)</div><div class="line">                          .findAllAsync();</div></pre></td></tr></table></figure>
<p>请注意，这里的调用并不会阻塞，而是立即返回一个 RealmResults<user>。这很类似于标准 Java 中 Future 的概念。查询将会在后台线程中被执行，当其完成时，之前返回的 RealmResults 实例会被更新。（这里异步查询要特别注意，它会有两次返回值，第一次是null，第二次才是结果）。</user></p>
<p>如果你希望当查询完成、RealmResults 被更新时获得通知，你可以注册一个 RealmChangeListener。这个监听器会在 RealmResults 被更新时被调用（通常是在事务被提交后）。(这才是正确的使用姿势)</p>
<h3 id="非-Looper-线程"><a href="#非-Looper-线程" class="headerlink" title="非 Looper 线程"></a>非 Looper 线程</h3><p>你可以在 Looper 线程中使用异步查询。异步查询需要使用 Handler 来传递查询结果。在没有 Looper 的线程中使用异步查询会导致 IllegalStateException 异常被抛出。</p>
<h2 id="Realms"><a href="#Realms" class="headerlink" title="Realms"></a>Realms</h2><p>Realm(s) 是我们对数据库的称谓：它包含多个不同的对象，并对应磁盘中的一个文件。</p>
<h3 id="默认的-Realm"><a href="#默认的-Realm" class="headerlink" title="默认的 Realm"></a>默认的 Realm</h3><p>我们总是通过Realm.getInstance(this)来访问我们已初始化的realm变量。该静态方法会为你的当前线程返回一个Realm实例，它对应了你Context.getFilesDir()目录中的default.realm文件。</p>
<p>该文件位于你应用的可写根目录中。默认情况下的Realm使用内部存储（internal storage)，你的应用并不需要取得任何读写权限。一般来说，这个文件位于/data/data/<packagename>/files/。</packagename></p>
<p>你可以通过realm.getPath()来获得该Realm的绝对路径。</p>
<p>请务必注意到Realm的实例是线程单例化的，也就是说，在同一个线程内多次调用静态方法获得针对同路径的Realm，会返回同一个Realm实例。</p>
<h3 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h3><p>如果 Realm 实例存在于一个带有 Looper 的线程，那么这个 Realm 实例即具有自动更新的功能。这意味这如果发生了 Realm 数据库的变化，那么该 Realm 实例会在下一个事件循环（event loop）中自动更新。这个便捷的功能使你不必花费太多的精力就能保证的UI与数据的实时同步。</p>
<p>如果 Realm 的实例所在线程没有绑定 Looper，那么该实例不会被更新直到你手动调用 waitForChange() 方法。请注意，不更新 Realm 以保持对旧数据的引用会造成而外的磁盘和内存开销。这也是为什么要在线程结束时调用 close() 关闭 Realm 实例的一个重要原因。</p>
<p>如果你想确定当前 Realm 实例是否有自动更新功能，可以通过调用 isAutoRefresh() 方法查询。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>其实对于跨线程使用 Realm，你需要知道的事情并不多。关键点是得益于对象和查询的即时更新特性，你不需要担心数据在多线程时的一致性和效率问题。</p>
<p>你可以实时在不同线程中读取和写入 Realm 对象，不用担心其它线程会对同一对象进行操作。你需要在改变对象时使用事务，在另一线程中指向同一对象的数据会被即时更新（更新会在下一次事件循环时进行）。</p>
<p>唯一局限是你不能随意跨线程传递 Realm 对象。如果你在另一线程使用同一对象，请在哪个线程使用查询重新获得该对象。请谨记所有的 Realm 对象都会在不同线程中保持更新——Realm 会在数据改变时通知你。</p>
<h3 id="跨线程使用-Realm"><a href="#跨线程使用-Realm" class="headerlink" title="跨线程使用 Realm"></a>跨线程使用 Realm</h3><p>Realm、RealmObject 和RealmResults 实例都不可以跨线程使用。但是你可以使用异步查询和异步事务来将部分操作放入后台线程进行，待完成时调用线程被通知以获取结果。</p>
<p>当你需要跨线程访问同一部分数据时，只需简单地在该线程重新获取一个 Realm 实例（例如：Realm.getInstance(RealmConfiguration config) 或是其他类似方法），然后通过这个 Realm 实例来查询获得你需要的数据。查询获得的对象会映射到 Realm 中的相同数据，由此方法获得对象在其线程中任何地方都可读写！</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>可以直接将 JSON 对象添加到 Realm 中，这些 JSON 对象可以是一个 String、一个 JSONObject 或者是一个 InputStream。Realm 会忽略 JSON 中存在但未定义在 Realm 模型类里的字段。单独对象可以通过 Realm.createObjectFromJson() 添加。对象列表可以通过 Realm.createAllFromJson() 添加。</p>
<h2 id="Intents"><a href="#Intents" class="headerlink" title="Intents"></a>Intents</h2><p>不可以直接通过 intent 传递 RealmObject，建议只传递 RealmObject 的标识符。在接受方（Activty、Service、IntentService、BroadcastReceiver 及其它）从 bundle 中解析出这个主键然后打开 Realm 查询得到这个 RealmObject。</p>
<h2 id="Realm-实例的生命周期"><a href="#Realm-实例的生命周期" class="headerlink" title="Realm 实例的生命周期"></a>Realm 实例的生命周期</h2><p>RealmObjects 和 RealmResults 在访问其引用数据时都是懒加载的。因为这个原因，请不要关闭你的 Realm 实例如果你仍然需要访问其中的 Realm 对象或者查询结果。为了避免不必要的 Realm 数据连接的打开和关闭，Realm 内部有一个基于引用计数的缓存。这表示在同一线程内调用 Realm.getDefaultInstance() 多次是基本没有开销的，并且底层资源会在所有实例都关闭的时候才被释放。</p>
<p>以 UI 线程举例，最简单安全的途径是，在你所有的 Activity 和 Fragment 初始化时取得 Realm 实例，并在它们销毁时关闭 Realm 实例。</p>
<p>参考资料：<br><a href="https://realm.io/cn/docs/java/latest/" target="_blank" rel="external">Realm Java</a><br><a href="http://www.jianshu.com/p/cd1684b58035" target="_blank" rel="external">Android数据库中的新王者realm</a><br><a href="http://www.jianshu.com/p/cd1ddff53472" target="_blank" rel="external">从零开始的Android新项目6 - Repository层(下) Realm、缓存、异常处理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用SQLite的时候总是要自己写一层接口出来方便使用，使用了Realm之后发现简单多了，并且据说在普通操作上，Realm的速度最快要达到原始的SQLite的10倍。&lt;br&gt;官方介绍：Realm，为移动设备而生，替代 SQLite 和 Core Data。为你省下数周的时间和数千行的代码，帮你创造出更棒的用户体验。&lt;br&gt;对于我这种数据库渣写SQL语句是很头疼的问题，简单的还好，复杂的真是要命。Realm的这种简单的流式API实在是太好用了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android开发框架" scheme="http://yoursite.com/tags/Android%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Reaml" scheme="http://yoursite.com/tags/Reaml/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Retrofit</title>
    <link href="http://yoursite.com/2016/08/15/Android%E7%AC%94%E8%AE%B0-Retrofit/"/>
    <id>http://yoursite.com/2016/08/15/Android笔记-Retrofit/</id>
    <published>2016-08-15T13:47:57.000Z</published>
    <updated>2016-08-28T04:35:15.058Z</updated>
    
    <content type="html"><![CDATA[<p>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是 Retrofit 来完成的。 Retrofit 2.0 开始内置 OkHttp ，前者专注于接口的封装，后者专注于网络请求的高效，二者分工协作。<br>网络请求框架开源的有很多，据说Retrofit性能最好，处理最快，出自开源狂魔Square公司，那我就直接拿来使用了。<br>我理解的Retrofit好处有两点，一是可以和RxJava联用， 二是通过注解的形式令 Http 请求的参数变得更加直接，而且类型安全。</p>
<a id="more"></a>
<p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。<br><a href="http://blog.igevin.info/posts/restful-architecture-in-general/" target="_blank" rel="external">RESTful 架构风格概述</a></p>
<p>我们的应用程序通过 Retrofit 请求网络，实际上是使用 Retrofit 接口层封装请求参数、Header、Url 等信息，之后由 OkHttp 完成后续的请求操作，在服务端返回数据之后， OkHttp 将原始的结果交给 Retrofit ，后者根据用户的需求对结果进行解析的过程。</p>
<h1 id="Retrofit-的基本用法"><a href="#Retrofit-的基本用法" class="headerlink" title="Retrofit 的基本用法"></a>Retrofit 的基本用法</h1><p>访问 GitHub 的 api，就定义一个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">    Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>其中，在发起请求时， {user} 会被替换为方法的第一个参数 user 。</p>
<p>构造 Retrofit：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">.baseUrl(<span class="string">"https://api.github.com/"</span>)</div><div class="line">.build();</div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure><br>发送请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</div></pre></td></tr></table></figure><br>repos 其实并不是真正的数据结果，它更像一条指令，你可以在合适的时机去执行它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步调用</span></div><div class="line">List&lt;Repo&gt; data=repos.execute();</div><div class="line"></div><div class="line"><span class="comment">//异步调用</span></div><div class="line">repos.enquene(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Reps&gt;&gt; response)</span></span>&#123;</div><div class="line">               List&lt;Reps&gt; data=response.body();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call,Throwable t)</span></span>&#123;</div><div class="line">               t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>  </p>
<h2 id="Url-配置"><a href="#Url-配置" class="headerlink" title="Url 配置"></a>Url 配置</h2><p>Retrofit 支持的协议包括 GET / POST / PUT / DELETE / HEAD / PATCH ，当然你也可以直接用 HTTP 来自定义请求。这些协议均以注解的形式进行配置。</p>
<h2 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h2><p>发请求时，需要传入参数， Retrofit 通过注解的形式令 Http 请求的参数变得更加直接，而且类型安全。</p>
<h2 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h2><p>Retrofit 允许我们自己定义入参和返回的类型，不过，如果这些类型比较特别，我们还需要准备相应的 Converter，也正是因为 Converter 的存在， Retrofit 在入参和返回类型上表现得非常灵活。</p>
<h1 id="Retrofit-原理"><a href="#Retrofit-原理" class="headerlink" title="Retrofit 原理"></a>Retrofit 原理</h1><h2 id="接口请求的处理"><a href="#接口请求的处理" class="headerlink" title="接口请求的处理"></a>接口请求的处理</h2><p>Retrofit 创建的一个代理对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">        eagerlyValidateMethods(service);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></div><div class="line">        <span class="keyword">throws</span> Throwable &#123;</div><div class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">                <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">                    <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">                    <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">                &#125;</div><div class="line">                ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">                OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">                <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>在我们调用 GitHubService.listRepos 时，实际上调用的是这里的 InvocationHandler.invoke 方法。</p>
<h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h2><p>Retrofit 为我们构造了一个 OkHttpCall ，实际上每一个 OkHttpCall 都对应于一个请求，它主要完成最基础的网络请求，而我们在接口的返回中看到的 Call 默认情况下就是 OkHttpCall 了，如果我们添加了自定义的 callAdapter ，那么它就会将 OkHttp 适配成我们需要的返回值，并返回给我们。</p>
<p>Call 的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;  </div><div class="line">    <span class="comment">//同步发起请求</span></div><div class="line">    <span class="function">Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;  </div><div class="line">    <span class="comment">//异步发起请求，结果通过回调返回</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;  </div><div class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">//返回原始请求</span></div><div class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>前面repos 其实就是一个 OkHttpCall 实例， execute 就是要发起网络请求。</p>
<p>OkHttpCall.execute：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">okhttp3.Call call;</div><div class="line"></div><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</div><div class="line">  executed = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</div><div class="line">      <span class="keyword">throw</span> (IOException) creationFailure;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">throw</span> (RuntimeException) creationFailure;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  call = rawCall;</div><div class="line">  <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      call = rawCall = createRawCall();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</div><div class="line">      creationFailure = e;</div><div class="line">      <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (canceled) &#123;</div><div class="line">  call.cancel();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> parseResponse(call.execute());</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>OkHttpCall 其实也是封装了 okhttp3.Call。<br>parseResponse 主要完成了由 okhttp3.Response 向 retrofit.Response 的转换，同时也处理了对原始返回的解析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    <span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ResponseBody rawBody = rawResponse.body();    </div><div class="line"></div><div class="line">    <span class="comment">//略掉一些代码</span></div><div class="line">    <span class="keyword">try</span> &#123;      </div><div class="line">    <span class="comment">//在这里完成了原始 Response 的解析，T 就是我们想要的结果，比如 GitHubService.listRepos 的 List&lt;Repo&gt;</span></div><div class="line">        T body = serviceMethod.toResponse(catchingBody);      </div><div class="line">        <span class="keyword">return</span> Response.success(body, rawResponse);</div><div class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;      </div><div class="line">        <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></div><div class="line">        <span class="comment">// a runtime exception.</span></div><div class="line">        catchingBody.throwIfCaught();      </div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="适配RxJava"><a href="#适配RxJava" class="headerlink" title="适配RxJava"></a>适配RxJava</h2><p>只需要提供一个 Adapter，将 OkHttpCall 转换为 Observable 即可。 Retrofit 的开发者们早就想到了这个问题，并且为我们提供了相应的 Adapter：RxJavaCallAdapterFactory<br>我们只需要在构造 Retrofit 时，添加它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div></pre></td></tr></table></figure><br>这样我们的接口就可以以 RxJava 的方式工作了。</p>
<p>同样，还可以添加Gson,将传回的Json格式数据直接转化成JavaBean的形式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addConverterFactory(GsonConverterFactory.create())</div></pre></td></tr></table></figure></p>
<p>参考资料：<br><a href="http://www.tuicool.com/articles/bIFvIfY" target="_blank" rel="external">深入浅出 Retrofit，这么牛逼的框架你们还不来看看？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。注意这里并没有说它是网络请求框架，主要原因在于网络请求的工作并不是 Retrofit 来完成的。 Retrofit 2.0 开始内置 OkHttp ，前者专注于接口的封装，后者专注于网络请求的高效，二者分工协作。&lt;br&gt;网络请求框架开源的有很多，据说Retrofit性能最好，处理最快，出自开源狂魔Square公司，那我就直接拿来使用了。&lt;br&gt;我理解的Retrofit好处有两点，一是可以和RxJava联用， 二是通过注解的形式令 Http 请求的参数变得更加直接，而且类型安全。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android开发框架" scheme="http://yoursite.com/tags/Android%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Retrofit" scheme="http://yoursite.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-RxJava</title>
    <link href="http://yoursite.com/2016/08/15/Android%E7%AC%94%E8%AE%B0-RxJava/"/>
    <id>http://yoursite.com/2016/08/15/Android笔记-RxJava/</id>
    <published>2016-08-15T12:20:05.000Z</published>
    <updated>2016-08-28T05:54:53.500Z</updated>
    
    <content type="html"><![CDATA[<p>RxJava算得上是我最喜欢的开源库了。以前在项目中使用异步是个很头疼的问题，来回回调，互相嵌套，往往让代码可读性变的很差。RxJava的出现算是解决了这个问题，一开始使用的时候还不觉得什么，用多了就发现这个开源库真心牛逼。它不仅仅是取代了AsyncTask,Handler等，而且还有一些实用的衍生产品。<br>Rx就是一种响应式编程,响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。<br>响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。<br>RxJava就是帮助我们在Android开发中实现响应式编程的框架，我的理解是它的好处有两点，一是响应式编程，帮我们将方法组合成链式；二是线程操作，简化异步事件的处理。</p>
<a id="more"></a>
<p><br></p>
<h1 id="RxJava是什么"><a href="#RxJava是什么" class="headerlink" title="RxJava是什么"></a>RxJava是什么</h1><p>RxJava就是一种用Java语言实现的响应式编程，来创建基于事件的异步程序。<br><br></p>
<h1 id="扩展的观察者模式"><a href="#扩展的观察者模式" class="headerlink" title="扩展的观察者模式"></a>扩展的观察者模式</h1><p>RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。</p>
<p>观察者（Observer）需要在被观察者(Observable)变化的一瞬间做出反应。<br>而两者通过注册（Register）或者订阅(Subscribe)的方式进行绑定。<br><br></p>
<h2 id="RxJava-的观察者模式"><a href="#RxJava-的观察者模式" class="headerlink" title="RxJava 的观察者模式"></a>RxJava 的观察者模式</h2><p>RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。</p>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。<br><br></p>
<h1 id="如何实现RxJava"><a href="#如何实现RxJava" class="headerlink" title="如何实现RxJava"></a>如何实现RxJava</h1><p><br></p>
<h2 id="创建Observer"><a href="#创建Observer" class="headerlink" title="创建Observer"></a>创建Observer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Observer</span></div><div class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"onNext ---&gt; "</span>, <span class="string">"Item: "</span> + s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"onCompleted ---&gt; "</span>, <span class="string">"完成"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"onError ---&gt; "</span>, e.toString());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>  
<p>在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。</p>
<p>Subscriber跟Observer接口几乎完全一样，只是多了两个方法：</p>
<ul>
<li>onStart(): 它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。</li>
<li>unsubscribe(): 用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</li>
</ul>
<p><br></p>
<h2 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h2><p>Observable是通过 create() 方法来创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Observable</span></div><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</div><div class="line">        subscriber.onNext(<span class="string">"World"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>  
<p><br></p>
<h2 id="订阅（Subscribe）"><a href="#订阅（Subscribe）" class="headerlink" title="订阅（Subscribe）"></a>订阅（Subscribe）</h2><p>在之前，我们创建了 Observable 和 Observer ，现在就需要用 subscribe() 方法来将它们连接起来，形成一种订阅关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//订阅</span></div><div class="line">observable.subscribe(observer);</div></pre></td></tr></table></figure>  
<p><br></p>
<h1 id="线程控制——Scheduler"><a href="#线程控制——Scheduler" class="headerlink" title="线程控制——Scheduler"></a>线程控制——Scheduler</h1><p>在RxJava中，Scheduler相当于线程控制器，可以通过它来指定每一段代码运行的线程。</p>
<ul>
<li>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。</li>
<li>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</li>
<li>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和newThread()差不多，区别在于io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下io()比newThread()更有效率。不要把计算工作放在io()中，可以避免创建不必要的线程。</li>
<li>Schedulers.computation(): 计算所使用的Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在computation()中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li>AndroidSchedulers.mainThread()，Android专用线程，指定操作在主线程运行。</li>
</ul>
<p>RxJava中提供了两个方法：subscribeOn() 和 observeOn() 切换线程，两者的不同点在于：</p>
<ul>
<li>subscribeOn(): 指定subscribe()订阅所发生的线程，即 call() 执行的线程。或者叫做事件产生的线程。</li>
<li>observeOn(): 指定Observer所运行在的线程，即onNext()执行的线程。或者叫做事件消费的线程。</li>
</ul>
<p><br></p>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>RxJava中有大量的操作符，比如创建操作符、变换操作符、过滤操作符等等。</p>
<p><br></p>
<h2 id="Observable-just"><a href="#Observable-just" class="headerlink" title="Observable.just()"></a>Observable.just()</h2><p>Just操作符是创建一个将参数依次发送出来的Observable。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/2046763-6c0e1adc83123ed6.png" alt="Image"><br><br></p>
<h2 id="Observable-from"><a href="#Observable-from" class="headerlink" title="Observable.from()"></a>Observable.from()</h2><p>将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/2046763-38826a6ab94d1cd9.png" alt="Image"><br><br></p>
<h2 id="Observable-create"><a href="#Observable-create" class="headerlink" title="Observable.create()"></a>Observable.create()</h2><p>create()方法创建了一个Observable，且在这个Observable中有个OnSubscribe。</p>
<p><br></p>
<h2 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe()"></a>subscribe()</h2><p>这个是将观察者（Observer）与被观察者(Observable)联系到一起的操作，也就是产生一种订阅(Subcribe)关系。</p>
<ul>
<li>首先创建过程也就是create()方法中创建了一个Observable，并有一个onSubscribe属性；</li>
<li>其次在订阅过程也就是subscribe()方法中，调用了create()方法中创建的Observable的onSubscribe属性的call方法；</li>
<li>最后这个call回调的就是代码中创建的Subscriber的onNext/onCompleted/onError方法。</li>
</ul>
<p><br></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map操作符对原始Observable发射的每一项数据应用一个你选择的函数，然后返回一个发射这些结果的Observable。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/map.png" alt="Image"><br>这是一对一的转换，就是一个单独的数据转成另一个单独的数据。<br><br></p>
<h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h2><p>FlatMap操作符使用一个指定的函数对原始Observable发射的每一项数据执行变换操作，这个函数返回一个本身也发射数据的Observable，然后FlatMap合并这些Observables发射的数据，最后将合并后的结果当做它自己的数据序列发射。<br><img src="http://ob5qdb9lc.bkt.clouddn.com/flatmap_2.png" alt="Image"><br>与Map相比较，FlatMap是能进行一对多的转换。</p>
<p><br></p>
<h1 id="FuncX与ActionX"><a href="#FuncX与ActionX" class="headerlink" title="FuncX与ActionX"></a>FuncX与ActionX</h1><p><br></p>
<h2 id="ActionX"><a href="#ActionX" class="headerlink" title="ActionX"></a>ActionX</h2><p>RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。</p>
<ul>
<li>Action0 就是把 onCompleted() 作为参数传入 subscribe() 。</li>
<li>Action1 就是把 onNext() 与 onError() 作为参数传入 subscribe() 。</li>
</ul>
<p><br></p>
<h2 id="FuncX"><a href="#FuncX" class="headerlink" title="FuncX"></a>FuncX</h2><p>FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。</p>
<p><br></p>
<h1 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe"></a>doOnSubscribe</h1><p>RxJava中给我们提供了另外一种操作符： doOnSubscribe ，这个操作符跟onStart方法一样，都是在 subscribe() 方法调用后且事件发送之前 执行，所以我们一样可以在这里面进行初始化的操作。而区别在于它可以指定线程。</p>
<p>默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。</p>
<p>如果在doOnSubscribe()之后指定了subscribeOn()，它决定了doOnSubscribe()在哪种线程中执行。</p>
<ul>
<li>doOnSubscribe()之前的subscribeOn()不会影响它。</li>
<li>doOnSubscribe()之后的subscribeOn()，且是最近的才会影响它。</li>
</ul>
<p><br></p>
<h1 id="doOnNext"><a href="#doOnNext" class="headerlink" title="doOnNext"></a>doOnNext</h1><p>RxJava中给我们提供了一个操作符： doOnNext() ，这个操作符允许我们在每次输出一个元素之前做一些其他的事情，比如提示啊保存啊之类的操作。</p>
<p><br></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上这些只是RxJava最最基本的用法，在我目前的项目中差不多就使用到了这些。其实RxJava包含了很多内容，有这数目众多的操作符和扩展类，官方给出了详细的文档<a href="http://rxjava.yuxingxin.com/" target="_blank" rel="external">RxJava Essentials 中文翻译版</a></p>
<p>参考资料：<br><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a><br><a href="http://www.jianshu.com/p/856297523728" target="_blank" rel="external">大话RxJava</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RxJava算得上是我最喜欢的开源库了。以前在项目中使用异步是个很头疼的问题，来回回调，互相嵌套，往往让代码可读性变的很差。RxJava的出现算是解决了这个问题，一开始使用的时候还不觉得什么，用多了就发现这个开源库真心牛逼。它不仅仅是取代了AsyncTask,Handler等，而且还有一些实用的衍生产品。&lt;br&gt;Rx就是一种响应式编程,响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。&lt;br&gt;响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。&lt;br&gt;RxJava就是帮助我们在Android开发中实现响应式编程的框架，我的理解是它的好处有两点，一是响应式编程，帮我们将方法组合成链式；二是线程操作，简化异步事件的处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android开发框架" scheme="http://yoursite.com/tags/Android%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Android性能优化</title>
    <link href="http://yoursite.com/2016/08/14/Android%E7%AC%94%E8%AE%B0-Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2016/08/14/Android笔记-Android性能优化/</id>
    <published>2016-08-14T13:50:08.000Z</published>
    <updated>2016-08-28T06:04:47.395Z</updated>
    
    <content type="html"><![CDATA[<p>看了很多有关Android性能优化的资料，基本上说的点都差不多。异步，内存泄漏，视图布局等等。<br>后来发现原来Google发布了<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">Android性能优化典范的专题</a>。国人也发布了相关的翻译文档，强，无敌！<br>性能优化是Android开发中一个很重要的课题，Android系统常年被诟病不如IOS好用，我觉得这并不是Android系统的问题，而是开发者开发的应用很多都没有优化，只是实现了其功能而已。(还有一点是好多应用强行占据系统资源，阿猫阿狗应用都自行启动，进程保活，简直无语)<br>Google大概是都看不下去，所以发布了这一专题，作为Android开发人员，在性能优化方面确实应该多长点心。</p>
<a id="more"></a>
<p><a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="external">Android性能优化典范 - 第1季</a><br><a href="http://hukai.me/android-performance-patterns-season-2/" target="_blank" rel="external">Android性能优化典范 - 第2季</a><br><a href="http://hukai.me/android-performance-patterns-season-3/" target="_blank" rel="external">Android性能优化典范 - 第3季</a><br><a href="http://hukai.me/android-performance-patterns-season-4/" target="_blank" rel="external">Android性能优化典范 - 第4季</a><br><a href="http://hukai.me/android-performance-patterns-season-5/" target="_blank" rel="external">Android性能优化典范 - 第5季</a></p>
<p>细化与补充：<br><a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇</a><br><a href="http://hukai.me/android-performance-compute/" target="_blank" rel="external">Android性能优化之运算篇</a><br><a href="http://hukai.me/android-performance-memory/" target="_blank" rel="external">Android性能优化之内存篇</a><br><a href="http://hukai.me/android-performance-battery/" target="_blank" rel="external">Android性能优化之电量篇</a><br><a href="http://hukai.me/android-performance-oom/" target="_blank" rel="external">Android内存优化之OOM篇</a></p>
<p>PS:今天Wings夺得TI6总冠军，看到他们从最初的小弟，勤学苦练，最终凭实力问鼎西雅图。原来现实生活中也存在着梦想照进现实的例子。所以呢？努力啊!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了很多有关Android性能优化的资料，基本上说的点都差不多。异步，内存泄漏，视图布局等等。&lt;br&gt;后来发现原来Google发布了&lt;a href=&quot;https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&quot;&gt;Android性能优化典范的专题&lt;/a&gt;。国人也发布了相关的翻译文档，强，无敌！&lt;br&gt;性能优化是Android开发中一个很重要的课题，Android系统常年被诟病不如IOS好用，我觉得这并不是Android系统的问题，而是开发者开发的应用很多都没有优化，只是实现了其功能而已。(还有一点是好多应用强行占据系统资源，阿猫阿狗应用都自行启动，进程保活，简直无语)&lt;br&gt;Google大概是都看不下去，所以发布了这一专题，作为Android开发人员，在性能优化方面确实应该多长点心。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android系统" scheme="http://yoursite.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Android性能优化" scheme="http://yoursite.com/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Android启动过程</title>
    <link href="http://yoursite.com/2016/08/14/Android%E7%AC%94%E8%AE%B0-Android%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/14/Android笔记-Android启动过程/</id>
    <published>2016-08-14T12:18:37.000Z</published>
    <updated>2016-08-28T06:21:19.367Z</updated>
    
    <content type="html"><![CDATA[<p>自买了《深入理解Android系统》，这本书就一直呆在角落里吃灰。大概是我对于创建那些花花绿绿的界面，实现有趣实用的功能比较感兴趣，对于这种上来就是一大页的源码，好多都还是c++的不太感兴趣，并且阅读了之后基本上留不下什么印象。<br>对于Android开发来说，要是别人问Android系统和应用是怎么启动的，那应该怎么解释。。。<br>参照书里的知识和网上的资料总结一下Android启动过程和Activity启动过程。</p>
<a id="more"></a>
<h1 id="Android启动过程"><a href="#Android启动过程" class="headerlink" title="Android启动过程"></a>Android启动过程</h1><p>当你按下电源开关后Android设备执行了以下步骤。</p>
<h2 id="启动电源以及系统启动"><a href="#启动电源以及系统启动" class="headerlink" title="启动电源以及系统启动"></a>启动电源以及系统启动</h2><p>当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。</p>
<h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2><p>引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。</p>
<p>设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qibootloader或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运营商加锁和限制的地方。</p>
<p>引导程序分两个阶段执行。</p>
<ol>
<li>检测外部的RAM以及加载对第二阶段有用的程序；</li>
<li>引导程序设置网络、内存等等。</li>
</ol>
<p>这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。</p>
<p>当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</p>
<h2 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h2><p>init是第一个进程，我们可以说它是root进程或者所有进程的父进程。</p>
<ul>
<li>初始化工作，主要包括建立/dev、/proc等目录，初始化属性，执行init.rc等初始化文件中的action等。</li>
<li>使用for循环建立子进程。</li>
</ul>
<p>在Linux系统中，init是一切应用空间进程的父进程。所以平常在Linux终端执行的命令，并建立进程，实际上都是在这个无限的for循环中完成的。</p>
<p>对于init.rc文件，Android中有特定的格式以及规则。在Android中，我们叫做Android初始化语言。<br>Android初始化语言由四大类型的声明组成，即Actions（动作）、Commands（命令）、Services（服务）、以及Options（选项）。当声明一个Service或者Action时，将隐式声明一个section，它之后跟随的Command或者Option都将属于这个section。另外，Action和Service不能重名，否则忽略为error。</p>
<ul>
<li>Action（动作）：就是在某种情况条件下触发一系列的命令，通常有一个trigger(触发器)。</li>
<li>Service（服务）：服务是init进程启动的程序、当服务退出时init进程会视情况重启服务。</li>
<li>Options（选项）：选项是对服务的描述。它们影响init进程如何以及何时启动服务。</li>
<li>Commands(命令)：动作的操作命令。</li>
</ul>
<p>在这个阶段你可以在设备的屏幕上看到“Android”logo了。</p>
<h2 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h2><p>在Android系统中有如下3个十分重要的进程系统</p>
<ol>
<li>Zygote进程：被称为“孵化”或“孕育”进程，功能和Linux的fork类似，用于“孕育”产生不同的子进程。</li>
<li>System进程：系统进程，整个Android Framework所在的进程，用于启动Android系统。其核心进程是system_server，其父进程就是Zygote。</li>
<li>应用程序进程：每个Android应用程序运行后都会拥有自己的进程。</li>
</ol>
<p>在Java中，我们知道不同的虚拟机实例会为不同的应用分配不同的内存。Android应用应该尽可能快地启动，但如果Android系统为每一个应用启动不同的Dalvik虚拟机实例，就会消耗大量的内存以及时间。</p>
<p>因此，为了克服这个问题，Android系统创造了”Zygote”。Zygote让Dalvik虚拟机共享代码、低内存占用以及最小的启动时间成为可能。</p>
<p>Zygote是一个虚拟器进程，正如我们在前一个步骤所说的在系统引导的时候启动。Zygote预加载以及初始化核心库类。通常，这些核心类一般是只读的，也是Android SDK或者核心框架的一部分。在Java虚拟机中，每一个实例都有它自己的核心库类文件和堆对象的拷贝。</p>
<p>在这个阶段，你可以看到启动动画。</p>
<h2 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h2><p>在Android系统中，System进程和系统服务有着重要的关系。几乎所有的Android核心服务都在这个进程中，例如ActivityManagerService、WindowManagerService等。System进程是系统进程，也就是整个Android Framework所在的进程，用于启动Android系统。其核心进程是system_server。</p>
<p>system_server是Android中Java层的两大支柱进程只有，另一个就是专门负责孵化Java进程的Zygote。如果这两大支柱其中之一崩溃了，都会导致Java层的崩溃。如果Java层崩溃了，则Linux系统中的进程init会重新启动system_server和Zygote，以重新建立Android的Java层。</p>
<p>完成了上面几步之后，运行环境请求Zygote运行系统服务。系统服务同时使用native以及java编写，系统服务可以认为是一个进程。同一个系统服务在Android SDK可以以System Services形式获得。系统服务包含了所有的System Services。</p>
<p>Zygote创建新的进程去启动系统服务。<br>核心服务：</p>
<ol>
<li>启动电源管理器；</li>
<li>创建Activity管理器；</li>
<li>启动电话注册；</li>
<li>启动包管理器；</li>
<li>设置Activity管理服务为系统进程；</li>
<li>启动上下文管理器；</li>
<li>启动系统Context Providers；</li>
<li>启动电池服务；</li>
<li>启动定时管理器；</li>
<li>启动传感服务；</li>
<li>启动窗口管理器；</li>
<li>启动蓝牙服务；</li>
<li>启动挂载服务。</li>
</ol>
<h2 id="引导完成"><a href="#引导完成" class="headerlink" title="引导完成"></a>引导完成</h2><p>一旦系统服务在内存中跑起来了，Android就完成了引导过程。在这个时候“ACTION_BOOT_COMPLETED”开机启动广播就会发出去。</p>
<h2 id="应用程序进程"><a href="#应用程序进程" class="headerlink" title="应用程序进程"></a>应用程序进程</h2><p>在Android系统中，启动应用程序过程中不但可以获得虚拟机实例外，还可以获得一个消息循环和一个Binder线程池。这样在应用程序中运行的组件，可以使用系统的消息处理机制和Binder通讯机制实现自己的业务逻辑。</p>
<p>当ActivityManagerService创建新进程来启动某个应用程序组件时，会调用ActivityManagerService中的函数startProcessLocked向Zygote发送创建应用程序的请求。</p>
<ul>
<li>在创建应用程序完毕之前，需要调用RuntimeInit的函数nativeZygoteInit()启动一个新的Binder线程池。</li>
<li>在创建新应用程序进程完毕之后，会调用函数invokeStaticMain()将类ActivityThread的函数main()设置为新程序的入口函数。当使用函数main()时，会在当前程序的进程中建立一个消息循环。</li>
</ul>
<h1 id="ART和Dalvik"><a href="#ART和Dalvik" class="headerlink" title="ART和Dalvik"></a>ART和Dalvik</h1><p>Android5.0开始，Android应用程序默认的运行环境为ART。ART机制与Dalvik不同，在Dalvik下，应用每次运行时，字节码都需要通过即时编译器转换为机器码，这会拖慢应用的运行效率。而在ART环境中，应用在第一次安装时，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫预编译(Ahead-Of-Time,AOT)。这样启动和执行都会变得更加快速。</p>
<p>ART虚拟机运行时和Dalvik虚拟机一样，实现了一套完全兼容Java虚拟机的接口。</p>
<p>不同点在于Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。这意味着Dalvik虚拟机包含一个解释器，用来执行dex字节码。当然也包含有即时编译器，用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。但是将dex字节码翻译成本地机器码是发生在应用程序运行过程中的，并且应用程序每一次重新运行时，都要重做这个翻译工程。</p>
<p>因此，即使采用了即时编译器，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。</p>
<p><br></p>
<h1 id="Activity启动过程"><a href="#Activity启动过程" class="headerlink" title="Activity启动过程"></a>Activity启动过程</h1><p><img src="http://ob5qdb9lc.bkt.clouddn.com/0_1313305334OkCc.gif" alt="Image"></p>
<p>在这个图中，ActivityManagerService和ActivityStack位于同一个进程中，而ApplicationThread和ActivityThread位于另一个进程中。</p>
<p>其中，ActivityManagerService是负责管理Activity的生命周期的，ActivityManagerService还借助ActivityStack是来把所有的Activity按照后进先出的顺序放在一个堆栈中；</p>
<p>对于每一个应用程序来说，都有一个ActivityThread来表示应用程序的主进程，而每一个ActivityThread都包含有一个ApplicationThread实例，它是一个Binder对象，负责和其它进程进行通信。</p>
<ol>
<li><p>无论是通过Launcher来启动Activity，还是通过Activity内部调用startActivity接口来启动新的Activity，都通过Binder进程间通信进入到ActivityManagerService进程中，并且调用ActivityManagerService.startActivity接口；</p>
</li>
<li><p>ActivityManagerService调用ActivityStack.startActivityMayWait来做准备要启动的Activity的相关信息；</p>
</li>
<li><p>ActivityStack通知ApplicationThread要进行Activity启动调度了，这里的ApplicationThread代表的是调用ActivityManagerService.startActivity接口的进程，对于通过点击应用程序图标的情景来说，这个进程就是Launcher了，而对于通过在Activity内部调用startActivity的情景来说，这个进程就是这个Activity所在的进程了；</p>
</li>
<li><p>ApplicationThread不执行真正的启动操作，它通过调用ActivityManagerService.activityPaused接口进入到ActivityManagerService进程中，看看是否需要创建新的进程来启动Activity；</p>
</li>
<li><p>对于通过点击应用程序图标来启动Activity的情景来说，ActivityManagerService在这一步中，会调用startProcessLocked来创建一个新的进程，而对于通过在Activity内部调用startActivity来启动新的Activity来说，这一步是不需要执行的，因为新的Activity就在原来的Activity所在的进程中进行启动；</p>
</li>
<li><p>ActivityManagerServic调用ApplicationThread.scheduleLaunchActivity接口，通知相应的进程执行启动Activity的操作；</p>
</li>
<li><p>ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread通过ClassLoader导入相应的Activity类，然后把它启动起来。</p>
</li>
</ol>
<p>参考资料：<br> 《深入理解Android系统》<br> <a href="http://blog.csdn.net/luoshengyang/article/details/6685853" target="_blank" rel="external">Android应用程序的Activity启动过程简要介绍和学习计划</a><br> <a href="http://blog.jobbole.com/67931/" target="_blank" rel="external">Android启动过程深入解析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自买了《深入理解Android系统》，这本书就一直呆在角落里吃灰。大概是我对于创建那些花花绿绿的界面，实现有趣实用的功能比较感兴趣，对于这种上来就是一大页的源码，好多都还是c++的不太感兴趣，并且阅读了之后基本上留不下什么印象。&lt;br&gt;对于Android开发来说，要是别人问Android系统和应用是怎么启动的，那应该怎么解释。。。&lt;br&gt;参照书里的知识和网上的资料总结一下Android启动过程和Activity启动过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android系统" scheme="http://yoursite.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-进程保活</title>
    <link href="http://yoursite.com/2016/08/12/Android%E7%AC%94%E8%AE%B0-%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB/"/>
    <id>http://yoursite.com/2016/08/12/Android笔记-进程保活/</id>
    <published>2016-08-12T12:49:12.000Z</published>
    <updated>2016-08-28T06:32:59.980Z</updated>
    
    <content type="html"><![CDATA[<p>使用Android系统不root是很麻烦的事情，root了更麻烦。<br>我们经常见到Android手机上的应用莫名其妙就自启了，有的还根本就杀不掉，一直在后台偷偷地搞些不可描述的小动作。<br>这就让人不能忍了，要搞定这些毒瘤应用首先要知道为什么它们能在Android系统中这样为所欲为，到底是Android系统的纵容，还是应用本身使用了特别的手段。<br>总结一下Android进程保活机制，看看手机里的应用怎么各凭本事，逃过系统的追杀。</p>
<a id="more"></a>
<h1 id="进程的优先级"><a href="#进程的优先级" class="headerlink" title="进程的优先级"></a>进程的优先级</h1><h2 id="前台进程-——-Foreground-process"><a href="#前台进程-——-Foreground-process" class="headerlink" title="前台进程 —— Foreground process"></a>前台进程 —— Foreground process</h2><p>用户当前操作所必需的进程。通常在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。</p>
<ul>
<li>拥有用户正在交互的 Activity（已调用 onResume()）</li>
<li>拥有某个 Service，后者绑定到用户正在交互的 Activity</li>
<li>拥有正在“前台”运行的 Service（服务已调用 startForeground()）</li>
<li>拥有正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</li>
<li>拥有正执行其 onReceive() 方法的 BroadcastReceiver</li>
</ul>
<h2 id="可见进程-——-Visible-process"><a href="#可见进程-——-Visible-process" class="headerlink" title="可见进程 —— Visible process"></a>可见进程 —— Visible process</h2><p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>
<ul>
<li>拥有不在前台、但仍对用户可见的 Activity（已调用 onPause()）</li>
<li>拥有绑定到可见（或前台）Activity 的 Service</li>
</ul>
<h2 id="服务进程-——-Service-process"><a href="#服务进程-——-Service-process" class="headerlink" title="服务进程 —— Service process"></a>服务进程 —— Service process</h2><p>尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>
<ul>
<li>正在运行 startService() 方法启动的服务，且不属于上述两个更高类别进程的进程。</li>
</ul>
<h2 id="后台进程-——-Background-process"><a href="#后台进程-——-Background-process" class="headerlink" title="后台进程 —— Background process"></a>后台进程 —— Background process</h2><p>后台进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU 列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。</p>
<ul>
<li>对用户不可见的 Activity 的进程（已调用 Activity的onStop() 方法）</li>
</ul>
<h2 id="空进程-——-Empty-process"><a href="#空进程-——-Empty-process" class="headerlink" title="空进程 —— Empty process"></a>空进程 —— Empty process</h2><p>保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
<ul>
<li>不含任何活动应用组件的进程</li>
</ul>
<h1 id="Android-进程回收策略"><a href="#Android-进程回收策略" class="headerlink" title="Android 进程回收策略"></a>Android 进程回收策略</h1><p>系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app。</p>
<p>这套杀进程回收内存的机制就叫 Low Memory Killer ，它是基于Linux内核的 OOM Killer（Out-Of-Memory killer）机制诞生。</p>
<p>oom_adj是linux内核分配给每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。</p>
<ul>
<li>进程的oom_adj越大，表示此进程优先级越低，越容易被杀回收；越小，表示进程优先级越高，越不容易被杀回收</li>
<li>普通app进程的oom_adj&gt;=0,系统进程的oom_adj才可能&lt;0</li>
</ul>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/2.jpg" alt="Image"><br>其中红色部分代表比较容易被杀死的 Android 进程（OOM_ADJ&gt;=4）,绿色部分表示不容易被杀死的 Android 进程，其他表示非 Android 进程（纯 Linux 进程）。在 Lowmemorykiller 回收内存时会根据进程的级别优先杀死 OOM_ADJ 比较大的进程，对于优先级相同的进程则进一步受到进程所占内存和进程存活时间的影响。</p>
<p>减少进程被杀死概率无非就是想办法提高进程优先级，减少进程在内存不足等情况下被杀死的概率。</p>
<h1 id="提升进程优先级的方案"><a href="#提升进程优先级的方案" class="headerlink" title="提升进程优先级的方案"></a>提升进程优先级的方案</h1><h2 id="利用-Activity-提升权限"><a href="#利用-Activity-提升权限" class="headerlink" title="利用 Activity 提升权限"></a>利用 Activity 提升权限</h2><p>监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。注意该 Activity 需设计成用户无感知。</p>
<p>通过该方案，可以使进程的优先级在屏幕锁屏时间由4提升为最高优先级1。</p>
<h2 id="利用-Service-提升权限"><a href="#利用-Service-提升权限" class="headerlink" title="利用 Service 提升权限"></a>利用 Service 提升权限</h2><p>Android 中 Service 的优先级为4，通过 setForeground 接口可以将后台 Service 设置为前台 Service，使进程的优先级由4提升为2，从而使进程的优先级仅仅低于用户当前正在交互的进程，与可见进程优先级一致，使进程被杀死的概率大大降低。</p>
<p>API&lt;18, setForeground 将后台 Service 设置为前台 Service 时，必须在系统的通知栏发送一条通知，也就是前台 Service 与一条可见的通知时绑定在一起的。可以直接 new Notification() 传入，这个通知是不可见的。</p>
<p>API&gt;=18, 通过实现一个内部 Service，在 LiveService 和其内部 Service 中同时发送具有相同 ID 的 Notification，然后将内部 Service 结束掉。随着内部 Service 的结束，Notification 将会消失，但系统优先级依然保持为2。</p>
<h2 id="进程死后拉活的方案"><a href="#进程死后拉活的方案" class="headerlink" title="进程死后拉活的方案"></a>进程死后拉活的方案</h2><h3 id="利用系统广播拉活"><a href="#利用系统广播拉活" class="headerlink" title="利用系统广播拉活"></a>利用系统广播拉活</h3><p>在发生特定系统事件时，系统会发出响应的广播，通过在 AndroidManifest 中“静态”注册对应的广播监听器，即可在发生响应事件时拉活。</p>
<p>缺点：</p>
<ol>
<li>广播接收器被管理软件、系统软件通过“自启管理”等功能禁用的场景无法接收到广播，从而无法自启。</li>
<li>系统广播事件不可控，只能保证发生事件时拉活进程，但无法保证进程挂掉后立即拉活。</li>
</ol>
<h3 id="利用第三方应用广播拉活"><a href="#利用第三方应用广播拉活" class="headerlink" title="利用第三方应用广播拉活"></a>利用第三方应用广播拉活</h3><p>该方案总的设计思想与接收系统广播类似，不同的是该方案为接收第三方 Top 应用广播。</p>
<p>通过反编译第三方 Top 应用，如：手机QQ、微信、支付宝、UC浏览器等，以及友盟、信鸽、个推等 SDK，找出它们外发的广播，在应用中进行监听，这样当这些应用发出广播时，就会将我们的应用拉活。</p>
<p>限制：</p>
<ol>
<li>反编译分析过的第三方应用的多少</li>
<li>第三方应用的广播属于应用私有，当前版本中有效的广播，在后续版本随时就可能被移除或被改为不外发。</li>
</ol>
<h3 id="利用系统Service机制拉活"><a href="#利用系统Service机制拉活" class="headerlink" title="利用系统Service机制拉活"></a>利用系统Service机制拉活</h3><p>将 Service 设置为 START_STICKY，利用系统机制在 Service 挂掉后自动拉活。</p>
<p>如下两种情况无法拉活：</p>
<ol>
<li>Service 第一次被异常杀死后会在5秒内重启，第二次被杀死会在10秒内重启，第三次会在20秒内重启，一旦在短时间内 Service 被杀死达到5次，则系统不再拉起。</li>
<li>进程被取得 Root 权限的管理工具或系统工具通过 forestop 停止掉，无法重启。</li>
</ol>
<h1 id="常见保活手段"><a href="#常见保活手段" class="headerlink" title="常见保活手段"></a>常见保活手段</h1><p>当前业界的Android进程保活手段主要分为 黑、白、灰 三种，其大致的实现思路如下：</p>
<ul>
<li>黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）</li>
<li>白色保活：启动前台Service</li>
<li>灰色保活：利用系统的漏洞启动前台Service</li>
</ul>
<h1 id="黑色保活"><a href="#黑色保活" class="headerlink" title="黑色保活"></a>黑色保活</h1><p>所谓黑色保活，就是利用不同的app进程使用广播来进行相互唤醒。举个3个比较常见的场景：</p>
<ul>
<li>场景1：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app。</li>
<li>场景2：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。由此发散开去，就会直接触发了下面的 场景三。</li>
<li>场景3：假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。</li>
</ul>
<h1 id="白色保活"><a href="#白色保活" class="headerlink" title="白色保活"></a>白色保活</h1><p>白色保活手段非常简单，就是调用系统api启动一个前台的Service进程，这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，哪怕当前的app退到了后台。如：酷狗音乐。</p>
<h1 id="灰色保活"><a href="#灰色保活" class="headerlink" title="灰色保活"></a>灰色保活</h1><p>灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的Service进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。那么如何利用系统的漏洞呢，大致的实现思路和代码如下：</p>
<ul>
<li>思路一：API &lt; 18，启动前台Service时直接传入new Notification()；</li>
<li>思路二：API &gt;= 18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理；</li>
</ul>
<p>参考资料：<br><a href="http://dev.qq.com/topic/57ac4a0ea374c75371c08ce8" target="_blank" rel="external">Android进程保活招式大全</a><br><a href="http://www.jianshu.com/p/63aafe3c12af" target="_blank" rel="external">关于 Android 进程保活，你所需要知道的一切</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Android系统不root是很麻烦的事情，root了更麻烦。&lt;br&gt;我们经常见到Android手机上的应用莫名其妙就自启了，有的还根本就杀不掉，一直在后台偷偷地搞些不可描述的小动作。&lt;br&gt;这就让人不能忍了，要搞定这些毒瘤应用首先要知道为什么它们能在Android系统中这样为所欲为，到底是Android系统的纵容，还是应用本身使用了特别的手段。&lt;br&gt;总结一下Android进程保活机制，看看手机里的应用怎么各凭本事，逃过系统的追杀。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android进程保活" scheme="http://yoursite.com/tags/Android%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-内存泄漏</title>
    <link href="http://yoursite.com/2016/08/12/Android%E7%AC%94%E8%AE%B0-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2016/08/12/Android笔记-内存泄漏/</id>
    <published>2016-08-12T11:56:40.000Z</published>
    <updated>2016-08-28T06:49:56.780Z</updated>
    
    <content type="html"><![CDATA[<p>Android是基于Java开发的，使用的虚拟机跟Java虚拟机也差不多。Java开发中遇到的问题Android开发中也经常遇到。其中典型就是内存泄漏问题。<br>内存泄漏问题多了就会出现OOM，在开发过程中应该时刻注意所写的代码是否会导致内存泄漏。<br>仅仅依靠开发时的自觉还是不够的，所幸还有一些工具能帮助我们发现内存泄漏。<br>总结一下如何避免内存：一是了解常见内存泄漏的问题，开发过程中避免。二是使用工具找出出现内存泄漏的代码然后修改。</p>
<a id="more"></a>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>Java是垃圾回收语言的一种，其优点是开发者无需特意管理内存分配，降低了应用由于局部故障(segmentation fault)导致崩溃，同时防止未释放的内存把堆栈(heap)挤爆的可能，所以写出来的代码更为安全。</p>
<p>不幸的是，在Java中仍存在很多容易导致内存泄漏的逻辑可能(logical leak)。如果不小心，你的Android应用很容易浪费掉未释放的内存，最终导致内存用光的错误抛出(out-of-memory，OOM)。</p>
<p>一般内存泄漏(traditional memory leak)的原因是：当该对象的所有引用都已经释放了，对象仍未被释放。</p>
<p>逻辑内存泄漏(logical memory leak)的原因是：当应用不再需要这个对象，当仍未释放该对象的所有引用。</p>
<p>如果持有对象的强引用，垃圾回收器是无法在内存中回收这个对象。</p>
<h1 id="Android内存泄漏"><a href="#Android内存泄漏" class="headerlink" title="Android内存泄漏"></a>Android内存泄漏</h1><p>在Android开发中，最容易引发的内存泄漏问题的是Context。比如Activity的Context，就包含大量的内存引用，例如View Hierarchies和其他资源。一旦泄漏了Context，也意味泄漏它指向的所有对象。Android机器内存有限，太多的内存泄漏容易导致OOM。</p>
<p>检测逻辑内存泄漏需要主观判断，特别是对象的生命周期并不清晰。幸运的是，Activity有着明确的生命周期，很容易发现泄漏的原因。Activity.onDestroy()被视为Activity生命的结束，程序上来看，它应该被销毁了，或者Android系统需要回收这些内存。</p>
<p>如果这个方法执行完，在堆栈中仍存在持有该Activity的强引用，垃圾回收器就无法把它标记成已回收的内存，而我们本来目的就是要回收它！</p>
<p>结果就是Activity存活在它的生命周期之外。</p>
<p>Activity是重量级对象，应该让Android系统来处理它。然而，逻辑内存泄漏总是在不经意间发生。在Android中，导致潜在内存泄漏的陷阱不外乎两种：</p>
<ul>
<li>全局进程(process-global)的static变量。这个无视应用的状态，持有Activity的强引用的怪物。</li>
<li>活在Activity生命周期之外的线程。没有清空对Activity的强引用。</li>
</ul>
<h2 id="Static-Activities"><a href="#Static-Activities" class="headerlink" title="Static Activities"></a>Static Activities</h2><p>在类中定义了静态Activity变量，把当前运行的Activity实例赋值于这个静态变量。</p>
<p>如果这个静态变量在Activity生命周期结束后没有清空，就导致内存泄漏。因为static变量是贯穿这个应用的生命周期的，所以被泄漏的Activity就会一直存在于应用的进程中，不会被垃圾回收器回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Activity activity;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStaticActivity</span><span class="params">()</span> </span>&#123;</div><div class="line">    activity = <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">View saButton = findViewById(R.id.sa_button);</div><div class="line">saButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        setStaticActivity();</div><div class="line">        nextActivity();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Static-Views"><a href="#Static-Views" class="headerlink" title="Static Views"></a>Static Views</h2><p>类似的情况会发生在单例模式中，如果Activity经常被用到，那么在内存中保存一个实例是很实用的。正如之前所述，强制延长Activity的生命周期是相当危险而且不必要的，无论如何都不能这样做。</p>
<p>特殊情况：如果一个View初始化耗费大量资源，而且在一个Activity生命周期内保持不变，那可以把它变成static，加载到视图树上(View Hierachy)，像这样，当Activity被销毁时，应当释放资源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> view;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStaticView</span><span class="params">()</span> </span>&#123;</div><div class="line">    view = findViewById(R.id.sv_button);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View svButton = findViewById(R.id.sv_button);</div><div class="line">svButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">      setStaticView();</div><div class="line">      nextActivity();</div><div class="line"> &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>  </p>
<h2 id="Inner-Classes"><a href="#Inner-Classes" class="headerlink" title="Inner Classes"></a>Inner Classes</h2><p>假设Activity中有个内部类，这样做可以提高可读性和封装性。将如我们创建一个内部类，而且持有一个静态变量的引用，那内存泄漏就离你不远了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object inner;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createInnerClass</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    inner = <span class="keyword">new</span> InnerClass();</div><div class="line">&#125;</div><div class="line"></div><div class="line">View icButton = findViewById(R.id.ic_button);</div><div class="line">icButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">     createInnerClass();</div><div class="line">     nextActivity();</div><div class="line"> &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><br>内部类的优势之一就是可以访问外部类，不幸的是，导致内存泄漏的原因，就是内部类持有外部类实例的强引用。</p>
<h2 id="Anonymous-Classes"><a href="#Anonymous-Classes" class="headerlink" title="Anonymous Classes"></a>Anonymous Classes</h2><p>相似地，匿名类也维护了外部类的引用。所以内存泄漏很容易发生，当你在Activity中定义了匿名的AsyncTsk。当异步任务在后台执行耗时任务期间，Activity不幸被销毁了，这个被AsyncTask持有的Activity实例就不会被垃圾回收器回收，直到异步任务结束。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">startAsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="keyword">new</span> AsyncTask&lt;Void, Void, Void&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line">      &#125;</div><div class="line"> &#125;.execute();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">setContentView(R.layout.activity_main);</div><div class="line">View aicButton = findViewById(R.id.at_button);</div><div class="line">aicButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">      startAsyncTask();</div><div class="line">      nextActivity();</div><div class="line"> &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>  </p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>同样道理，定义匿名的Runnable，用匿名类Handler执行。Runnable内部类会持有外部类的隐式引用，被传递到Handler的消息队列MessageQueue中，在Message消息没有被处理之前，Activity实例不会被销毁了，于是导致内存泄漏。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handleMessage(message);</div><div class="line">    &#125;</div><div class="line">&#125;.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;, Long.MAX_VALUE &gt;&gt; <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View hButton = findViewById(R.id.h_button);</div><div class="line">hButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">       createHandler();</div><div class="line">       nextActivity();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>  </p>
<h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><p>我们再次通过Thread和TimerTask来展现内存泄漏。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spawnThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">View tButton = findViewById(R.id.t_button);</div><div class="line">tButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">      spawnThread();</div><div class="line">      nextActivity();</div><div class="line"> &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>   </p>
<h2 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h2><p>只要是匿名类的实例，不管是不是在工作线程，都会持有Activity的引用，导致内存泄漏。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTimer</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;, Long.MAX_VALUE &gt;&gt; <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View ttButton = findViewById(R.id.tt_button);</div><div class="line">ttButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        scheduleTimer();</div><div class="line">        nextActivity();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Sensor-Manager"><a href="#Sensor-Manager" class="headerlink" title="Sensor Manager"></a>Sensor Manager</h2><p>通过Context.getSystemService(int name)可以获取系统服务。这些服务工作在各自的进程中，帮助应用处理后台任务，处理硬件交互。如果需要使用这些服务，可以注册监听器，这会导致服务持有了Context的引用，如果在Activity销毁的时候没有注销这些监听器，会导致内存泄漏。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">()</span> </span>&#123;</div><div class="line">   SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);</div><div class="line">   Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);</div><div class="line">   sensorManager.registerListener(<span class="keyword">this</span>, sensor, SensorManager.SENSOR_DELAY_FASTEST);</div><div class="line">&#125;</div><div class="line"></div><div class="line">View smButton = findViewById(R.id.sm_button);</div><div class="line">smButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        registerListener();</div><div class="line">        nextActivity();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="内存泄漏检测工具"><a href="#内存泄漏检测工具" class="headerlink" title="内存泄漏检测工具"></a>内存泄漏检测工具</h1><h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p>LeakCanary 是square团队开源的检测内存泄露的开源类库。你可以在 debug 包种轻松检测内存泄露。</p>
<p>工作机制：</p>
<ul>
<li>RefWatcher.watch() 创建一个 KeyedWeakReference 到要被监控的对象。</li>
<li>然后在后台线程检查引用是否被清除，如果没有，调用GC。</li>
<li>如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。</li>
<li>在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用<a href="https://github.com/square/haha" target="_blank" rel="external">HAHA</a> 解析这个文件。</li>
<li>得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄露。</li>
<li>HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄露。如果是的话，建立导致泄露的引用链。</li>
<li>引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。</li>
</ul>
<p>参考资料：<br><a href="http://blog.nimbledroid.com/2016/05/23/memory-leaks.html" target="_blank" rel="external">Eight Ways Your Android App Can Leak Memory</a><br><a href="http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="external">LeakCanary 中文使用说明</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android是基于Java开发的，使用的虚拟机跟Java虚拟机也差不多。Java开发中遇到的问题Android开发中也经常遇到。其中典型就是内存泄漏问题。&lt;br&gt;内存泄漏问题多了就会出现OOM，在开发过程中应该时刻注意所写的代码是否会导致内存泄漏。&lt;br&gt;仅仅依靠开发时的自觉还是不够的，所幸还有一些工具能帮助我们发现内存泄漏。&lt;br&gt;总结一下如何避免内存：一是了解常见内存泄漏的问题，开发过程中避免。二是使用工具找出出现内存泄漏的代码然后修改。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android内存泄漏" scheme="http://yoursite.com/tags/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Android多线程</title>
    <link href="http://yoursite.com/2016/08/12/Android%E7%AC%94%E8%AE%B0-Android%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/12/Android笔记-Android多线程/</id>
    <published>2016-08-12T10:40:16.000Z</published>
    <updated>2016-08-28T07:07:45.435Z</updated>
    
    <content type="html"><![CDATA[<p>Android系统机制要求我们在开发过程中耗时的操作不能放在主线程里执行，不然就分分钟卡顿给你看。Android系统也提供了工具类来帮助我们实现多线程。<br>多线程意味着并发，意味着异步，就像在Dota里面玩地卜师一样，需要多线操作，难度就自然很大。<br>总结一下Android系统提供给我们多线程操作的法门，以及为什么我们要使用多线程。</p>
<a id="more"></a>
<h1 id="Android多线程"><a href="#Android多线程" class="headerlink" title="Android多线程"></a>Android多线程</h1><p>众所周知，Android 程序的大多数代码操作都必须执行在主线程，例如系统事件(例如设备屏幕发生旋转)，输入事件(例如用户点击滑动等)，程序回调服务，UI绘制以及闹钟事件等等。那么我们在上述事件或者方法中插入的代码也将执行在主线程。</p>
<p>一旦我们在主线程里面添加了操作复杂的代码，这些代码就很可能阻碍主线程去响应点击/滑动事件，阻碍主线程的 UI 绘制等等。我们知道，为了让屏幕的刷新帧率达到 60fps，我们需要确保 16ms 内完成单次刷新的操作。</p>
<p>一旦我们在主线程里面执行的任务过于繁重就可能导致接收到刷新信号的时候因为资源被占用而无法完成这次刷新操作，这样就会产生掉帧的现象，刷新帧率自然也就跟着下降了。</p>
<p>为了避免上面提到的掉帧问题，我们需要使用多线程的技术方案，把那些操作复杂的任务移动到其他线程当中执行，这样就不容易阻塞主线程的操作，也就减小了出现掉帧的可能性。</p>
<p>Android 系统为我们提供了若干组工具类来帮助解决这个问题。</p>
<ul>
<li>AsyncTask: 为 UI 线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</li>
<li>HandlerThread: 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</li>
<li>ThreadPool: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</li>
<li>IntentService: 适合于执行由 UI 触发的后台 Service任务，并可以把后台任务执行的情况通过一定的机制反馈给 UI。</li>
</ul>
<p>通常来说，一个线程需要经历三个生命阶段：开始，执行，结束。线程会在任务执行完毕之后结束，那么为了确保线程的存活，我们会在执行阶段给线程赋予不同的任务，然后在里面添加退出的条件从而确保任务能够执行完毕后退出。</p>
<p>在很多时候，线程不仅仅是线性执行一系列的任务就结束那么简单的，我们会需要增加一个任务队列，让线程不断的从任务队列中获取任务去进行执行，另外我们还可能在线程执行的任务过程中与其他的线程进行协作。如果这些细节都交给我们自己来处理，这将会是件极其繁琐又容易出错的事情。</p>
<p>Android 系统为我们提供了 Looper，Handler，MessageQueue 来帮助实现上面的线程任务模型(Handler机制)。</p>
<p><br></p>
<h1 id="多线程与内存"><a href="#多线程与内存" class="headerlink" title="多线程与内存"></a>多线程与内存</h1><p>增加并发的线程数会导致内存消耗的增加，平衡好这两者的关系是非常重要的。我们知道，多线程并发访问同一块内存区域有可能带来很多问题，例如读写的权限争夺问题，ABA问题等等。为了解决这些问题，我们会需要引入锁的概念。</p>
<p>在 Android 系统中也无法避免因为多线程的引入而导致出现诸如上文提到的种种问题。Android UI 对象的创建，更新，销毁等等操作都默认是执行在主线程，但是如果我们在非主线程对UI对象进行操作，程序将可能出现异常甚至是崩溃。</p>
<p>另外，在非 UI 线程中直接持有 UI 对象的引用也很可能出现问题。例如Work线程中持有某个 UI 对象的引用，在 Work 线程执行完毕之前，UI 对象在主线程中被从 ViewHierarchy 中移除了，这个时候 UI 对象的任何属性都已经不再可用了，另外对这个 UI 对象的更新操作也都没有任何意义了，因为它已经从 ViewHierarchy 中被移除，不再绘制到画面上了。</p>
<p>不仅如此，View 对象本身对所属的 Activity 是有引用关系的，如果工作线程持续保有 View 的引用，这就可能导致 Activity无法完全释放。除了直接显式的引用关系可能导致内存泄露之外，我们还需要特别留意隐式的引用关系也可能导致泄露。</p>
<p>为了解决上面的问题，我们需要谨记的原则就是：不要在任何非 UI 线程里面去持有 UI 对象的引用。系统为了确保所有的 UI 对象都只会被 UI 线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当 Activity 被销毁的时候，由该 Activity 所触发的非 UI 线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止 UI 对象被错误的使用。</p>
<p><br></p>
<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><ul>
<li>Android系统基于精简过后的linux内核，其线程的调度受时间片轮转和优先级控制等诸多因素影响。</li>
<li>Linux系统的调度器在分配time slice的时候，采用的CFS（completely fair scheduler）策略。这种策略不但会参考单个线程的优先级，还会追踪每个线程已经获取到的time slice数量，如果高优先级的线程已经执行了很长时间，但低优先级的线程一直在等待，后续系统会保证低优先级的线程也能获取更多的CPU时间。显然使用这种调度策略的话，优先级高的线程并不一定能在争取time slice上有绝对的优势，所以Android系统在线程调度上使用了cgroups的概念，cgroups能更好的凸显某些线程的重要性，使得优先级更高的线程明确的获取到更多的time slice。</li>
<li>Android将线程分为多个group，其中两类group尤其重要。一类是default group，UI线程属于这一类。另一类是background group，工作线程应该归属到这一类。background group当中所有的线程加起来总共也只能分配到5～10%的time slice，剩下的全部分配给default group，这样设计显然能保证UI线程绘制UI的流畅性。</li>
</ul>
<p><br></p>
<h1 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h1><p>一个典型的AsyncTask实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doInBackground</span><span class="params">(Object[] params)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPreExecute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPostExecute(o);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>和使用Thread()不同的是，多了几处API回调来严格规范工作线程与UI线程之间的交互。我们大部分的业务场景几乎都符合这种规范，比如去磁盘读取图片，缩放处理需要在工作线程执行，最后绘制到ImageView控件需要切换到UI线程。</p>
<p>举个例子，常遇到的一个典型的使用场景：用户切换到某个界面，触发了界面上的图片的加载操作，因为图片的加载相对来说耗时比较长，我们需要在子线程中处理图片的加载，当图片在子线程中处理完成之后，再把处理好的图片返回给主线程，交给 UI 更新到画面上。</p>
<p>AsyncTask 的出现就是为了快速的实现上面的使用场景，AsyncTask 把在主线程里面的准备工作放到 onPreExecute()方法里面进行执行，doInBackground()方法执行在工作线程中，用来处理那些繁重的任务，一旦任务执行完毕，就会调用 onPostExecute()方法返回到主线程。</p>
<p>AsyncTask 的内部实现主要就是封装了一个可以串行执行任务的 Executor 以及处理线程间消息传递的 Handler，极大的简化了异步任务的处理。</p>
<p>使用 AsyncTask 需要注意的问题有哪些呢?请关注以下几点：</p>
<ul>
<li><p>首先，默认情况下，所有的 AsyncTask 任务都是被线性调度执行的，他们处在同一个任务队列当中，按顺序逐个执行。假设你按照顺序启动20个 AsyncTask，一旦其中的某个 AsyncTask 执行时间过长，队列中的其他剩余 AsyncTask 都处于阻塞状态，必须等到该任务执行完毕之后才能够有机会执行下一个任务。</p>
<p>为了解决上面提到的线性队列等待的问题，我们可以使用 AsyncTask.executeOnExecutor()强制指定 AsyncTask 使用线程池并发调度任务。</p>
</li>
</ul>
<ul>
<li><p>其次，如何才能够真正的取消一个 AsyncTask 的执行呢?我们知道 AsyncTaks 有提供 cancel()的方法，但是这个方法实际上做了什么事情呢?线程本身并不具备中止正在执行的代码的能力，为了能够让一个线程更早的被销毁，我们需要在 doInBackground()的代码中不断的添加程序是否被中止的判断逻辑。<br>一旦任务被成功中止，AsyncTask 就不会继续调用 onPostExecute()，而是通过调用 onCancelled()的回调方法反馈任务执行取消的结果。</p>
</li>
<li><p>最后，使用 AsyncTask 很容易导致内存泄漏，一旦把 AsyncTask 写成 Activity 的内部类的形式就很容易因为 AsyncTask 生命周期的不确定而导致 Activity 发生泄漏。</p>
</li>
</ul>
<p><br></p>
<h1 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h1><p>在需要对多任务做更精细控制，线程切换更频繁的场景之下，Thread()和AsyncTask都会显得力不从心。HandlerThread却能胜任这些需求甚至更多。</p>
<p>HandlerThread将Handler，Thread，Looper，MessageQueue几个概念相结合。Handler是线程对外的接口，所有新的message或者runnable都通过handler post到工作线程。Looper在MessageQueue取到新的任务就切换到工作线程去执行。不同的post方法可以让我们对任务做精细的控制，什么时候执行，执行的顺序都可以控制。HandlerThread最大的优势在于引入MessageQueue概念，可以进行多任务队列管理。</p>
<p>HandlerThread背后只有一个线程，所以任务是串行执行的。串行相对于并行来说更安全，各任务之间不会存在多线程安全问题。</p>
<p>HandlerThread所产生的线程会一直存活，Looper会在该线程中持续的检查MessageQueue。这一点和Thread()，AsyncTask都不同，thread实例的重用可以避免线程相关的对象的频繁重建和销毁。</p>
<p>另外很重要的一点是，一旦我们使用了 HandlerThread，需要特别注意给 HandlerThread 设置不同的线程优先级，CPU 会根据设置的不同线程优先级对所有的线程进行调度优化。</p>
<p><br></p>
<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>Thread(),AsyncTask适合处理单个任务的场景，HandlerThread适合串行处理多任务的场景。当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择。</p>
<p>使用线程池需要特别注意同时并发线程数量的控制，理论上来说，我们可以设置任意你想要的并发数量，但是这样做非常的不好。因为 CPU 只能同时执行固定数量的线程数，一旦同时并发的线程数量超过 CPU 能够同时执行的阈值，CPU 就需要花费精力来判断到底哪些线程的优先级比较高，需要在不同的线程之间进行调度切换。</p>
<p>一旦同时并发的线程数量达到一定的量级，这个时候 CPU 在不同线程之间进行调度的时间就可能过长，反而导致性能严重下降。另外需要关注的一点是，每开一个新的线程，都会耗费至少 64K+ 的内存。为了能够方便的对线程数量进行控制，ThreadPoolExecutor 为我们提供了初始化的并发线程数量，以及最大的并发数量进行设置。</p>
<p>另外需要关注的一个问题是：Runtime.getRuntime().availableProcesser()方法并不可靠，他返回的值并不是真实的 CPU 核心数，因为 CPU 会在某些情况下选择对部分核心进行睡眠处理，在这种情况下，返回的数量就只能是激活的 CPU 核心数。</p>
<p><br></p>
<h1 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h1><p>IntentService 继承自普通 Service 同时又在内部创建了一个 HandlerThread，在 onHandlerIntent()的回调里面处理扔到 IntentService 的任务。所以 IntentService 就不仅仅具备了异步线程的特性，还同时保留了 Service 不受主页面生命周期影响的特点。</p>
<p>我们可以在 IntentService 里面通过设置闹钟间隔性的触发异步任务，例如刷新数据，更新缓存的图片或者是分析用户操作行为等等，当然处理这些任务需要小心谨慎。</p>
<p>使用 IntentService 需要特别留意以下几点：</p>
<ul>
<li>首先，因为 IntentService 内置的是 HandlerThread 作为异步线程，所以每一个交给 IntentService 的任务都将以队列的方式逐个被执行到，一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。</li>
<li>其次，通常使用到 IntentService 的时候，我们会结合使用 BroadcastReceiver 把工作线程的任务执行结果返回给主 UI 线程。使用广播容易引起性能问题，我们可以使用 LocalBroadcastManager 来发送只在程序内部传递的广播，从而提升广播的性能。我们也可以使用 runOnUiThread() 快速回调到主 UI 线程。</li>
<li>最后，包含正在运行的 IntentService 的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li>
</ul>
<p><br></p>
<h1 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h1><p>Activity 有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在 Activity 不停的创建与销毁的过程当中，很有可能因为工作线程持有 Activity 的 View 而导致内存泄漏(因为工作线程很可能持有 View 的强引用，另外工作线程的生命周期还无法保证和 Activity 的生命周期一致，这样就容易发生内存泄漏了)。</p>
<p>Loader 的出现就是为了确保工作线程能够和 Activity 的生命周期保持一致，同时避免出现前面提到的问题。</p>
<p>LoaderManager 会对查询的操作进行缓存，只要对应 Cursor 上的数据源没有发生变化，在配置信息发生改变的时候(例如屏幕的旋转)，Loader 可以直接把缓存的数据回调到 onLoadFinished()，从而避免重新查询数据。另外系统会在 Loader 不再需要使用到的时候(例如使用 Back 按钮退出当前页面)回调 onLoaderReset()方法，我们可以在这里做数据的清除等等操作。</p>
<ul>
<li>LoaderManager 来管理我们的laoder实例，获取，初始化，重启一个loader。</li>
<li>Loader 来执行我们的异步操作，有开始，完成，后台加载中等接口实现。</li>
<li>LoaderCallbacks 来执行我们的loader回调，主要是绑定分发Loader，完成加载，重置数据等。</li>
</ul>
<p>参考资料：<br><a href="http://www.androidchina.net/5238.html?sukey=3997c0719f1515202fb25b1b408e219206e39e105e1e1203c8dee51645ecddb38f3cf762488f5fdb111f656e0f2997c9" target="_blank" rel="external">Android 线程的正确使用姿势</a><br><a href="http://www.2cto.com/kf/201605/511009.html" target="_blank" rel="external">Android性能优化典范之多线程篇</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android系统机制要求我们在开发过程中耗时的操作不能放在主线程里执行，不然就分分钟卡顿给你看。Android系统也提供了工具类来帮助我们实现多线程。&lt;br&gt;多线程意味着并发，意味着异步，就像在Dota里面玩地卜师一样，需要多线操作，难度就自然很大。&lt;br&gt;总结一下Android系统提供给我们多线程操作的法门，以及为什么我们要使用多线程。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android系统" scheme="http://yoursite.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-View绘制流程</title>
    <link href="http://yoursite.com/2016/08/11/Android%E7%AC%94%E8%AE%B0-View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/11/Android笔记-View绘制流程/</id>
    <published>2016-08-11T13:05:35.000Z</published>
    <updated>2016-09-01T02:30:47.866Z</updated>
    
    <content type="html"><![CDATA[<p>平时应用开发中会使用到Android系统提供给我们的视图组件TextView、ImageView、LinearLayoutd等，它们是如何绘制在屏幕上的，当他们显示的数据或自身的状态改变时，又是如何在屏幕上表现出来的？<br>当自定义UI时，要重写那些哪些函数，怎么去绘制？<br>网上有很多博客都有写过Android系统UI绘制过程，已经非常详尽地解释了。(大神的博文看得真是爽)<br>这里再结合源码总结一下，理清一下思路。</p>
<a id="more"></a>
<h1 id="ViewRoot和DecorVIew"><a href="#ViewRoot和DecorVIew" class="headerlink" title="ViewRoot和DecorVIew"></a>ViewRoot和DecorVIew</h1><p>ViewRoot对应ViewRootImpl类，它是连接WindowManager和DecorView的纽带。<br>在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联。</p>
<h1 id="View绘制"><a href="#View绘制" class="headerlink" title="View绘制"></a>View绘制</h1><ul>
<li>每一个View的绘制过程都必须经历三个最主要的过程，也就是measure、layout和draw。</li>
<li>整个View树的绘图流程是在ViewRootImpl类的performTraversals()方法，该函数做的执行过程主要是根据之前设置的状态，判断是否重新计算视图大小(measure)、是否重新放置视图的位置(layout)、以及是否重绘 (draw)，其核心也就是通过判断来选择顺序执行这三个方法中的哪个。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="comment">//最外层的根视图的widthMeasureSpec和heightMeasureSpec由来</span></div><div class="line">    <span class="comment">//lp.width和lp.height在创建ViewGroup实例时等于MATCH_PARENT</span></div><div class="line">    <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line">    <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line">    ......</div><div class="line">    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    ......</div><div class="line">    mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</div><div class="line">    ......</div><div class="line">    mView.draw(canvas);</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> measureSpec;</div><div class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    ......</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> measureSpec;</div><div class="line">&#125;</div></pre></td></tr></table></figure>        
可以看见这个方法的注释说是用来测Root View的。上面传入参数后这个函数走的是MATCH_PARENT，使用MeasureSpec.makeMeasureSpec方法组装一个MeasureSpec，MeasureSpec的specMode等于EXACTLY，specSize等于windowSize，也就是为何根视图总是全屏的原因。</li>
</ul>
<p>其中的mView就是View对象。如下就是整个流程的大致流程图：</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/20150529090922419.png" alt="Image"></p>
<p><br></p>
<h1 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h1><h3 id="View中的measure-提供给父View调用，并调用了自己的onMeasure，不可重写"><a href="#View中的measure-提供给父View调用，并调用了自己的onMeasure，不可重写" class="headerlink" title="View中的measure(提供给父View调用，并调用了自己的onMeasure，不可重写)"></a>View中的measure(提供给父View调用，并调用了自己的onMeasure，不可重写)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">    ...    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>每个View控件的实际宽高都是由父视图和自身决定的。实际的测量是在onMeasure方法进行。</li>
<li>View的子类需要重写onMeasure方法，这是因为measure方法是final的，不允许重写，所以View子类只能通过重写onMeasure来实现自己的测量逻辑。</li>
<li>这个方法的两个参数都是父View传递过来的，也就是代表了父view的规格。他由两部分组成，高2位表示MODE，定义在MeasureSpec类（View的内部类）中，有三种类型，MeasureSpec.EXACTLY表示确定大小， MeasureSpec.AT_MOST表示最大大小， MeasureSpec.UNSPECIFIED不确定。低30位表示size，也就是父View的大小。对于系统Window类的DecorVIew对象Mode一般都为MeasureSpec.EXACTLY ，而size分别对应屏幕宽高。对于子View来说大小是由父View和子View共同决定的。</li>
</ul>
<h3 id="View中的onMeasure-根据父View的建议参数和子View自己的意向确定子View的宽高-可重写，有默认实现"><a href="#View中的onMeasure-根据父View的建议参数和子View自己的意向确定子View的宽高-可重写，有默认实现" class="headerlink" title="View中的onMeasure(根据父View的建议参数和子View自己的意向确定子View的宽高,可重写，有默认实现)"></a>View中的onMeasure(根据父View的建议参数和子View自己的意向确定子View的宽高,可重写，有默认实现)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对于非ViewGroup的View而言，通过调用上面默认的onMeasure即可完成View的测量，当然你也可以重写onMeasure并调用setMeasuredDimension来设置任意大小的布局。</li>
<li>onMeasure默认的实现仅仅调用了setMeasuredDimension，setMeasuredDimension函数是一个很关键的函数，它对View的成员变量mMeasuredWidth和mMeasuredHeight变量赋值。</li>
<li>measure的主要目的就是对View树中的每个View的mMeasuredWidth和mMeasuredHeight进行赋值，所以一旦这两个变量被赋值意味着该View的测量工作结束。</li>
</ul>
<h3 id="getDefaultSize-onMeasure默认实现的方案，由父View给的建议参数和子View自己的建议最小参数决定"><a href="#getDefaultSize-onMeasure默认实现的方案，由父View给的建议参数和子View自己的建议最小参数决定" class="headerlink" title="getDefaultSize(onMeasure默认实现的方案，由父View给的建议参数和子View自己的建议最小参数决定)"></a>getDefaultSize(onMeasure默认实现的方案，由父View给的建议参数和子View自己的建议最小参数决定)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = size;</div><div class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">        result = size;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">        result = specSize;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果specMode等于AT_MOST或EXACTLY就返回specSize，这就是系统默认的规格。</li>
<li>getDefaultSize参数的widthMeasureSpec和heightMeasureSpec都是由父View传递进来的。getSuggestedMinimumWidth与getSuggestedMinimumHeight都是View的方法。</li>
</ul>
<h3 id="getSuggestedMinimumXXXXX-获得子View自己的建议最小参数"><a href="#getSuggestedMinimumXXXXX-获得子View自己的建议最小参数" class="headerlink" title="getSuggestedMinimumXXXXX(获得子View自己的建议最小参数)"></a>getSuggestedMinimumXXXXX(获得子View自己的建议最小参数)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>建议的最小宽度和高度都是由View的Background尺寸与通过设置View的miniXXX属性共同决定的。</li>
</ul>
<h3 id="ViewGroup中的measureChild-父View调用子View的measure方法-可重写，有默认实现"><a href="#ViewGroup中的measureChild-父View调用子View的measure方法-可重写，有默认实现" class="headerlink" title="ViewGroup中的measureChild(父View调用子View的measure方法,可重写，有默认实现)"></a>ViewGroup中的measureChild(父View调用子View的measure方法,可重写，有默认实现)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">        <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">            mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">            mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ViewGroup定义了measureChild方法对子View进行测量。</li>
<li>ViewGroup继承自View,所以也可以通过重写onMeasure实现自己的测量逻辑。</li>
</ul>
<h2 id="measure小结"><a href="#measure小结" class="headerlink" title="measure小结"></a>measure小结</h2><ul>
<li>measure过程主要就是从顶层父View向子View递归调用view.measure方法（measure中又回调onMeasure方法）的过程。</li>
<li>MeasureSpec（View的内部类）测量规格为int型，值由高2位规格模式specMode和低30位具体尺寸specSize组成。其中specMode只有三种值：<br>1.MeasureSpec.EXACTLY //确定模式，父View希望子View的大小是确定的，由specSize决定；<br>2.MeasureSpec.AT_MOST //最多模式，父View希望子View的大小最多是specSize指定的值；<br>3.MeasureSpec.UNSPECIFIED //未指定模式，父View完全依据子View的设计值来决定；</li>
<li>View的measure方法是final的，不允许重载，View子类只能重写onMeasure来完成自己的测量逻辑。</li>
<li>最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定的（LayoutParams宽高参数均为MATCH_PARENT，specMode是EXACTLY，specSize为物理屏幕大小）。</li>
<li>ViewGroup类提供了measureChild，measureChild和measureChildWithMargins方法，简化了父子View的尺寸计算。</li>
<li>View的布局大小由父View和子View共同决定。</li>
<li>使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流程之后被调用才能返回有效值。</li>
</ul>
<p><br></p>
<h1 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h1><h3 id="View中的layout-提供给父View调用，并调用自己的onLayout方法，确定自己的位置，可重写，有默认实现"><a href="#View中的layout-提供给父View调用，并调用自己的onLayout方法，确定自己的位置，可重写，有默认实现" class="headerlink" title="View中的layout(提供给父View调用，并调用自己的onLayout方法，确定自己的位置，可重写，有默认实现)"></a>View中的layout(提供给父View调用，并调用自己的onLayout方法，确定自己的位置，可重写，有默认实现)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> oldL = mLeft;</div><div class="line">    <span class="keyword">int</span> oldT = mTop;</div><div class="line">    <span class="keyword">int</span> oldB = mBottom;</div><div class="line">    <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">        onLayout(changed, l, t, r, b);</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">        ListenerInfo li = mListenerInfo;</div><div class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>类似measure过程，layout调用了onLayout方法。</li>
<li>View的layout方法是可以在子类重写的。</li>
</ul>
<h3 id="View中的onLayout-空方法，可重写，无默认实现"><a href="#View中的onLayout-空方法，可重写，无默认实现" class="headerlink" title="View中的onLayout(空方法，可重写，无默认实现)"></a>View中的onLayout(空方法，可重写，无默认实现)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>View中的onLayout是个空方法。</li>
</ul>
<h3 id="ViewGroup中的layout-不可重写，作用是让ViewGroup必须调用自己的onLayout"><a href="#ViewGroup中的layout-不可重写，作用是让ViewGroup必须调用自己的onLayout" class="headerlink" title="ViewGroup中的layout(不可重写，作用是让ViewGroup必须调用自己的onLayout)"></a>ViewGroup中的layout(不可重写，作用是让ViewGroup必须调用自己的onLayout)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</div><div class="line">        <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</div><div class="line">            mTransition.layoutChange(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">super</span>.layout(l, t, r, b);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// record the fact that we noop'd it; request layout when transition finishes</span></div><div class="line">        mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ViewGroup的layout是不能在子类重写的。</li>
<li>所以ViewGroup中只能通过重写onLayout方法计算自己的位置。</li>
<li>必定调用onLayout，不然重写onLayout有何意义？</li>
</ul>
<h3 id="ViewGroup中的onLayout-必须重写，ViewGroup必须自己定义如何布局子View"><a href="#ViewGroup中的onLayout-必须重写，ViewGroup必须自己定义如何布局子View" class="headerlink" title="ViewGroup中的onLayout(必须重写，ViewGroup必须自己定义如何布局子View)"></a>ViewGroup中的onLayout(必须重写，ViewGroup必须自己定义如何布局子View)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed,</span></span></div><div class="line">        <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b);</div></pre></td></tr></table></figure>
<ul>
<li>ViewGroup中的onLayout是一个虚方法，所有ViewGroup的子类都必须重写这个方法。</li>
<li>所以在自定义ViewGroup控件中，onLayout配合onMeasure方法一起使用可以实现自定义View的复杂布局。自定义View首先调用onMeasure进行测量，然后调用onLayout方法动态获取子View和子View的测量大小，然后进行layout布局。</li>
<li>重载onLayout的目的就是安排其children在父View的具体位置，重载onLayout通常做法就是写一个for循环调用每一个子视图的layout(l, t, r, b)函数，传入不同的参数l, t, r, b来确定每个子视图在父视图中的显示位置。</li>
<li>比如LinearLayout中根据定义的mOrientation不同重写了不同的布局逻辑。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</div><div class="line">        layoutVertical(l, t, r, b);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        layoutHorizontal(l, t, r, b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="layout小结"><a href="#layout小结" class="headerlink" title="layout小结"></a>layout小结</h2><ul>
<li>layout也是从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。</li>
<li>View.layout方法可被重载，ViewGroup.layout为final的不可重载，ViewGroup.onLayout为abstract的，子类必须重载实现自己的位置逻辑。</li>
<li>measure操作完成后得到的是对每个View经测量过的measuredWidth和measuredHeight，layout操作完成之后得到的是对每个View进行位置分配后的mLeft、mTop、mRight、mBottom，这些值都是相对于父View来说的。</li>
<li>凡是layout_XXX的布局属性基本都针对的是包含子View的ViewGroup的，当对一个没有父容器的View设置相关layout_XXX属性是没有任何意义的。</li>
<li>使用View的getWidth()和getHeight()方法来获取View测量的宽高，必须保证这两个方法在onLayout流程之后被调用才能返回有效值。</li>
</ul>
<p><br></p>
<h1 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h1><h3 id="View中的draw-分步进行自己的绘制"><a href="#View中的draw-分步进行自己的绘制" class="headerlink" title="View中的draw(分步进行自己的绘制)"></a>View中的draw(分步进行自己的绘制)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallSuper</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Draw traversal performs several drawing steps which must be executed</div><div class="line">     * in the appropriate order:</div><div class="line">     *</div><div class="line">     *      1. Draw the background</div><div class="line">     *      2. If necessary, save the canvas' layers to prepare for fading</div><div class="line">     *      3. Draw view's content</div><div class="line">     *      4. Draw children</div><div class="line">     *      5. If necessary, draw the fading edges and restore layers</div><div class="line">     *      6. Draw decorations (scrollbars for instance)</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">    <span class="keyword">int</span> saveCount;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">        drawBackground(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">        <span class="comment">// Step 3, draw the content</span></div><div class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// Step 4, draw the children</span></div><div class="line">        dispatchDraw(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></div><div class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></div><div class="line">        onDrawForeground(canvas);</div><div class="line"></div><div class="line">        <span class="comment">// we're done...</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个draw过程分为了6步,第2和5步可以跳过(skip step 2 &amp; 5 if possible (common case))。</p>
<ul>
<li>第一步，对View的背景进行绘制。</li>
<li>第三步，对View的内容进行绘制。</li>
<li>第四步，对当前View的所有子View进行绘制，如果当前的View没有子View就不需要进行绘制。</li>
<li>第六步，对View的滚动条进行绘制。<br>可以看见其实任何一个View都是有（水平垂直）滚动条的，只是一般情况下没让它显示而已。</li>
</ul>
<h3 id="View中的onDraw-空方法，View可以-不是必须-自己定义如何绘制自己"><a href="#View中的onDraw-空方法，View可以-不是必须-自己定义如何绘制自己" class="headerlink" title="View中的onDraw(空方法，View可以(不是必须)自己定义如何绘制自己)"></a>View中的onDraw(空方法，View可以(不是必须)自己定义如何绘制自己)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Implement this to do your drawing.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> canvas the canvas on which the background will be drawn</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>View中的onDraw是一个空方法,因为每个View的内容部分是各不相同的，所以需要由子类去实现具体逻辑。</li>
</ul>
<h3 id="View中的dispatchDraw-空方法，ViewGroup才会重写"><a href="#View中的dispatchDraw-空方法，ViewGroup才会重写" class="headerlink" title="View中的dispatchDraw(空方法，ViewGroup才会重写)"></a>View中的dispatchDraw(空方法，ViewGroup才会重写)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Called by draw to draw the child views. This may be overridden</div><div class="line"> * by derived classes to gain control just before its children are drawn</div><div class="line"> * (but after its own view has been drawn).</div><div class="line"> * <span class="doctag">@param</span> canvas the canvas on which to draw the view</div><div class="line"> */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>View中的dispatchDraw也是一个空方法，注释说明了如果View包含子类需要重写他。</li>
</ul>
<h3 id="ViewGroup中的dispatchDraw-调用drawChild方法"><a href="#ViewGroup中的dispatchDraw-调用drawChild方法" class="headerlink" title="ViewGroup中的dispatchDraw(调用drawChild方法)"></a>ViewGroup中的dispatchDraw(调用drawChild方法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">int</span> flags = mGroupFlags;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</div><div class="line">        <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</div><div class="line">            <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</div><div class="line">            <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</div><div class="line">                    transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</div><div class="line">                more |= drawChild(canvas, transientChild, drawingTime);</div><div class="line">            &#125;</div><div class="line">            transientIndex++;</div><div class="line">            <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</div><div class="line">                transientIndex = -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">        <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">                ? children[childIndex] : preorderedList.get(childIndex);</div><div class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</div><div class="line">            more |= drawChild(canvas, child, drawingTime);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// there may be additional transient views after the normal views</span></div><div class="line">        <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</div><div class="line">        <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</div><div class="line">                transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</div><div class="line">            more |= drawChild(canvas, transientChild, drawingTime);</div><div class="line">        &#125;</div><div class="line">        transientIndex++;</div><div class="line">        <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</div><div class="line"></div><div class="line">    <span class="comment">// Draw any disappearing views that have animations</span></div><div class="line">    <span class="keyword">if</span> (mDisappearingChildren != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">final</span> ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> disappearingCount = disappearingChildren.size() - <span class="number">1</span>;</div><div class="line">        <span class="comment">// Go backwards -- we may delete as animations finish</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = disappearingCount; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">final</span> View child = disappearingChildren.get(i);</div><div class="line">            more |= drawChild(canvas, child, drawingTime);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ViewGroup没有重写draw，也没有重写onDraw，而是重写了dispatchDraw方法，然后调用drawChild方法。</li>
</ul>
<h3 id="ViewGroup的drawChild-调用子View的draw方法"><a href="#ViewGroup的drawChild-调用子View的draw方法" class="headerlink" title="ViewGroup的drawChild(调用子View的draw方法)"></a>ViewGroup的drawChild(调用子View的draw方法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>drawChild()方法调用了子View的draw()方法。所以说ViewGroup类已经为我们重写了dispatchDraw()的功能实现，我们一般不需要重写该方法，但可以重载父类函数实现具体的功能。</li>
</ul>
<h2 id="draw小结"><a href="#draw小结" class="headerlink" title="draw小结"></a>draw小结</h2><ul>
<li>如果该View是一个ViewGroup，则需要递归绘制其所包含的所有子View。</li>
<li>View默认不会绘制任何内容，真正的绘制都需要自己在子类中实现。</li>
<li>View的绘制是借助onDraw方法传入的Canvas类来进行的。</li>
<li>区分View动画和ViewGroup布局动画，前者指的是View自身的动画，可以通过setAnimation添加，后者是专门针对ViewGroup显示内部子视图时设置的动画，可以在xml布局文件中对ViewGroup设置layoutAnimation属性。</li>
<li>在获取画布剪切区（每个View的draw中传入的Canvas）时会自动处理掉padding，子View获取Canvas不用关注这些逻辑，只用关心如何绘制即可。</li>
<li>默认情况下子View的ViewGroup.drawChild绘制顺序和子View被添加的顺序一致，但是你也可以重写ViewGroup.getChildDrawingOrder()方法提供不同顺序。</li>
</ul>
<p>参考资料：<br><a href="http://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="external">Android应用层View绘制流程与源码分析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时应用开发中会使用到Android系统提供给我们的视图组件TextView、ImageView、LinearLayoutd等，它们是如何绘制在屏幕上的，当他们显示的数据或自身的状态改变时，又是如何在屏幕上表现出来的？&lt;br&gt;当自定义UI时，要重写那些哪些函数，怎么去绘制？&lt;br&gt;网上有很多博客都有写过Android系统UI绘制过程，已经非常详尽地解释了。(大神的博文看得真是爽)&lt;br&gt;这里再结合源码总结一下，理清一下思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android系统" scheme="http://yoursite.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="View绘制流程" scheme="http://yoursite.com/tags/View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-设计模式</title>
    <link href="http://yoursite.com/2016/08/10/Android%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/08/10/Android笔记-设计模式/</id>
    <published>2016-08-10T14:20:29.000Z</published>
    <updated>2016-08-28T07:37:26.918Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>在软件开发中使用设计模式能够让我们写出更加可靠，可重用，可扩展的代码。平时常见到的设计模式有单例模式、工厂模式、适配器模式、代理模式等。<br>我的理解是设计模式是套路，dota里面也有很多套路，使用套路可以帮我们更轻松地赢得比赛。同样，在合适的场景使用设计模式提供给我们的套路能使我们的代码变得更强壮。</p>
<a id="more"></a>
<h1 id="面向对象的六大原则"><a href="#面向对象的六大原则" class="headerlink" title="面向对象的六大原则"></a>面向对象的六大原则</h1><ul>
<li>单一职责原则<br>所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。通俗的说，即一个类只负责一项职责，将一组相关性很高的函数、数据封装到一个类中。</li>
<li>开闭原则<br>对于扩展是开放的，这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。<br>对于修改是关闭的，对模块行为进行扩展时，不必改动模块的源代码。通俗的说，尽量通过扩展的方式实现系统的升级维护和新功能添加，而不是通过修改已有的源代码。</li>
<li>里氏替换原则<br>使用“抽象(Abstraction)”和“多态(Polymorphism)”将设计中的静态结构改为动态结构，维持设计的封闭性。任何基类可以出现的地方，子类一定可以出现。在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li>
<li>依赖倒置原则<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合（各个模块之间相互传递的参数声明为抽象类型，而不是声明为具体的实现类）。</li>
<li>接口隔离原则<br>一个类对另一个类的依赖应该建立在最小的接口上。其原则是将非常庞大的、臃肿的接口拆分成更小的更具体的接口。</li>
<li>最少知识原则<br>就是说一个对象应当对其他对象有尽可能少的了解。<br>通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，不关心被耦合或调用的类的内部实现，只负责调用你提供的方法。</li>
</ul>
<h1 id="Singleton（单例模式）"><a href="#Singleton（单例模式）" class="headerlink" title="Singleton（单例模式）"></a>Singleton（单例模式）</h1><p>作用：保证在Java应用程序中，一个类Class只有一个实例存在。</p>
<p>好处：<br>由于单例模式在内存中只有一个实例，减少了内存开销。<br>单例模式可以避免对资源的多重占用，例如一个写文件时，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。<br>单例模式可以再系统设置全局的访问点，优化和共享资源访问。</p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 私有构造方法，防止被实例化 */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 懒汉式：第一次调用时初始Singleton，以后就不用再生成了</span></div><div class="line">    静态方法，创建实例 */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 私有构造方法，防止被实例化 */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 懒汉式：第一次调用时初始Singleton，以后就不用再生成了</span></div><div class="line">    静态方法，创建实例 */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">         <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">         instance = <span class="keyword">new</span> Singleton();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* 持有私有静态实例，防止被引用，此处直接创建 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="comment">/* 私有构造方法，防止被实例化 */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 饿汉式：类加载时就创建了静态实例。 */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Android中的Singleton"><a href="#Android中的Singleton" class="headerlink" title="Android中的Singleton"></a>Android中的Singleton</h2><p>软键盘管理的 InputMethodManager<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InputMethodManager</span> </span>&#123;</div><div class="line">    <span class="comment">//.........</span></div><div class="line">    <span class="keyword">static</span> InputMethodManager sInstance;</div><div class="line">    <span class="comment">//.........</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputMethodManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (InputMethodManager.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);</div><div class="line">                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);</div><div class="line">                sInstance = <span class="keyword">new</span> InputMethodManager(service, Looper.getMainLooper());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> sInstance;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><br>Application并不算是单例模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Application</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>在Application源码中，其构造方法是公有的，意味着可以生出多个Application实例，但为什么Application能实现一个app只存在一个实例？<br>在ContextWrapper源码中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</div><div class="line">Context mBase;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ContextWrapper</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">    mBase = base;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</div><div class="line">    &#125;</div><div class="line">    mBase = base;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>ContextWrapper构造函数传入的base为null, 就算有多个Application实例，但是没有通过attach()绑定相关信息，没有上下文环境，即使创建了也没用。</p>
<h1 id="Factory（工厂模式）"><a href="#Factory（工厂模式）" class="headerlink" title="Factory（工厂模式）"></a>Factory（工厂模式）</h1><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。<br>对同一个接口的实现类进行管理和实例化创建。</p>
<p>假设我们有这样一个需求：</p>
<p>动物Animal，它有行为move()。有两个实现类cat和dog。为了统一管理和创建我们设计一个工厂模式。<br>同时两个子类有各自的行为，Cat有eatFish()，Dog有eatBone().</p>
<p>Animal接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">animal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Cat类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        System.out.println(<span class="string">"我是只肥猫，不爱动"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatFish</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"爱吃鱼"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Dog类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        System.out.println(<span class="string">"我是狗，跑的快"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatBone</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"爱吃骨头"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>那么现在就可以建一个工厂类（Factory.java）来对实例类进行管理和创建了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="comment">//静态工厂方法</span></div><div class="line">    <span class="comment">//多处调用，不需要实例工厂类</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title">produceCat</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title">produceDog</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</div><div class="line">    &#125;</div><div class="line"><span class="comment">//当然也可以一个方法，通过传入参数，switch实现</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br>使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Animal cat = Factory.produceCat();</div><div class="line">cat.move();</div><div class="line"><span class="comment">//-----------------------------</span></div><div class="line">Dog dog = Factory.produceDog();</div><div class="line">dog.move();</div><div class="line">dog.eatBone();</div></pre></td></tr></table></figure><br>这里实例化了Animal但不涉及到Animal的具体子类（减少了它们之间的耦合联系性），达到封装效果，也就减少错误修改的机会</p>
<p>Java面向对象的原则，封装(Encapsulation)和分派(Delegation)告诉我们：具体事情做得越多，越容易范错误。<br>一般来说，这样的普通工厂就可以满足基本需求。但是我们如果要新增一个Animal的实现类panda，那么必然要在工厂类里新增了一个生产panda的方法。就违背了闭包的设计原则（对扩展要开放对修改要关闭） ，于是有了抽象工厂模式。</p>
<h1 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory(抽象工厂)"></a>Abstract Factory(抽象工厂)</h1><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>就是把生产抽象成一个接口，每个实例类都对应一个工厂类（普通工厂只有一个工厂类），同时所有工厂类都继承这个生产接口。</p>
<p>生产接口Provider：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</div><div class="line">    <span class="function">Animal <span class="title">produce</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>每个产品都有自己的工厂<br>CatFactory：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">produce</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>DogFactory：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Animal <span class="title">produce</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>产品生产：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Provider provider = <span class="keyword">new</span> CatFactory();</div><div class="line">Animal cat =provider.produce();</div><div class="line">cat.move();</div></pre></td></tr></table></figure><br>现在我们要加入panda，直接新建一个pandaFactory就行了，这样我们系统就非常灵活，具备了动态扩展功能。</p>
<h2 id="Android中的Factory"><a href="#Android中的Factory" class="headerlink" title="Android中的Factory"></a>Android中的Factory</h2><p>AsyncTask的抽象工厂实现：<br>工厂的抽象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</div><div class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>产品的抽象（new Runnable就是其实现类）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>AsyncTask中工厂类的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br>其中sThreadFactory唯一作用是作为线程池的专业用来生产线程的工厂：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">        = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure><br>Android中的BitmapFactory中有重载的decodeXXXXXX()方法，大意就是资源的不同,但生产出的都是Bitmap。</p>
<h1 id="Adapter（适配器模式）"><a href="#Adapter（适配器模式）" class="headerlink" title="Adapter（适配器模式）"></a>Adapter（适配器模式）</h1><p>将一个类的接口转换成客户希望的另外一个接口。<br>我们经常碰到要将两个没有关系的类组合在一起使用，第一解决方案是：修改各自类的接口，但是如果我们没有源代码，或者，我们不愿意为了一个应用而修改各自的接口。 怎么办?<br>使用Adapter，在这两种接口之间创建一个混合接口。</p>
<p>模式中的角色<br>需要适配的类（Adaptee）：需要适配的类。<br>适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。<br>目标接口（Target）：客户所期待的接口。可以是具体的或抽象的类，也可以是接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 需要适配的类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"需要适配的类"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 目标接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>实现方式：<br>对象适配器（采用对象组合方式实现）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 适配器类实现标准接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</div><div class="line">    <span class="comment">// 直接关联被适配类</span></div><div class="line">    <span class="keyword">private</span> Adaptee adaptee;</div><div class="line"></div><div class="line">    <span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span> <span class="params">(Adaptee adaptee)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee = adaptee;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 这里是使用委托的方式完成特殊功能</span></div><div class="line">        <span class="keyword">this</span>.adaptee.specificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 需要先创建一个被适配类的对象作为参数</span></div><div class="line">        Target adapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</div><div class="line">        adapter.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果Target不是接口而是一个具体的类的情况，这里的Adapter直接继承Target就可以了。</p>
<p>类的适配器模式（采用继承实现）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 适配器类继承了被适配类同时实现标准接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.specificRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试类</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 使用适配类</span></div><div class="line">    Target adapter = <span class="keyword">new</span> Adapter();</div><div class="line">    adapter.request();</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果Target和 Adaptee都是接口，并且都有实现类。 可以通过Adapter实现两个接口来完成适配。<br>还有一种叫PluggableAdapters,可以动态的获取几个adapters中一个。使用Reflection技术，可以动态的发现类中的Public方法。</p>
<p>优点：</p>
<ul>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li>
<li>将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码，更好的扩展性。</li>
</ul>
<p>缺点</p>
<ul>
<li>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现。如果不是必要，不要使用适配器，而是直接对系统进行重构。</li>
</ul>
<h2 id="Android中的Adapter"><a href="#Android中的Adapter" class="headerlink" title="Android中的Adapter"></a>Android中的Adapter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAdapter</span> <span class="keyword">implements</span> <span class="title">ListAdapter</span>, <span class="title">SpinnerAdapter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSetObservable mDataSetObservable = <span class="keyword">new</span> DataSetObservable();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasStableIds</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDataSetObserver</span><span class="params">(DataSetObserver observer)</span> </span>&#123;</div><div class="line">        mDataSetObservable.registerObserver(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterDataSetObserver</span><span class="params">(DataSetObserver observer)</span> </span>&#123;</div><div class="line">        mDataSetObservable.unregisterObserver(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>    
<p>ListAdapter, SpinnerAdapter都是Target ，数据是Adaptee ，采用对象组合方式。</p>
<h1 id="Chain-of-Responsibility（责任链模式）"><a href="#Chain-of-Responsibility（责任链模式）" class="headerlink" title="Chain of Responsibility（责任链模式）"></a>Chain of Responsibility（责任链模式）</h1><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<br>发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p>
<p>责任链模式的优点:<br>可以降低系统的耦合度（请求者与处理者代码分离），简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；</p>
<p>责任链模式的缺点:<br>不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。<br>每次都是从链头开始，这也正是链表的缺点。</p>
<h2 id="Android中的Chain-of-Responsibility"><a href="#Android中的Chain-of-Responsibility" class="headerlink" title="Android中的Chain of Responsibility"></a>Android中的Chain of Responsibility</h2><p>触摸、按键等各种事件的传递<br><img src="http://ob5qdb9lc.bkt.clouddn.com/20160621101505594_3.gif" alt="Image"></p>
<h1 id="Observer（观察者模式）"><a href="#Observer（观察者模式）" class="headerlink" title="Observer（观察者模式）"></a>Observer（观察者模式）</h1><p>有时被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<p>将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的（依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。）。</p>
<p>RxJava Observable类源自于经典的Gang Of Four的观察者模式。</p>
<h1 id="Builder（建造者模式）"><a href="#Builder（建造者模式）" class="headerlink" title="Builder（建造者模式）"></a>Builder（建造者模式）</h1><p>建造者模式：是将一个复杂的对象的构建与它的表示分离（同构建不同表示），使得同样的构建过程可以创建不同的表示。</p>
<p>一个人活到70岁以上，都会经历这样的几个阶段：婴儿，少年，青年，中年，老年。并且每个人在各个阶段肯定是不一样的，世界上不存在两个人在人生的这5个阶段的生活完全一样，但是活到70岁以上的人，都经历了这几个阶段是肯定的。实际上这是一个比较经典的建造者模式的例子了。</p>
<p>将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心。</p>
<p>建造者模式通常包括下面几个角色：</p>
<ul>
<li>Builder：一个抽象接口，用来规范产品对象的各个组成成分的建造。</li>
<li>ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建，在建造过程完成后，提供产品的实例。</li>
<li>Director：指导者，调用具体建造者来创建复杂对象的各个部分，不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li>
<li>Product：要创建的复杂对象。</li>
</ul>
<p>与抽象工厂的区别：在建造者模式里，有个指导者，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的建造过程。</p>
<p>优点：</p>
<ul>
<li>客户端不必知道产品内部组成的细节。</li>
<li>具体的建造者类之间是相互独立的，对系统的扩展非常有利。</li>
<li>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</li>
</ul>
<p>使用场合：</p>
<ul>
<li>创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。</li>
<li>要创建的复杂对象的算法，独立于该对象的组成部分，也独立于组成部分的装配方法时。</li>
</ul>
<h1 id="Android中的Builder"><a href="#Android中的Builder" class="headerlink" title="Android中的Builder"></a>Android中的Builder</h1><p>AlertDialog:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AlertController.AlertParams P;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTheme;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Constructor using a context for this builder and the &#123;<span class="doctag">@link</span> AlertDialog&#125; it creates.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, resolveDialogTheme(context, <span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Constructor using a context and theme for this builder and</div><div class="line">     * the &#123;<span class="doctag">@link</span> AlertDialog&#125; it creates.  The actual theme</div><div class="line">     * that an AlertDialog uses is a private implementation, however you can</div><div class="line">     * here supply either the name of an attribute in the theme from which</div><div class="line">     * to get the dialog's style (such as &#123;<span class="doctag">@link</span> android.R.attr#alertDialogTheme&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context, <span class="keyword">int</span> theme)</span> </span>&#123;</div><div class="line">        P = <span class="keyword">new</span> AlertController.AlertParams(<span class="keyword">new</span> ContextThemeWrapper(</div><div class="line">                context, resolveDialogTheme(context, theme)));</div><div class="line">        mTheme = theme;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>Builder类中部分方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setTitle</span><span class="params">(<span class="keyword">int</span> titleId)</span> </span>&#123;</div><div class="line">    P.mTitle = P.mContext.getText(titleId);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setMessage</span><span class="params">(<span class="keyword">int</span> messageId)</span> </span>&#123;</div><div class="line">    P.mMessage = P.mContext.getText(messageId);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setPositiveButton</span><span class="params">(CharSequence text, <span class="keyword">final</span> OnClickListener listener)</span> </span>&#123;</div><div class="line">    P.mPositiveButtonText = text;</div><div class="line">    P.mPositiveButtonListener = listener;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>简单建造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> AlertDialog.Builder(context)</div><div class="line">.setTitle(<span class="string">"标题"</span>)</div><div class="line">.setMessage(<span class="string">"消息框"</span>)</div><div class="line">.setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">null</span>)</div><div class="line">.show();</div></pre></td></tr></table></figure><br>Retrofit中也同样用到Bulider<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> Platform platform;</div><div class="line">        <span class="keyword">private</span> okhttp3.Call.Factory callFactory;</div><div class="line">        <span class="keyword">private</span> HttpUrl baseUrl;</div><div class="line">        <span class="keyword">private</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">private</span> List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">private</span> Executor callbackExecutor;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</div><div class="line"></div><div class="line">        Builder(Platform platform) &#123;</div><div class="line">        <span class="keyword">this</span>.platform = platform;</div><div class="line">        <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></div><div class="line">        <span class="comment">// ensures correct behavior when using converters that consume all types.</span></div><div class="line">        converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</div><div class="line">    &#125;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>简单建造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient.Builder();</div><div class="line">builder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">retrofit=<span class="keyword">new</span> Retrofit.Builder()</div><div class="line">        .baseUrl(BASE_URL)</div><div class="line">        .client(builder.build())</div><div class="line">        .addConverterFactory(GsonConverterFactory.create())</div><div class="line">        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">        .build();</div></pre></td></tr></table></figure></p>
<h1 id="Memento（备忘录模式）"><a href="#Memento（备忘录模式）" class="headerlink" title="Memento（备忘录模式）"></a>Memento（备忘录模式）</h1><p>备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。</p>
<p>备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。</p>
<p>备忘录模式所涉及的角色有三个：</p>
<ol>
<li>Originator(发起人):　负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。</li>
<li>Memento(备忘录):　负责存储Originnator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento，备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。</li>
<li>Caretaker(管理者):负责保存好备忘录Memento，不能对备忘录的内容进行操作或检查。</li>
</ol>
<h2 id="Android中的Memento"><a href="#Android中的Memento" class="headerlink" title="Android中的Memento"></a>Android中的Memento</h2><p>Activity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle（相当于备忘录对象）这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</div><div class="line">    Parcelable p = mFragments.saveAllState();</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</div><div class="line">    &#125;</div><div class="line">    getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mWindow != <span class="keyword">null</span>) &#123;</div><div class="line">        Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);</div><div class="line">        <span class="keyword">if</span> (windowState != <span class="keyword">null</span>) &#123;</div><div class="line">            mWindow.restoreHierarchyState(windowState);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Prototype（原型模式）"><a href="#Prototype（原型模式）" class="headerlink" title="Prototype（原型模式）"></a>Prototype（原型模式）</h1><p>原型模式，能快速克隆出一个与已经存在对象类似的另外一个我们想要的新对象。<br>工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。</p>
<p>分为深拷贝和浅拷贝。深拷贝就是把对象里面的引用的对象也要拷贝一份新的对象，并将这个新的引用对象作为拷贝的对象引用（多读两遍）。</p>
<p>一般使用原型模式有个明显的特点，就是实现cloneable的clone()方法。</p>
<h2 id="Android中的Prototype"><a href="#Android中的Prototype" class="headerlink" title="Android中的Prototype"></a>Android中的Prototype</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Intent(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>  
<p>这里Intent通过实现Cloneable接口来实现原型拷贝。<br>Intent克隆的意义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Make a clone of only the parts of the Intent that are relevant for</div><div class="line"> * filter matching: the action, data, type, component, and categories.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">cloneFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Intent(<span class="keyword">this</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Strategy（策略模式）"><a href="#Strategy（策略模式）" class="headerlink" title="Strategy（策略模式）"></a>Strategy（策略模式）</h1><p>定义：有一系列的算法，将每个算法封装起来（每个算法可以封装到不同的类中），各个算法之间可以替换，策略模式让算法独立于使用它的客户而独立变化。</p>
<p>举例：<br>一个影碟机，你往里面插什么碟子，就能放出什么电影。<br>属性动画，设置不同的插值器对象，就可以得到不同的变化曲线。<br>返回值解析，传入什么样的解析器，就可以把二进制数据转换成什么格式的数据，比如String、Json、XML。</p>
<p>策略模式其实就是多态的一个淋漓精致的体现。</p>
<h2 id="Android中的Strategy"><a href="#Android中的Strategy" class="headerlink" title="Android中的Strategy"></a>Android中的Strategy</h2><p>在android中不同Animation动画的实现，主要是依靠Interpolator(补间器，控制动画的变化速率)的不同而实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterpolator</span><span class="params">(Interpolator i)</span> </span>&#123;</div><div class="line">    mInterpolator = i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Template（模板模式）"><a href="#Template（模板模式）" class="headerlink" title="Template（模板模式）"></a>Template（模板模式）</h1><p>定义：定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定的步骤。<br>实现流程已经确定，实现细节由子类完成。</p>
<h2 id="Android中的Template"><a href="#Android中的Template" class="headerlink" title="Android中的Template"></a>Android中的Template</h2><p>生命周期对于我们都不陌生，它就是典型的Template模式，在具体流程确定的情况下，至于我们要复写生命周期那些方法，实现那些功能由继承activity的子类去具体实现。<br>关键在于必须有具体的执行流程，比如AsyncTask。</p>
<h1 id="Proxy（代理模式）"><a href="#Proxy（代理模式）" class="headerlink" title="Proxy（代理模式）"></a>Proxy（代理模式）</h1><p>定义：为其他对象提供一种代理以控制对这个对象的访问。<br>代理： 在出发点到目的地之间有一道中间层。</p>
<h2 id="Android中Proxy"><a href="#Android中Proxy" class="headerlink" title="Android中Proxy"></a>Android中Proxy</h2><p>Retrofit中也用到了Proxy。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">  Utils.validateServiceInterface(service);</div><div class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">    eagerlyValidateMethods(service);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></div><div class="line">            <span class="keyword">throws</span> Throwable &#123;</div><div class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">          &#125;</div><div class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">          OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Interpreter（解释器模式）"><a href="#Interpreter（解释器模式）" class="headerlink" title="Interpreter（解释器模式）"></a>Interpreter（解释器模式）</h1><p>定义语言的文法，并且建立一个解释器来解释该语言中的句子。<br>比如Android中通过PackageManagerService来解析AndroidManifest.xml中定义的Activity、service等属性。</p>
<h1 id="State（状态模式）"><a href="#State（状态模式）" class="headerlink" title="State（状态模式）"></a>State（状态模式）</h1><p>行为是由状态来决定的，不同状态下有不同行为。<br>注意：状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立可相互替换的。<br>体现：不同的状态执行不同的行为，当WIFI开启时，自动扫描周围的接入点，然后以列表的形式展示；当wifi关闭时则清空。</p>
<h1 id="Command（命令模式）"><a href="#Command（命令模式）" class="headerlink" title="Command（命令模式）"></a>Command（命令模式）</h1><p>我们有很多命令，把它们放在一个下拉菜单中，用户通过先选择菜单再选择具体命令，这就是Command模式。</p>
<p>本来用户(调用者)是直接调用这些命令的，在菜单上打开文档，就直接指向打开文档的代码，使用Command模式，就是在这两者之间增加一个中间者，将这种直接关系拗断，同时两者之间都隔离,基本没有关系了。</p>
<p>显然这样做的好处是符合封装的特性，降低耦合度，有利于代码的健壮性 可维护性 还有复用性。Command是将对行为进行封装的典型模式，Factory是将创建进行封装的模式。</p>
<p>android底层逻辑对事件的转发处理就用到了Command模式。</p>
<h1 id="Iterator（迭代模式）"><a href="#Iterator（迭代模式）" class="headerlink" title="Iterator（迭代模式）"></a>Iterator（迭代模式）</h1><p>提供一种方法顺序访问一个容器对象中的各个元素，而不需要暴露该对象的内部表示。<br>应用：<br>在Java中的Iterator类。<br>Android中的 Cursor。</p>
<h1 id="Composite（组合模式）"><a href="#Composite（组合模式）" class="headerlink" title="Composite（组合模式）"></a>Composite（组合模式）</h1><p>将对象以树形结构组织起来，以达成“部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。</p>
<p>Android中View的结构是树形结构，每个ViewGroup包含一系列的View，而ViewGroup本身又是View。这是Android中非常典型的组合模式。</p>
<h1 id="Flyweight（共享模式-享元模式）"><a href="#Flyweight（共享模式-享元模式）" class="headerlink" title="Flyweight（共享模式/享元模式）"></a>Flyweight（共享模式/享元模式）</h1><p>定义：避免大量拥有相同内容的小类的开销(如耗费内存)，使大家共享一个类(元类)。</p>
<p>面向对象语言的原则就是一切都是对象，但是如果真正使用起来，有时对象数可能显得很庞大，比如，字处理软件，如果以每个文字都作为一个对象，几千个字，对象数就是几千，无疑耗费内存，那么我们还是要”求同存异”，找出这些对象群的共同点，设计一个元类，封装可以被共享的类，另外，还有一些特性是取决于应用(context)，是不可共享的，这也Flyweight中两个重要概念内部状态intrinsic和外部状态extrinsic之分。</p>
<p>说白点，就是先捏一个的原始模型，然后随着不同场合和环境，再产生各具特征的具体模型，很显然，在这里需要产生不同的新对象，所以Flyweight模式中常出现Factory模式。Flyweight的内部状态是用来共享的，Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象。</p>
<p>Flyweight模式是一个提高程序效率和性能的模式，会大大加快程序的运行速度。应用场合很多：比如你要从一个数据库中读取一系列字符串，这些字符串中有许多是重复的，那么我们可以将这些字符串储存在Flyweight池(pool)中。</p>
<p>在Android线程通信中，每次获取Message时调Message.obtain()其实就是从消息池中取出可重复使用的消息，避免产生大量的Message对象。</p>
<p>参考资料：<br><a href="http://www.androidchina.net/5115.html?sukey=3997c0719f1515206fcb3e208377fb04b0d6d5bac30e6c12e922c8c935f52f6ec04d69ccd1ad82d6ea0de8db077b4ab4" target="_blank" rel="external">Android 源码中的设计模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。&lt;br&gt;在软件开发中使用设计模式能够让我们写出更加可靠，可重用，可扩展的代码。平时常见到的设计模式有单例模式、工厂模式、适配器模式、代理模式等。&lt;br&gt;我的理解是设计模式是套路，dota里面也有很多套路，使用套路可以帮我们更轻松地赢得比赛。同样，在合适的场景使用设计模式提供给我们的套路能使我们的代码变得更强壮。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-View事件分发机制</title>
    <link href="http://yoursite.com/2016/08/10/Android%E7%AC%94%E8%AE%B0-View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/08/10/Android笔记-View事件分发机制/</id>
    <published>2016-08-10T13:00:28.000Z</published>
    <updated>2016-09-01T07:12:21.283Z</updated>
    
    <content type="html"><![CDATA[<p>我们一般通过点击和滑动屏幕给应用下达指令，应用就会响应并做出相应的处理。这其中经历了一段怎样的过程？<br>Android事件分发机制总的来说就是先分发再处理，是责任链模式的运用，其处理过程中有很多细节，所以相关的代码很长。<br>这里笼统的总结一下Android事件分发的规律，其实用图来解释比较清楚，见参考资料。</p>
<a id="more"></a>
<h1 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h1><h2 id="涉及到事件响应的常用方法构成"><a href="#涉及到事件响应的常用方法构成" class="headerlink" title="涉及到事件响应的常用方法构成"></a>涉及到事件响应的常用方法构成</h2><ul>
<li>MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）</li>
<li>MotionEvent.ACTION_MOVE　：手指在屏幕上移动</li>
<li>MotionEvent.ACTION_UP　：手指离开屏幕瞬间</li>
<li>MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生</li>
</ul>
<p>Android中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。</p>
<p>android 事件响应机制是先分发（先由外部的View接收，然后依次传递给其内层的最小View）再处理（从最小View单元（事件源）开始依次向外层传递。）的形式实现的。</p>
<h2 id="涉及到的三个重要函数"><a href="#涉及到的三个重要函数" class="headerlink" title="涉及到的三个重要函数"></a>涉及到的三个重要函数</h2><h3 id="事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev"><a href="#事件分发：public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="事件分发：public boolean dispatchTouchEvent(MotionEvent ev)"></a>事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</h3><p>如果事件能够传递给当前View,那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级的View的dispatchTouchEvent方法的影响，表示是否消耗当前的事件。
　</p>
<h3 id="事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev"><a href="#事件拦截：public-boolean-onInterceptTouchEvent-MotionEvent-ev" class="headerlink" title="事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)"></a>事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</h3><p>该方法为ViewGroup独有。<br>在ViewGroup的dispatchTouchEvent内部调用，用来判断当前ViewGroup是否拦截事件，如果拦截，那么在同一个事件序列中，此方法不会被再次调用，返回结果表示是否拦截事件，默认不拦截。</p>
<h3 id="事件响应：public-boolean-onTouchEvent-MotionEvent-ev"><a href="#事件响应：public-boolean-onTouchEvent-MotionEvent-ev" class="headerlink" title="事件响应：public boolean onTouchEvent(MotionEvent ev)"></a>事件响应：public boolean onTouchEvent(MotionEvent ev)</h3><p>ViewGroup未实现，而是调用父类view的该方法。<br>在dispatchTouchEvent中调用，用来处理事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收事件。</p>
<h2 id="View分析"><a href="#View分析" class="headerlink" title="View分析"></a>View分析</h2><ul>
<li>触摸控件（View）首先执行dispatchTouchEvent方法。</li>
<li>在dispatchTouchEvent方法中先执行onTouch方法，后执行onClick方法（onClick方法在onTouchEvent中执行）。</li>
<li>如果控件（View）的onTouch返回false或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是enable的情况下会调用onTouchEvent，dispatchTouchEvent返回值与onTouchEvent返回一样。</li>
<li>如果控件不是enable的设置了onTouch方法也不会执行，只能通过重写控件的onTouchEvent方法处理，dispatchTouchEvent返回值与onTouchEvent返回一样。</li>
<li>如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。</li>
<li>当dispatchTouchEvent在进行事件分发的时候，只有前一个action返回true，才会触发下一个action（也就是说dispatchTouchEvent返回true才会进行下一次action派发）。</li>
<li>onTouchEvent方法中会在ACTION_UP分支中触发onClick的监听。</li>
</ul>
<h2 id="ViewGroup分析"><a href="#ViewGroup分析" class="headerlink" title="ViewGroup分析"></a>ViewGroup分析</h2><ul>
<li>Android事件派发是先传递到最顶级的ViewGroup，再由ViewGroup递归传递到View的。</li>
<li>在ViewGroup中可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。</li>
<li>子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。</li>
<li>ViewGroup没有重写View的onTouchEvent(MotionEvent event) 方法。</li>
</ul>
<h2 id="Activity分析"><a href="#Activity分析" class="headerlink" title="Activity分析"></a>Activity分析</h2><ul>
<li>首先会触发Activity的dispatchTouchEvent方法。</li>
<li>dispatchTouchEvent方法中如果是ACTION_DOWN的情况下会接着触发onUserInteraction方法。</li>
<li>接着在dispatchTouchEvent方法中会通过Activity的rootView（id为content的FrameLayout），实质是ViewGroup，通过super.dispatchTouchEvent把touchevent派发给各个activity的子view，也就是我们再Activity.onCreat方法中setContentView时设置的view。</li>
<li>若Activity下面的子view拦截了touchEvent事件(返回true)则Activity.onTouchEvent方法就不会执行。</li>
<li>onUserInteraction方法是一个空方法,此方法是activity的方法，当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法。下拉statubar、旋转屏幕、锁屏不会触发此方法。所以它会用在屏保应用上，因为当你触屏机器就会立马触发一个事件，而这个事件又不太明确是什么，正好屏保满足此需求；或者对于一个Activity，控制多长时间没有用户点响应的时候，自己消失等。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>如果我们没有对控件里面的方法进行重写或更改返回值，而直接用super调用父类的默认实现，那么整个事件流向应该是从Activity—-&gt;ViewGroup—&gt;View从上往下调用dispatchTouchEvent方法，一直到叶子节点（View）的时候，再由View—&gt;ViewGroup—&gt;Activity从下往上调用onTouchEvent方法。<br><img src="http://ob5qdb9lc.bkt.clouddn.com/966283-d01a5845f742609712.png" alt="Image"></li>
<li>dispatchTouchEvent 和 onTouchEvent 一旦return true,事件就停止传递了，对于return true我们经常说事件被消费了，消费了的意思就是事件走到这里就是终点，不会往下传，没有谁能再收到这个事件了。</li>
<li>dispatchTouchEvent 和 onTouchEvent return false的时候事件都回传给父控件的onTouchEvent处理。事件停止往子View传递和分发同时开始往父控件回溯（父控件的onTouchEvent开始从下往上回传直到某个onTouchEvent return true），事件分发机制就像递归，return false 的意义就是递归停止然后开始回溯。</li>
<li>对于onTouchEvent return false 就比较简单了，它就是不消费事件，并让事件继续往父控件的方向从下往上流动。</li>
<li>dispatchTouchEvent、onTouchEvent、onInterceptTouchEvent<br>ViewGroup 和View的这些方法的默认实现就是会让整个事件安装U型完整走完，所以 return super.xxxxxx() 就会让事件依照U型的方向的完整走完整个事件流动路径），中间不做任何改动，不回溯、不终止，每个环节都走到。</li>
</ul>
<h2 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent"></a>onInterceptTouchEvent</h2><ul>
<li>Intercept 的意思就是拦截，每个ViewGroup每次在做分发的时候，问一问拦截器要不要拦截（也就是问问自己这个事件要不要自己来处理）如果要自己处理那就在onInterceptTouchEvent方法中 return true就会交给自己的onTouchEvent的处理，如果不拦截就是继续往子控件往下传。</li>
<li>默认是不会去拦截的，因为子View也需要这个事件，所以onInterceptTouchEvent拦截器return super.onInterceptTouchEvent()和return false是一样的，是不会拦截的，事件会继续往子View的dispatchTouchEvent传递。</li>
</ul>
<h2 id="ViewGroup的dispatchTouchEvent"><a href="#ViewGroup的dispatchTouchEvent" class="headerlink" title="ViewGroup的dispatchTouchEvent"></a>ViewGroup的dispatchTouchEvent</h2><ul>
<li>return true是终结传递。return false 是回溯到父View的onTouchEvent。</li>
<li>通过Interceptor把事件拦截下来给自己的onTouchEvent</li>
<li>ViewGroup dispatchTouchEvent方法的super默认实现就是去调用onInterceptTouchEvent。</li>
</ul>
<h2 id="View的dispatchTouchEvent"><a href="#View的dispatchTouchEvent" class="headerlink" title="View的dispatchTouchEvent"></a>View的dispatchTouchEvent</h2><ul>
<li>View类的dispatchTouchEvent（）方法默认实现就是能帮你调用View自己的onTouchEvent方法的。</li>
</ul>
<h2 id="ViewGroup和View的onTouchEvent"><a href="#ViewGroup和View的onTouchEvent" class="headerlink" title="ViewGroup和View的onTouchEvent"></a>ViewGroup和View的onTouchEvent</h2><ul>
<li>自己消费掉，事件终结，不再传给谁—–&gt;return true;</li>
<li>继续从下往上传，不消费事件，让父View也能收到到这个事件—–&gt;return false;View的默认实现是不消费的。所以super==false。</li>
</ul>
<h2 id="ACTION-MOVE-和-ACTION-UP"><a href="#ACTION-MOVE-和-ACTION-UP" class="headerlink" title="ACTION_MOVE 和 ACTION_UP"></a>ACTION_MOVE 和 ACTION_UP</h2><ul>
<li>ACTION_DOWN事件在哪个控件消费了（return true）， 那么ACTION_MOVE和ACTION_UP就会从上往下（通过dispatchTouchEvent）做事件分发往下传，就只会传到这个控件，不会继续往下传</li>
<li>如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</li>
</ul>
<h2 id="滑动冲突的解决办法"><a href="#滑动冲突的解决办法" class="headerlink" title="滑动冲突的解决办法"></a>滑动冲突的解决办法</h2><h3 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h3><p>点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截。需要重写父容器的onInterceptTouchEvent方法。</p>
<h3 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h3><p>父容器不拦截任何事件，所有事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器处理。需要重写子View的dispatchTouchEvent方法。</p>
<p>参考资料：<br><a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解 Android 事件分发机制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们一般通过点击和滑动屏幕给应用下达指令，应用就会响应并做出相应的处理。这其中经历了一段怎样的过程？&lt;br&gt;Android事件分发机制总的来说就是先分发再处理，是责任链模式的运用，其处理过程中有很多细节，所以相关的代码很长。&lt;br&gt;这里笼统的总结一下Android事件分发的规律，其实用图来解释比较清楚，见参考资料。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android系统" scheme="http://yoursite.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="View事件分发机制" scheme="http://yoursite.com/tags/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Handler机制</title>
    <link href="http://yoursite.com/2016/08/10/Android%E7%AC%94%E8%AE%B0-Handler%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/08/10/Android笔记-Handler机制/</id>
    <published>2016-08-10T11:37:00.000Z</published>
    <updated>2016-09-02T13:56:06.495Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发中多线程是随处都可以见到的，Android系统提供了Handler机制来处理线程间信息的交换。<br>实际上，当一个应用启动时，就会在当前进程的主线程里建立一个消息循环，好确保主线程的存活并源源不断地处理任务。<br>Android 系统为我们提供了 Looper，Handler，MessageQueue 来实现线程任务模型。<br>总结一下Android系统中的Handler机制。</p>
<a id="more"></a>
<h1 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h1><p>Hnadler机制其实从某种意义上而言，是基于生产者-消费者模式展开的。<br>如UI线程就是消费者，在其他线程（生产者）上通过 Handler 将要执行的Callback ，迁移到UI线程上执行。</p>
<p>生产者（Work thread）需要将任务提交给缓冲区(MessageQueue)，而这个提交工作是由 post(Runnable runable) 或者 postDelayed(Runnable r, long delayMillis) 等post方法来执行。而消费者（UI thread）通过 looper 不断地从 MessageQueue 中取出任务再执行。</p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>生成和消费的内容就是Message。<br>Message部分代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * User-defined message code so that the recipient can identify</div><div class="line"> * what this message is about. Each &#123;<span class="doctag">@link</span> Handler&#125; has its own name-space</div><div class="line"> * for message codes, so you do not need to worry about yours conflicting</div><div class="line"> * with other handlers.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * arg1 and arg2 are lower-cost alternatives to using</div><div class="line"> * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</div><div class="line"> * few integer values.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * arg1 and arg2 are lower-cost alternatives to using</div><div class="line"> * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</div><div class="line"> * few integer values.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line"><span class="comment">/*package*/</span> Bundle data;</div><div class="line"></div><div class="line"><span class="comment">/*package*/</span> Handler target;</div><div class="line"></div><div class="line"><span class="comment">/*package*/</span> Runnable callback;</div><div class="line"></div><div class="line"><span class="comment">// sometimes we store linked lists of these things</span></div><div class="line"><span class="comment">/*package*/</span> Message next;</div></pre></td></tr></table></figure></p>
<ul>
<li>Message是实现了Parcelable序列化接口的。</li>
<li>what标明 Message 的类型 Id，调用者可以通过这个 what 做出相应的逻辑调整。</li>
<li>arg1 arg2 以及后面的 object 是用作额外数据传输的。</li>
<li>target 则定义了是哪一个消费者来处理哪一个 callback。因为一个 LooperThread 是允许存在多个 Handler 的，也就是多个消费者，而这些消息都被放置到一个 MessageQueue 队列中，target 就起到了区别它们的目的。callback 即实际要执行的东西。</li>
<li>Message 同时提供了 obtain() 方法，不推荐使用 new Message() 的方法，而是重复回收利用 Message，和 ThreadPool 的原理类似。</li>
</ul>
<h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MessageQueue就是存放Message的缓冲区，Android Framework 对其做了一些 JNI 的调用，来进行一些保护。<br>它是线程安全的，并提供了 Message next() 和 boolean enqueueMessage(Message msg, long when) 接口。<br>内部结构其实是单链表，单链表在插入和删除上比较有优势。</p>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/IC709523.png" alt="Image"></p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>Looper 主要负责的工作是从 MessageQueue 中取出要执行的任务，也就是维护一个消息循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//This is a typical example of the implementation of a Looper thread</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> Handler mHandler;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Looper.prepare();</div><div class="line"></div><div class="line">       mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                <span class="comment">// process incoming messages here</span></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Looper.loop();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Looper源码给出了Looper运作的示例(在Looper源码注释中)。</p>
<p>通过Looper.prepare()进行相应的初始化工作，而Looper.loop()则正式开启消息循环。简单来说，Looper 使得一个普通的线程具备了消息循环的能力，也就是获取信息并消费的能力。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure><br> Looper.prepare()检查Looper是否创建，并保证其全局唯一性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;  </div><div class="line">        <span class="comment">//不断循环校验Message是否为空，不为空就派发消息</span></div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>首先检查Looper创建，如果没有就抛出异常。</p>
<p>进入消息循环，不断地从MessageQueue中获取要处理的消息，并通过方法进行消息派发。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msg.target.dispatchMessage(msg)</div></pre></td></tr></table></figure></p>
<p>loop方法会调用MessageQueue的next方法来获得信息，而next是一个阻塞操作，当没有消息，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里。</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler 在系统中承担的角色较为复杂，可是当做是全局的操作者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Handler 必须依附于相应的Looper线程，如果线程没有Looper 或者 Looper 没有调用 prepare 方法，会抛出new RuntimeException(“Can’t create handler inside thread that has not called Looper.prepare()”)的异常。</p>
<p>在这个构造函数里，赋值相应的 MessageQueue 和 callback。</p>
<p>callback即在 Looper Thread 要执行的任务，一般情况可以是在其他线程耗时操作执行完成后，回到Looper Thread 上要执行的UI 更新操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Callback interface you can use when instantiating a Handler to avoid</div><div class="line"> * having to implement your own subclass of Handler.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</div><div class="line"> * <span class="doctag">@return</span> True if no further handling is desired</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Handler 通过 post，postDelayed 等等方法，来将相应的 Message 发送到消息队列中去，最后通过 sendMessageAtTime() 来进行发送，进行的工作特别简单，将 Message.target 指定为自己，同时将自己加入到队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="机制总结"><a href="#机制总结" class="headerlink" title="机制总结"></a>机制总结</h2><ul>
<li>Handler 消息处理者<br>它主要有两大作用：① 处理Message。② 发送Message，并将某个Message压入到MessageQueue中。</li>
<li>Looper 轮询器<br>在 Looper里面的 loop()函数中有个死循环,它不断地从 MessageQueue 中取出一个Message,然后传给Handler进行处理,如此循环往复。假如队列为空,那么它会进入休眠。</li>
<li>MessageQueue 消息队列<br>消息队列中含有多个Message，每个Message中包含了具体的调用信息。</li>
<li>在每一个Application启动的时候，会给这个Application分配一个 ActivityThread ，就是我们所说的UI 线程。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android开发中多线程是随处都可以见到的，Android系统提供了Handler机制来处理线程间信息的交换。&lt;br&gt;实际上，当一个应用启动时，就会在当前进程的主线程里建立一个消息循环，好确保主线程的存活并源源不断地处理任务。&lt;br&gt;Android 系统为我们提供了 Looper，Handler，MessageQueue 来实现线程任务模型。&lt;br&gt;总结一下Android系统中的Handler机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android系统" scheme="http://yoursite.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Handler机制" scheme="http://yoursite.com/tags/Handler%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记-Intent和Binder</title>
    <link href="http://yoursite.com/2016/08/09/Android%E7%AC%94%E8%AE%B0-Intent%E5%92%8CBinder/"/>
    <id>http://yoursite.com/2016/08/09/Android笔记-Intent和Binder/</id>
    <published>2016-08-09T13:32:49.000Z</published>
    <updated>2016-08-31T06:26:36.145Z</updated>
    
    <content type="html"><![CDATA[<p>Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。Intent相当于组件通讯的媒介。<br>Binder是Android 系统进程间通信(IPC)方式之一。当应用启动时就会启动一个Binder线程池。Linux已经拥有管道,socket等IPC 手段,却还要倚赖Binder来实现进程间通信,说明Binder具有无可比拟的优势。<br>这里总结一下Intent的使用和解析，和Binder基本模型(Binder太复杂，还没理解透)。</p>
<a id="more"></a>
<h1 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h1><p>Intent 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p>
<ul>
<li>启动 Activity</li>
<li>启动服务</li>
<li>发送广播</li>
</ul>
<h2 id="Intent-类型"><a href="#Intent-类型" class="headerlink" title="Intent 类型"></a>Intent 类型</h2><p>Intent 分为两种类型：</p>
<ol>
<li>显式 Intent ：按名称（完全限定类名）指定要启动的组件。通常，您会在自己的应用中使用显式 Intent 来启动组件，这是因为您知道要启动的 Activity 或服务的类名。例如，启动新 Activity 以响应用户操作，或者启动服务以在后台下载文件。</li>
<li>隐式 Intent ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理它。例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。</li>
</ol>
<p>创建显式 Intent 启动 Activity 或服务时，系统将立即启动 Intent 对象中指定的应用组件。</p>
<p>创建隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent 过滤器进行比较，从而找到要启动的相应组件。Intent如果 Intent 与 Intent 过滤器匹配，则系统将启动该组件，并将其传递给对象。如果多个 Intent 过滤器兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</p>
<p>为了确保应用的安全性，启动 Service 时，请始终使用显式 Intent，且不要为服务声明 Intent 过滤器。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 bindService()，系统会抛出异常。</p>
<h2 id="构建-Intent"><a href="#构建-Intent" class="headerlink" title="构建 Intent"></a>构建 Intent</h2><p>Intent 对象携带了 Android 系统用来确定要启动哪个组件的信息（例如，准确的组件名称或应当接收该 Intent 的组件类别），以及收件人组件为了正确执行操作而使用的信息（例如，要采取的操作以及要处理的数据）。</p>
<p>Intent 中包含的主要信息如下：</p>
<h3 id="组件名称"><a href="#组件名称" class="headerlink" title="组件名称"></a>组件名称</h3><p>要启动的组件名称。这是可选项，但也是构建显式 Intent 的一项重要信息，这意味着 Intent 应当仅传递给由组件名称定义的应用组件。如果没有组件名称，则 Intent 是隐式的，且系统将根据其他 Intent 信息（例如，以下所述的操作、数据和类别）决定哪个组件应当接收 Intent。因此，如需在应用中启动特定的组件，则应指定该组件的名称。</p>
<h3 id="操作-action"><a href="#操作-action" class="headerlink" title="操作(action)"></a>操作(action)</h3><p>指定要执行的通用操作（例如，“ACTION_VIEW”或“ACTION_SEND”）的字符串。对于广播 Intent，这是指已发生且正在报告的操作。操作在很大程度上决定了其余 Intent 的构成，特别是数据和 extra 中包含的内容。</p>
<h3 id="数据-data"><a href="#数据-data" class="headerlink" title="数据(data)"></a>数据(data)</h3><p>引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。提供的数据类型通常由 Intent 的操作决定。例如，如果操作是 ACTION_EDIT，则数据应包含待编辑文档的 URI。</p>
<p>要仅设置数据 URI，请调用 setData()。要仅设置 MIME 类型，请调用 setType()。如有必要，可以使用 setDataAndType() 同时显式设置二者。</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>一个包含应处理 Intent 组件类型的附加信息的字符串。您可以将任意数量的类别描述放入一个 Intent 中，但大多数 Intent 均不需要类别。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CATEGORY_BROWSABLE</div></pre></td></tr></table></figure><br>目标 Activity 允许本身通过 Web 浏览器启动，以显示链接引用的数据，如图像或电子邮件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CATEGORY_LAUNCHER</div></pre></td></tr></table></figure><br>该 Activity 是任务的初始 Activity，在系统的应用启动器中列出。</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的附加数据。</p>
<p>您可以使用各种 putExtra() 方法添加附加数据，每种方法均接受两个参数：键名和值。您还可以创建一个包含所有附加数据的 Bundle 对象，然后使用 putExtras() 将 Bundle 插入 Intent 中。</p>
<p>例如，使用 ACTION_SEND创建用于发送电子邮件的 Intent 时，可以使用 EXTRA_EMAIL 键指定“目标”收件人，并使用 EXTRA_SUBJECT 键指定“主题”。</p>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>在 Intent 类中定义的、充当 Intent 元数据的标志。标志可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个 任务 ），以及启动之后如何处理（例如，它是否属于最近的 Activity 列表）。</p>
<h2 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h2><p>要公布应用可以接收哪些隐式 Intent，请在清单文件中使用 <intent-filter> 元素为每个应用组件声明一个或多个 Intent 过滤器。每个 Intent 过滤器均根据 Intent 的操作、数据和类别指定自身接受的 Intent 类型。仅当隐式 Intent 可以通过 Intent 过滤器之一传递时，系统才会将该 Intent 传递给应用组件。</intent-filter></p>
<p>应用组件应当为自身可执行的每个独特作业声明单独的过滤器。例如，图像库应用中的一个 Activity 可能会有两个过滤器，分别用于查看图像和编辑图像。 当 Activity 启动时，它将检查 Intent 并根据 Intent 中的信息决定具体的行为（例如，是否显示编辑器控件）。每个 Intent 过滤器均由应用清单文件中的 &lt; intent-filter &gt; 元素定义，并嵌套在相应的应用组件（例如，&lt; activity &gt; 元素）中。在 &lt; intent-filter &gt; 内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p>
<h3 id="lt-action-gt"><a href="#lt-action-gt" class="headerlink" title="&lt; action &gt;"></a>&lt; action &gt;</h3><p>在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。</p>
<h3 id="lt-data-gt"><a href="#lt-data-gt" class="headerlink" title="&lt; data &gt;"></a>&lt; data &gt;</h3><p>使用一个或多个指定 数据 URI（scheme、host、port、path 等）各个方面和 MIME 类型的属性，声明接受的数据类型。</p>
<h3 id="lt-category-gt"><a href="#lt-category-gt" class="headerlink" title="&lt; category &gt;"></a>&lt; category &gt;</h3><p>在 name 属性中，声明接受的 Intent 类别。该值必须是操作的文本字符串值，而不是类常量。</p>
<p>注意：为了接收隐式 Intent，必须将 CATEGORY_DEFAULT 类别包括在 Intent 过滤器中。方法 startActivity() 和 startActivityForResult() 将按照已申明 [CATEGORY_DEFAULT]) 类别的方式处理所有 Intent。 如果未在 Intent 过滤器中声明此类别，则隐式 Intent 不会解析为你的 Activity。</p>
<h2 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h2><p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是从应用本身的进程中执行的一样。</p>
<p>待定 Intent 的主要用例包括：</p>
<ul>
<li>声明用户使用您的通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li>
<li>声明用户使用您的应用小工具执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li>
<li>声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。</li>
</ul>
<p>由于每个 Intent 对象均设计为由特定类型的应用组件进行处理（Activity、Service 或 BroadcastReceiver），因此还必须基于相同的考虑因素创建PendingIntent。</p>
<p>使用待定 Intent 时，应用不会使用调用（如 startActivity()）执行该 Intent。相反，通过调用相应的创建器方法创建 PendingIntent时，必须声明所需的组件类型：</p>
<ul>
<li>PendingIntent.getActivity()，适用于启动 Activity 的 Intent。</li>
<li>PendingIntent.getService()，适用于启动 Service 的 Intent。</li>
<li>PendingIntent.getBroadcast()，适用于启动 BroadcastReceiver 的 Intent。</li>
</ul>
<h2 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h2><p>当系统收到隐式 Intent 以启动 Activity 时，它根据以下三个方面将该 Intent 与 Intent 过滤器进行比较，搜索该 Intent 的最佳 Activity：</p>
<ul>
<li>Intent 操作</li>
<li>Intent 数据（URI 和数据类型）</li>
<li>Intent 类别</li>
</ul>
<h3 id="操作测试-Action-Test"><a href="#操作测试-Action-Test" class="headerlink" title="操作测试(Action Test)"></a>操作测试(Action Test)</h3><ul>
<li>要指定接受的 Intent 操作， Intent 过滤器既可以不声明任何 &lt; action &gt; 元素，也可以声明多个此类元素。</li>
<li>要通过此过滤器，Intent 中指定的操作必须与过滤器中列出的某一操作匹配。</li>
<li>如果该过滤器未列出任何操作，则 Intent 没有任何匹配项，因此所有 Intent 均无法通过测试。</li>
</ul>
<p>总结：Action匹配规则要求Intent中的action存在且必须和过滤规则中其中一个action相同。</p>
<h3 id="类别测试-Category-Test"><a href="#类别测试-Category-Test" class="headerlink" title="类别测试(Category Test)"></a>类别测试(Category Test)</h3><ul>
<li>要指定接受的 Intent 类别， Intent 过滤器既可以不声明任何 &lt; category &gt;元素，也可以声明多个此类元素。</li>
<li>若要 Intent 通过类别测试，则 Intent 中的每个类别均必须与过滤器中的类别匹配。</li>
<li>反之则未必然，Intent 过滤器声明的类别可以超出 Intent 中指定的数量，且 Intent仍会通过测试。</li>
<li>因此，不含类别的 Intent 应当始终会通过此测试，无论过滤器中声明何种类别均是如此。</li>
<li>Android 会自动将 CATEGORY_DEFAULT 类别传递给 startActivity()<br>和 startActivityForResult() 的所有隐式 Intent。因此，如需 Activity 接收隐式 Intent，则必须 “android.intent.category.DEFAULT” 的类别包括在其 Intent 过滤器中。</li>
</ul>
<p>总结：Intent中可以没有category,但是如果有category,不管有几个，每个都要能够和过滤规则中任何一个category对应。</p>
<h3 id="数据测试-Data-Test"><a href="#数据测试-Data-Test" class="headerlink" title="数据测试(Data Test)"></a>数据测试(Data Test)</h3><ul>
<li>要指定接受的 Intent 数据， Intent 过滤器既可以不声明任何 &lt; data &gt; 元素，也可以声明多个此类元素。</li>
<li>数据测试会将 Intent 中的 URI 和 MIME 类型与过滤器中指定的 URI 和 MIME 类型进行比较。</li>
<li>仅当过滤器未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</li>
<li>对于包含 URI、但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与过滤器的 URI 格式匹配、且过滤器同样未指定 MIME 类型时，才会通过测试。</li>
<li>仅当过滤器列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型、但不含 URI 的 Intent 才会通过测试。</li>
<li>仅当 MIME 类型与过滤器中列出的类型匹配时，包含 URI 和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与过滤器中的 URI 匹配，或者如果 Intent 具有 content: 或 file: URI 且过滤器未指定 URI，则 Intent 会通过测试的 URI 部分。换而言之，如果过滤器仅列出 MIME 类型，则假定组件支持 content: 和 file: 数据。</li>
</ul>
<p>总结： data匹配规则和action类似，要求data数据能够完全匹配过滤规则中的某一个data。</p>
<h2 id="Android多进程"><a href="#Android多进程" class="headerlink" title="Android多进程"></a>Android多进程</h2><p>首先，在Android中使用多进程只有一种方法，那就是给四大组件在AndroidManifest中指定android：process属性。<br>也就是说我们无法给一个线程或者一个实体类指定运行时所在的进程。<br>当进程名以“：”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以“：”开头的进程属于全局进程，其他应用可以通过ShareUID方式可以和它跑在同一个进程中。</p>
<p>多线程带来的问题：所有运行在不同进程的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败，这也是多进程所带来的主要影响。一般情况会造成如下几个方面的问题：</p>
<ol>
<li>静态成员和单例模式完全失效；</li>
<li>线程同步机制完全失效；</li>
<li>SharePreferences的可靠性下降；</li>
<li>Application会多次创建。</li>
</ol>
<h1 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1><p>首先Binder是Android系统进程间通信(IPC)方式之一。</p>
<ul>
<li>Binder是实现IBinder接口的一个类；</li>
<li>从Android Framework角度来说，它是ServiceManager连接各种Manager(ActivityManagr、WindowManager)和相应ManagerSerivce的桥梁。</li>
<li>从应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService时，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或数据。</li>
</ul>
<p>除了Binder,Android还支持Socket，通过Socket也可以实现任意两个终端之间的通信，当然一个设备上两个进程通过Socket通信自然也是可以的。</p>
<p>Binder使用Client－Server通信方式。Binder框架定义了四个角色：Server,Client,ServiceManager以及Binder驱动。其中Server,Client,ServiceManager运行于用户空间，驱动运行于内核空间。Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信。</p>
<p>Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给ServiceManager，通知ServiceManager注册一个名字为XX的Binder，它位于Server中。</p>
<p>驱动为这个穿过进程边界的Binder创建位于内核中的实体结点以及ServiceManager对实体的引用，将名字以及新建的引用打包给ServiceManager。</p>
<p>ServiceManager收数据包后，从中取出名字和引用填入一张查找表中。但是一个Server若向ServiceManager注册自己Binder就必须通过0这个引用和ServiceManager的Binder通信。</p>
<p>Server向ServiceManager注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Clent也利用保留的0号引用向ServiceManager请求访问某个Binder：我申请名字叫XX的Binder的引用。</p>
<p>ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder引用，将该引用作为回复发送给发起请求的Client。</p>
<p>当然，不是所有的Binder都需要注册给ServiceManager广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。由于这个Binder没有向ServiceManager注册名字，所以是匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。</p>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>一个Binder服务器就是一个Binder类的对象。当创建一个Binder对象后，内部就会开启一个线程，这个线程用户接收binder驱动发送的消息，收到消息后，会执行相关的服务代码。</p>
<h2 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h2><p>当服务端成功创建一个Binder对象后，Binder驱动也会相应创建一个mRemote对象，该对象的类型也是Binder类，客户就可以借助这个mRemote对象来访问远程服务。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端要想访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binde对象的服务了。</p>
<p>客户是通过Binder驱动来调用服务端的相关服务。首先，在服务端创建一个Binder对象，接着客户端通过获取Binder驱动中Binder对象的引用来调用服务端的服务。在Binder机制中正是借着Binder驱动将不同进程间的组件bind(粘连)在一起，实现通信。</p>
<h1 id="Android跨进程通讯"><a href="#Android跨进程通讯" class="headerlink" title="Android跨进程通讯"></a>Android跨进程通讯</h1><p>Linux内核实际上没有从一个用户空间到另一个用户空间直接拷贝的函数，需要先用copy_from_user()拷贝到内核空间，再用copy_to_user()拷贝到另一个用户空间。为了实现用户空间到用户空间的拷贝，mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。</p>
<p>最底层的是Android的ashmen(Anonymous shared memory)机制，它负责辅助实现内存的分配，以及跨进程所需要的内存共享。AIDL(android interface definition language)对Binder的使用进行了封装，可以让开发者方便的进行方法的远程调用。Intent是最高一层的抽象，方便开发者进行常用的跨进程调用。</p>
<p>使用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次内存数据：一次从输入文件到共享内存区，另一次从共享内存到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域，而是保持共享区域，直到通信完成为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除内存映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<p>进程通讯方式:</p>
<ol>
<li>AIDL</li>
<li>Messenger(对AIDL进行了封装)</li>
<li>Broadcast</li>
<li>ContentProvider</li>
<li>Socket</li>
</ol>
<h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><p>AIDL实现进程间通信的流程分为客户端和服务端两个方面。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个接口即可。</p>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>客户端需要绑定服务端的Service，绑定成功后，将服务端返回Binder对抗性转化成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。Intent相当于组件通讯的媒介。&lt;br&gt;Binder是Android 系统进程间通信(IPC)方式之一。当应用启动时就会启动一个Binder线程池。Linux已经拥有管道,socket等IPC 手段,却还要倚赖Binder来实现进程间通信,说明Binder具有无可比拟的优势。&lt;br&gt;这里总结一下Intent的使用和解析，和Binder基本模型(Binder太复杂，还没理解透)。&lt;/p&gt;
    
    </summary>
    
      <category term="Android笔记" scheme="http://yoursite.com/categories/Android%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android系统" scheme="http://yoursite.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
