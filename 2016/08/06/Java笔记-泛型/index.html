<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Java笔记-泛型
  
</title>

<meta property="og:type" content="article">
<meta property="og:title" content="Java笔记-泛型">
<meta property="og:url" content="http://yoursite.com/2016/08/06/Java笔记-泛型/index.html">
<meta property="og:site_name" content="Be Level5 Coder">
<meta property="og:image" content="http://ob5qdb9lc.bkt.clouddn.com/ab659IR5y5OLk.jpg">
<meta property="og:updated_time" content="2016-08-07T11:08:33.006Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java笔记-泛型">
<meta name="twitter:image" content="http://ob5qdb9lc.bkt.clouddn.com/ab659IR5y5OLk.jpg">


  <link rel="alternative" href="/atom.xml" title="Be Level5 Coder" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">Be Level5 Coder</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">Be Level5 Coder</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">Sion</div>
        
      </div>
      
        <div class="avatar">
          
            <img src="http://ob5qdb9lc.bkt.clouddn.com/my_avatar.jpg">
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android笔记/">Android笔记</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java笔记/">Java笔记</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP笔记/">TCP/IP笔记</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统笔记/">操作系统笔记</a><span class="category-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">39</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/liaosiyang" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-Java笔记-泛型" class="article article-type-post">
  
    <h1 class="article-header">
      Java笔记-泛型
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2016-08-06
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java笔记/">Java笔记</a></li></ul>
	</span>


    
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
	</span>


  </div>
  <div class="article-entry">
    <p><img src="http://ob5qdb9lc.bkt.clouddn.com/ab659IR5y5OLk.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型是我们需要的程序设计手段。使用泛型机制编写的应用程序代码要比那些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。</p>
<h2 id="为什么要使用泛型"><a href="#为什么要使用泛型" class="headerlink" title="为什么要使用泛型"></a>为什么要使用泛型</h2><p>泛型程序设计意味着编写的代码可以被不同类型的对象所重用。在Java增加泛型类之前，泛型程序设计是用继承实现的。ArrayList类只维护一个Object引用的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span>&#123;   <span class="comment">//before generic classes</span></div><div class="line">  <span class="keyword">private</span> Object[] elementData;</div><div class="line">  ...</div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;...&#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这样的实现有两个问题。当获取一个值时必须进行强制类型转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList files=<span class="keyword">new</span> ArrayList();</div><div class="line">...</div><div class="line">String filename=(String)files.get(<span class="number">0</span>);</div></pre></td></tr></table></figure><br>此外，这里没有错误检查。可以向数组列表中添加任何类的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">files.add(<span class="keyword">new</span> File(<span class="string">"..."</span>));</div></pre></td></tr></table></figure><br>对于这个调用，编译和运行都不会出错。然而在其他地方，如果将get的结果强制转换为String类型，就会产生一个错误。</p>
<p>泛型提供了一个更好的解决方案：类型参数。ArrayList类有一个类型参数用来指示元素的类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; files=<span class="keyword">new</span> ArrayList&lt;String&gt;();</div></pre></td></tr></table></figure><br>类型参数的魅力在于：使得程序具有更好的可读性和安全性。</p>
<h2 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h2><p>一个泛型类就是具有一个或多个类型变量的类。下面是简单定义的Pair类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> T first;</div><div class="line">    <span class="keyword">private</span> T second;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;first=<span class="keyword">null</span>;second=<span class="keyword">null</span>;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span></span>&#123;<span class="keyword">this</span>.first=first;<span class="keyword">this</span>.second=second;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> a[a.length/<span class="number">2</span>];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">		 <span class="keyword">return</span> first;</div><div class="line">	 &#125;</div><div class="line"> 	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</div><div class="line">		 <span class="keyword">this</span>.first = first;</div><div class="line">	 &#125;</div><div class="line">	 <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</div><div class="line">		 <span class="keyword">return</span> second;</div><div class="line">	 &#125;</div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span> </span>&#123;</div><div class="line">		 <span class="keyword">this</span>.second = second;</div><div class="line">	 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Pair类引入了一个类型变量T，用&lt;&gt;括起来，并放在类名的后面。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个域和第二个域使用不同的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;</span>&#123;...&#125;</div></pre></td></tr></table></figure><br>类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> T first;</div></pre></td></tr></table></figure><br>在Java库中，使用变量E表示集合的元素类型，K和V分别表示表的关键字与值的类型。T(需要时还可以用临近的字母U和S)表示“任意类型”。</p>
<p>用具体的类型替换变量类型就可以实例化泛型实例，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt;</div></pre></td></tr></table></figure><br>泛型类可以看作普通类的工厂。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>实际上，还可以定义一个带有类型参数的简单方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</div><div class="line">      <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T getMiddle&lt;T...a&gt;</div><div class="line">       &#123;</div><div class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这个方法是在普通类中定义，而不是在泛型类中定义的。然而，这是一个泛型方法，注意，类型变量放在修饰符的后面，返回类型的前面。</p>
<p>泛型方法可以定义在普通类中，也可以定义在泛型类中。<br>当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String middle=ArrayAlg.&lt;String&gt;getMiddle&#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>&#125;;</div></pre></td></tr></table></figure><br>实际上方法调用可以省略<string>类型参数。编译器有足够的信息能推断出所调用的方法。它是names的类型与泛型类型T进行匹配并推断出T一定是String。也即是说，可以调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String middle=ArrayAlg.getMiddle(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</div></pre></td></tr></table></figure><br>几乎大多数情况下，对于泛型方法的类型引用没有问题。偶尔，编译器也会提示错误，eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> middle=ArrayAlg.getMiddle(<span class="number">3.14</span>,<span class="number">1729</span>,<span class="number">0</span>);</div></pre></td></tr></table></figure><br>错误信息会指出：解释这句代码有2种方法，而且这2种方法都是合法的。<br>简单的说，编译器将会自动打包参数为1个Double和2个Integer对象，而后寻找这些类的共同超类型。事实上，找到这2个类的超类型：Number和Comparable接口，其本身也是一个泛型类型。在这种情况下，可以采取的补救措施是将所有的参数写成double值。</string></p>
<h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>有时，类或方法需要对类型变量加以约束。eg:我们要计算数组中的最小元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</div><div class="line">       <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;</div><div class="line">           <span class="keyword">if</span>(a==<span class="keyword">null</span>||a.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">           T smallest=a[<span class="number">0</span>];</div><div class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)</div><div class="line">               <span class="keyword">if</span>(smallest.compareTo(a[i])&gt;<span class="number">0</span>) smallest=a[i];</div><div class="line">               retrun smallest;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>变量smallest类型为T，意味着它可以是任何一个类的对象。怎么才能确信T所属的类有compareTo方法呢？<br>解决这个问题的方案是将T限制为实现了Comparable接口(只含有一个方法compareTo的标准接口)的类。可以通过对类型变量T设置限定(bound)实现这一点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span>...</span></div></pre></td></tr></table></figure><br>为什么使用关键字extends而不是implements？毕竟，Comparable是一个接口。下面的符号：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;T extends BoundingType&gt;</div></pre></td></tr></table></figure><br>表示T应该是绑定类型的子类型。T和绑定类型可以是类，也可以是接口。选择关键字extends的原因是更接近子类的概念。<br>一个类型变量或通配符可以有多个限定，eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T extends Comparable &amp; Serializable</div></pre></td></tr></table></figure><br>限定类型用‘&amp;’分隔，而‘，’用来分隔类型变量。<br>在Java的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类作为限定，他必须是限定列表的第一个。</p>
<h2 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h2><p>虚拟机没有泛型类型对象——所有对象都属于普通类。</p>
<p>无论何时定义一个泛型类型，都自动提供一个相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为无限定类型(无限定类型用Object)。</p>
<p>eg：Pair<t>的原始类型如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></div><div class="line">&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123; first = <span class="keyword">null</span>; second = <span class="keyword">null</span>; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object second)</span> </span>&#123; <span class="keyword">this</span>.first = first;  <span class="keyword">this</span>.second = second; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> first; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> second; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span> </span>&#123; first = newValue; &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object newValue)</span> </span>&#123; second = newValue; &#125;</div><div class="line">   <span class="keyword">private</span> Object first;</div><div class="line">   <span class="keyword">private</span> Object second;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>因为T是一个无限定的变量，所以直接用Object替换。<br>在程序中可以包含不同类型的Pair，例如Pair<string>或Pair<greoriancalendar>。<br>原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object替换。</greoriancalendar></string></t></p>
<h3 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h3><p>当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。eg:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pair&lt;Employee&gt; buddies=...;</div><div class="line">Empolyee buddy=buddies.getFirst();</div></pre></td></tr></table></figure><br>擦除getFirst的返回类型后将返回Object类型。编译器自动插入Employee的强制类型转换。也就是说，编译器把这个方法调用翻译为2条虚拟机指令：</p>
<ol>
<li>对原始方法Pair.getFirst的调用。</li>
<li>将返回的Object类型强制转换为Employee类型。</li>
</ol>
<p>当存取一个泛型域时也要插入强制类型转换。假设Pair类的first域和second域都是公有的。表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Employee buddy=buddies.first;</div></pre></td></tr></table></figure><br>也会在结果字节码中插入强制类型转换。</p>
<h3 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h3><p>类型擦除也会出现在泛型方法中。通常认为下述的泛型方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt;<span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></div></pre></td></tr></table></figure><br>是一个完整的方法族，而擦除类型之后，只剩下一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Comparable[] a)</span></span></div></pre></td></tr></table></figure><br>注意，类型参数T已经被擦除了，只留下了限定类型Comparable<br>方法擦除带来两个复杂问题。下面示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt;</span></div><div class="line">&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span></div><div class="line">  &#123;</div><div class="line">     <span class="keyword">if</span>(second.compareTo(getFirst())&gt;=<span class="number">0</span>)</div><div class="line">       <span class="keyword">super</span>.setSecond(second);</div><div class="line">   &#125;</div><div class="line">       ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>一个日期区间是一对Date对象，并且需要覆盖这个方法来确保第二个值永远不小于第一个值。这个类擦除后变成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span></span></div><div class="line">&#123;</div><div class="line"> ...   </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>存在另外一个从Pair继承的setSecond方法，即<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span></div></pre></td></tr></table></figure><br>考虑下面的语句序列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DateInterval interval=<span class="keyword">new</span> DateInterval(...)</div><div class="line">Pair&lt;Date&gt; pair=interval;</div><div class="line">pair.setSecond(aDate);</div></pre></td></tr></table></figure><br>这里，希望对setSecond的调用具有多态性，并调用最合适的那个方法。由于Pair引用DateInterval对象，所以应该调用DateInterval.setSecond。问题在于类型擦除与多态发生了冲突。要解决这个问题，就需要在编译器在DateInterval类中生成一个桥方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span></div><div class="line">&#123;</div><div class="line">   setSecond((Date)second;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>变量pair已经声明为类型Pair<date>，并且这个类型只有一个简单的方法叫setSecond，即setSecond(Object)。虚拟机用pair引用的对象调用这个方法。这个对象是DateInterval类型的，因而将会调用DateInterval.setSecond(Object)方法。这个方法是合成的桥方法。它调用DateInterval.setSecond(Date)。</date></p>
<p>桥方法可能会变得十分奇怪。假设DateInterval方法也覆盖了getSecond方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getSecond</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> (Date)<span class="keyword">super</span>.getSecond().clone()</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>在擦除的类型中，有两个getSecond方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">Date <span class="title">getSecond</span><span class="params">()</span><span class="comment">//defined in DateInterval</span></span></div><div class="line">Object <span class="title">getSecond</span><span class="params">()</span> <span class="comment">//overrides the method defined in Pair to call the first method</span></div></pre></td></tr></table></figure><br>不能这样编写Java代码(在这里，具有相同参数类型的两个方法是不合法的)。它们都没有参数。但是，在虚拟机中，用参数类型和返回类型确定一个方法。因此，编译器可能产生两个仅返回类型不同的方法字节码，虚拟机能够正确地处理这一情况。</p>
<p>有关Java泛型转换的事实：</p>
<ul>
<li>虚拟机中没有泛型，只有普通类和方法。</li>
<li>所有的类型参数都用它们的限定类型替换。</li>
<li>桥方法被合成用来保持多态。</li>
<li>为保持类型安全性，必要时插入强制类型转换。</li>
</ul>
<h2 id="约束和局限性"><a href="#约束和局限性" class="headerlink" title="约束和局限性"></a>约束和局限性</h2><h3 id="不能用基本类型实例化类型参数。"><a href="#不能用基本类型实例化类型参数。" class="headerlink" title="不能用基本类型实例化类型参数。"></a>不能用基本类型实例化类型参数。</h3><p>原因是类型擦除。</p>
<h3 id="运行时类型查询值适用于原始类型。"><a href="#运行时类型查询值适用于原始类型。" class="headerlink" title="运行时类型查询值适用于原始类型。"></a>运行时类型查询值适用于原始类型。</h3><p>虚拟机中的对象总有 一个特定的非泛型类型因此，所有的类型查询只产生原始类型。getClass方法总是返回原始类型。eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; stringPair=...;</div><div class="line">Pair&lt;Employee&gt; employeePair=...;</div><div class="line"><span class="keyword">if</span>(String.getClass()==employeePair.getClass())<span class="comment">//they are equal</span></div></pre></td></tr></table></figure><br>其比较结果是true，这是因为两次getClass都将返回Pair.class；</p>
<h3 id="不能创建参数化类型数组"><a href="#不能创建参数化类型数组" class="headerlink" title="不能创建参数化类型数组"></a>不能创建参数化类型数组</h3><p>不能实例化参数化类型数组，eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt;[] table=<span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];<span class="comment">//error</span></div></pre></td></tr></table></figure><br>擦除之后，table[]的类型是Pair[]，可以把它转换为Object[]；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object[] object=table;</div></pre></td></tr></table></figure><br>数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个ArrayStoreException异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object[<span class="number">0</span>]=<span class="string">"HELLO"</span>; <span class="comment">//ERROR --component type is Pair</span></div></pre></td></tr></table></figure><br>不过对于泛型类型，擦除会使这种机制无效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object[<span class="number">0</span>]=<span class="keyword">new</span> Pair&lt;Employee&gt;();</div></pre></td></tr></table></figure><br>能够通过数组存储检查，不过仍会导致一个类型错误。出于这个原因，不允许创建参数化类型数组。<br>需要说明的是，只是不允许创建这个数组，而声明类型为Pair<string>[]的变量仍是合法的。不过不能用new Pair<string>[10]初始化这个变量。</string></string></p>
<h3 id="Varargs警告"><a href="#Varargs警告" class="headerlink" title="Varargs警告"></a>Varargs警告</h3><p>上一节了解到，Java不支持泛型类型的数组。这一节讨论一个相关问题：向参数个数可变的方法传递一个泛型类型的实例。<br>下面这个简单的方法，参数个数是可变的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collect&lt;T&gt; coll,T...ts)</span></span>&#123;</div><div class="line"> <span class="keyword">for</span>(t:ts)coll.add(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>实际上ts是一个数组，包含提供的所有实参。<br>现在考虑以下调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Collection&lt;Pair&lt;String&gt;&gt; table=...;</div><div class="line">Pair&lt;String&gt; pair1=...;</div><div class="line">Pair&lt;String&gt; pair2=...;</div><div class="line">addAll(table.pair1,pair2);</div></pre></td></tr></table></figure><br>为了调用这个方法，Java虚拟机必须建立一个Pair<string>数组，这就违反了前面的规则。不过，对于这种情况，规则有所放松，你只会得到一个警告，而不是错误。</string></p>
<p>可以采用两种方法来抑制这个警告，一种方法是包含addAll调用的方法增加标注@SuppressWarning(“unchecked”)。或者在Java SE 7中，还可以用@SafeVarargs直接标注addAll方法。</p>
<h3 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h3><p>不能使用相new T(…)，new T[…]或T.class这样的表达式中的类型变量。类型擦除将T改变成Object，而且，本意肯定不希望调用new Object()。但是，可以通过反射调用Class.newInstance方法构造泛型对象。<br>不能调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">first=T.class.newInstance(); <span class="comment">//error</span></div></pre></td></tr></table></figure><br>必须像下面这样设计API以便可以支配Class对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Public <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cl)</span></span>&#123;</div><div class="line">   <span class="keyword">try</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(c1.newInstance(),c1.newInstance());&#125;</div><div class="line">   <span class="keyword">catch</span>(Exception ex)&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这个方法可以按照下列方式调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; p=Pair.makePair(String.class);</div></pre></td></tr></table></figure><br>注意，Class类本身是泛型。例如，String.class是一个Class<string>的实例(事实上，它是唯一的实例)。因此，makePair方法能够推断出pair的类型。<br>不能构造一个泛型数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T[] a)&#123;</div><div class="line">    T[] mm=<span class="keyword">new</span> T[<span class="number">2</span>]...;      <span class="comment">//error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br>类型擦除会让这个方法永远构造Object[2]数组。</string></p>
<h3 id="泛型类的静态上下文中的类型变量无效"><a href="#泛型类的静态上下文中的类型变量无效" class="headerlink" title="泛型类的静态上下文中的类型变量无效"></a>泛型类的静态上下文中的类型变量无效</h3><p>不能在静态域或方法中引用类型变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> T singleInstance;<span class="comment">//error</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getSingleInstance</span><span class="params">()</span><span class="comment">//error</span></span></div><div class="line">   &#123;</div><div class="line">     <span class="keyword">if</span>(singleInstance==<span class="keyword">null</span>)</div><div class="line">     <span class="keyword">return</span> singleInstance;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>类型擦除后，只剩下SingleTon类，它只包含一个singleInstance域。因此，禁止使用带有类型变量的静态域和方法。</p>
<h3 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h3><p>既不能抛出也不能捕获泛型类对象。实际上，甚至泛型类扩展Throwable都是不合法的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;...&#125; <span class="comment">//error</span></div></pre></td></tr></table></figure><br>catch子句中不能使用类型变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(class&lt;T&gt; t)</span></span>&#123;</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    ...</div><div class="line"> &#125;<span class="keyword">catch</span>(T e)  <span class="comment">//error</span></div><div class="line">  &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>不过，在异常规范中使用类型变量是允许的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T <span class="comment">//ok</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">try</span>&#123;...&#125;</div><div class="line">   <span class="keyword">catch</span>(Throwable realCause)</div><div class="line"> &#123;   </div><div class="line">   t.initCause(realCause);</div><div class="line">   <span class="keyword">throw</span> t;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>可以消除对已检查异常的检查<br>Java异常处理的一个基本原则是：必须为所有已检查异常提供一个处理器。不过可以利用泛型消除这个限制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span>throw T</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">throw</span>(T) e;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>假设这个方法包装在类Block中，如果调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Block.&lt;RuntimeException&gt;throwAs(t);</div></pre></td></tr></table></figure><br>编译器就会认为t是一个未检查的异常。以下代码会把所以异常都转换为编译器所认为的未检查异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">   ...</div><div class="line">&#125;<span class="keyword">catch</span>(Throwable t)&#123;</div><div class="line">  Block.&lt;RuntimeException&gt;throwAs(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这有什么意义呢？正常情况下，你必须捕获线程run方法中的所有已检查的异常，把它们“包装”到未检查异常中，run方法声明就不抛出已检查异常。<br>通过使用泛型类、擦除和@SuppressWarnings标注，就能消除Java类型系统的部分基本限制。</p>
<h3 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h3><p>当泛型类型被擦除时，无法创建引发冲突的条件。eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> first.equals(value)&amp;&amp;second.equals(value);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>考虑一个Pair<string>。从概念上来讲，它有两个equals方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span>  <span class="comment">//defind in Pair&lt;T&gt;</span></span></div><div class="line"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span>  <span class="comment">//inherited form Object</span></div></pre></td></tr></table></figure><br>但是，直觉把我们引入歧途。方法擦除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> equals&lt;T&gt;</div></pre></td></tr></table></figure><br>就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span></span></div></pre></td></tr></table></figure><br>与Object.equals方法发生冲突。当然，补救的方法是重新命名引发错误的方法。<br>泛型规范说明还提到另外一个原则：“要想支持擦除的转换，就需要强制限制一个类或类型变量不能同时称为两个接口类型的子类，而这两个接口是同一接口的不同参数化。”eg：下述代码非法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt;</span>&#123;...&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendar</span> <span class="keyword">extends</span> <span class="title">Calendar</span> <span class="title">implment</span> <span class="title">Comparable</span>&lt;<span class="title">GregorianClendar</span>&gt;</span></div><div class="line">&#123;</div><div class="line">...                              <span class="comment">//error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br>GregoianCalenda会实现Comparable<calendar>和Comparable<gregoriancalendar>，这是同一接口的不同参数化。</gregoriancalendar></calendar></string></p>
<h2 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h2><p>考虑一个类和一个子类，如Employee和Manager。Pair<manager>是Pair<employee>的一个子类吗？答案是“不是！” 下面的代码不能编译成功：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Manager[] topHonchos=...;</div><div class="line">Pair&lt;Employee&gt; result=ArrayAlg.minmax(topHonchos); <span class="comment">//error</span></div></pre></td></tr></table></figure><br>minmax方法返回Pair<manager>，而不是Pair<employee>，并且这样的赋值是不合法的。<br>无论S和T有什么联系，通常，Pair<s>与Pair<t>没有什么联系。<br>泛型类可以扩展或实现其他泛型类。就这一点而言，与普通的类没有什么区别。例如，ArrayList<t>类实现List<t>接口。这意味着，一个ArrayList<manager>可以被转换为一个List<manager>。但是，一个ArrayList<manager>不是一个ArrayList<employee>或List<employee>。</employee></employee></manager></manager></manager></t></t></t></s></employee></manager></employee></manager></p>
<h2 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;? extends Employee&gt;</div></pre></td></tr></table></figure>    
<p>表示任何泛型Pair类型，它的类型参数是Employee的子类，如Pair<manager>，但不是Pair<string>。<br>假设要编写一个打印雇员对的方法，eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;Employee&gt; p)</span></span></div><div class="line">&#123;</div><div class="line">   Employee first=p.getFirst();</div><div class="line">   Employee second=p.getSeconde();</div><div class="line">   System.out.println(first.getName()+<span class="string">"and"</span>+second.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>正如前面讲到，不能将Pair<manager>传递给这个方法，这一点很受限制。解决的方法：使用通配符类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span></div></pre></td></tr></table></figure><br>类型Pair<manager>是Pair&lt;? extends Employee&gt;的子类型</manager></manager></string></manager></p>
<p>通配符的限定与类型变量限定十分类似，但是，还有一个附加的能力，即可以知道一个超类型指定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">? <span class="keyword">super</span> Manager</div></pre></td></tr></table></figure><br>这个通配符限制为Manager的所有超类型。</p>
<p>还可以使用无限定通配符，例如，Pair&lt;?&gt;，类型Pair&lt;?&gt;有方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">? getFirst()</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span></span></div></pre></td></tr></table></figure><br>etFirst的返回值只能赋值给一个Object.。setFirst方法不能调用，甚至不能用Object调用。Pair&lt;?&gt;和Pair本质的不同：可以用任意Object对象调用原始的Pair类的setObject方法。<br>为什么要使用这样脆弱的类型？它对于许多简单操作非常有用。例如，下面这个方法用来测试pair是否包含一个null引用，它不需要实际的类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> p.getFirst()=<span class="keyword">null</span>||p.getSecond()==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>通过将hasNulls转换为泛型方法，可以避免使用通配符类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;T&gt; p)</span></span></div></pre></td></tr></table></figure><br>但是，带有通配符的版本可读性更强。</p>
<h3 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h3><p>通配符不是类型变量。因此，不能在编写代码中使用“?”作为一种类型。下述代码非法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; p)</span></span>&#123;</div><div class="line">  ? t=p.getFirst;<span class="comment">//error</span></div><div class="line">  p.setFirse(p.getSecond);</div><div class="line">  p.setSecond(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>解决方案：我们可以写一个辅助方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span></span>&#123;</div><div class="line">  T t=p.getFirst;</div><div class="line">  p.setFirse(p.getSecond);</div><div class="line">  p.setSecond(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>现在swap可以调用swapHelper<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; p)</span></span>&#123;swapHelper(p);&#125;</div></pre></td></tr></table></figure><br>swapHelper参数T捕获通配符。它不知道是哪种类型的通配符，但是这是一个明确的类型，并且<t>swapHelper的定义只有在T指出类型时才有明确的含义。<br>通配符捕获只有在有许多限制的情况下才是合法的。编译器必须能够确信通配符表达的是单个、确定的类型。例如ArrayList<pair<t>&gt;中的T永远不能捕获ArrayList<pair<?>&gt;中的通配符。</pair<?></pair<t></t></p>
<h2 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h2><p>class类是泛型的。例如，String.class实际上是一个Class<string>类的对象(事实上，是唯一的对象)。<br>类型参数十分有用，这是因为它允许Clas<t>方法的返回类型更加具有针对性。</t></string></p>
<h3 id="使用Class参数进行类型匹配"><a href="#使用Class参数进行类型匹配" class="headerlink" title="使用Class参数进行类型匹配"></a>使用Class<t>参数进行类型匹配</t></h3><p>有时，匹配类型方法中的Class<t>参数的类型变量很有实用价值。eg:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; c)</span><span class="keyword">throws</span>           </span></div><div class="line">InstantiationException,IllegalAccessException</div><div class="line">&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(c.newInstance(),c.newInstance());</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">makePair(Employee.class)</div></pre></td></tr></table></figure><br>Employee.class是类型Class<employee>的一个对象。makePair方法的类型参数T同Employee匹配，并且编译器可以推断出这个方法将返回一个Pair<employee>。</employee></employee></t></p>
<h3 id="虚拟机中的泛型类型信息"><a href="#虚拟机中的泛型类型信息" class="headerlink" title="虚拟机中的泛型类型信息"></a>虚拟机中的泛型类型信息</h3><p>ava泛型的卓越特性之一是在虚拟机中泛型类型的擦除。擦除的类仍然保留一些泛型祖先的微弱记忆。例如，原始的Pai类知道源于泛型类Pair<t>，即使一个Pair类型的对象无法区分是由Pair<string>构造的还是由Pair<employee>构造的。<br>类似地，看一下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Comparable[] a)</span></span></div></pre></td></tr></table></figure><br>这是一个泛型方法的擦除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></div></pre></td></tr></table></figure><br>可以使用反射API来确定：</employee></string></t></p>
<ol>
<li>这个泛型方法有一个叫做T的类型参数</li>
<li>这个类型参数有一个子类型限定，其自身又是一个泛型类型</li>
<li>这个限定类型有一个通配符类型</li>
<li>这个通配符参数有一个超类型限定</li>
<li>这个泛型方法有一个泛型数组参数</li>
</ol>
<p>换句话说，需要重新构造实现者声明的泛型类以及方法中的所有内容。但是，不会知道对于特定的对象或方法调用，如何解释类型参数。</p>

  </div>
  <footer class="article-footer">
    

    

  </footer>
</article>


  <link rel="stylesheet" href="http://static.duoshuo.com/styles/embed.default.css?349d9313.css">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2016/08/06/Java笔记-泛型/" data-title="Java笔记-泛型" data-url="/2016/08/06/Java笔记-泛型/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
    var duoshuoQuery = {
      short_name: "SION"
    };
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';
      ds.async = true;
      ds.src = (document.location.protocol == 'https:'
        ? 'https:'
        : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->






          <div class="main-footer">
  
    © 2016 Be Level5 Coder - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
