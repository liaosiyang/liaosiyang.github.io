<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Java笔记-虚拟机类加载机制
  
</title>

<meta name="description" content="虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。总结一下虚拟机类加载的过程和类加载器相关知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java笔记-虚拟机类加载机制">
<meta property="og:url" content="http://yoursite.com/2016/08/04/Java笔记-虚拟机类加载机制/index.html">
<meta property="og:site_name" content="Be Level5 Coder">
<meta property="og:description" content="虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。总结一下虚拟机类加载的过程和类加载器相关知识。">
<meta property="og:image" content="http://ob5qdb9lc.bkt.clouddn.com/fc2d8dab-9a09-3c4a-bc16-83eac314aa51.jpg">
<meta property="og:image" content="http://ob5qdb9lc.bkt.clouddn.com/1345973537_4943.jpg">
<meta property="og:updated_time" content="2016-08-29T08:12:31.169Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java笔记-虚拟机类加载机制">
<meta name="twitter:description" content="虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。总结一下虚拟机类加载的过程和类加载器相关知识。">
<meta name="twitter:image" content="http://ob5qdb9lc.bkt.clouddn.com/fc2d8dab-9a09-3c4a-bc16-83eac314aa51.jpg">


  <link rel="alternative" href="/atom.xml" title="Be Level5 Coder" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">Be Level5 Coder</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">Be Level5 Coder</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">Sion</div>
        
      </div>
      
        <div class="avatar">
          
            <img src="http://ob5qdb9lc.bkt.clouddn.com/my_avatar.jpg">
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android笔记/">Android笔记</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java笔记/">Java笔记</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative笔记笔记/">ReactNative笔记笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP笔记/">TCP/IP笔记</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/其它/">其它</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统笔记/">操作系统笔记</a><span class="category-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android事件分发机制/">Android事件分发机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android内存泄漏/">Android内存泄漏</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android开发框架/">Android开发框架</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android性能优化/">Android性能优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android插件化/">Android插件化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android热补丁/">Android热补丁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android系统/">Android系统</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android进程保活/">Android进程保活</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dagger2/">Dagger2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataBinding/">DataBinding</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler机制/">Handler机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVP模式/">MVP模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactNative/">ReactNative</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reaml/">Reaml</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/">Retrofit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View绘制流程/">View绘制流程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/other/">other</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">40</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/liaosiyang" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-Java笔记-虚拟机类加载机制" class="article article-type-post">
  
    <h1 class="article-header">
      Java笔记-虚拟机类加载机制
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2016-08-04
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java笔记/">Java笔记</a></li></ul>
	</span>


    
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</span>


  </div>
  <div class="article-entry">
    <p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。<br>总结一下虚拟机类加载的过程和类加载器相关知识。</p>
<a id="more"></a>
<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><ul>
<li>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。</li>
</ul>
<p><img src="http://ob5qdb9lc.bkt.clouddn.com/fc2d8dab-9a09-3c4a-bc16-83eac314aa51.jpg" alt="image2"></p>
<ul>
<li>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。并且这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。</li>
<li>Java虚拟机规范并未约束什么情况下进行类加载的第一阶段：加载，这个可以交给虚拟机的具体实现在自由把握。但是对于初始化阶段，虚拟机规范则严格规定了有且只有5种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前开始)：<br><br>1.遇到new、getstatic、putstatic或者invokestatic这4个字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰，已在编译期把结果放入常量池的静态字段除外)的时候，以及调用一个类的静态方法的时候。<br><br>2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br><br>3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<br><br>4.当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会初始化主类。<br><br>5.当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>对于这个5种触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5中场景中的行为称为对一个类的主动引用。除此之外，任何引用类的方式都不会触发初始化，称为被动引用。</li>
<li>被动引用：<br><br>1.通过子类引用父类的静态字段，不会导致子类初始化。对于静态字段，只有直接定义这个字段的类才会初始化。<br><br>2.通过数组定义来引用类，不会触发此类的初始化。但会触发另外一个名为classloading.SuperClass的类初始化，它是由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。Java语言比C/C++相对安全就是因为这个类封装了数组元素的访问方法，而C/C++则直接翻译为对数组指针的移动。<br><br>3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。<br></li>
<li>接口的加载过程与类的加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器，用于初始化接口中所定义的成员变量。</clinit></li>
<li>接口与类的真正有所区别的是前面5中“有且仅有”需要开始初始化场景中的3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部完成初始化，只要在真正使用到父接口的时候(如引用接口中定义的常量)才会初始化。</li>
</ul>
<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h2><h3 id="加载阶段，虚拟机需要完成以下3件事情："><a href="#加载阶段，虚拟机需要完成以下3件事情：" class="headerlink" title="加载阶段，虚拟机需要完成以下3件事情："></a>加载阶段，虚拟机需要完成以下3件事情：</h3><ol>
<li>通过一个类的全限定名获得定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种访问入口。</li>
</ol>
<h3 id="通过一个类的全限定名获得定义此类的二进制字节流，并没有指明二进制字节流要从一个Class文件中获取。"><a href="#通过一个类的全限定名获得定义此类的二进制字节流，并没有指明二进制字节流要从一个Class文件中获取。" class="headerlink" title="通过一个类的全限定名获得定义此类的二进制字节流，并没有指明二进制字节流要从一个Class文件中获取。"></a>通过一个类的全限定名获得定义此类的二进制字节流，并没有指明二进制字节流要从一个Class文件中获取。</h3><ol>
<li>从ZIP包中读取，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，典型应用就是Applet。</li>
<li>运行期计算生成，这个场景使用得最多的就是动态代理技术,在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为”$Proxy”的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP引用，即由JSP文件生成对于的Class类。</li>
<li>从数据库中读取。例如有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ol>
<ul>
<li>相对于类加载的其他阶段，一个非数组类的加载阶段(准确地说，是加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过自定义的类加载器去控制字节流的获取方式(即重写一个类加载器的loadClass()方法)。</li>
</ul>
<h3 id="对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是有Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型-Element-Type，指的是数组去掉所有维度的类型-最终是要靠类加载器去创建，一个数组类的创建过程遵循以下规则："><a href="#对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是有Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型-Element-Type，指的是数组去掉所有维度的类型-最终是要靠类加载器去创建，一个数组类的创建过程遵循以下规则：" class="headerlink" title="对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是有Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型(Element Type，指的是数组去掉所有维度的类型)最终是要靠类加载器去创建，一个数组类的创建过程遵循以下规则："></a>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是有Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型(Element Type，指的是数组去掉所有维度的类型)最终是要靠类加载器去创建，一个数组类的创建过程遵循以下规则：</h3><ol>
<li>如果数组的组件类型(Component Type，指的是数组去掉一个维度的类型)是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组将在加载该组件类型的类加载器的类名称空间上被标识(一个类必须与类加载器一起确定唯一性)。</li>
<li>如果数组的组件类型不是引用类型(例如int[]数组)，Java虚拟机将会把数组标记为引导类加载器关联。</li>
<li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</li>
</ol>
<ul>
<li><p>类加载器完成，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。然后在内存中实例化一个java.lang.Class类的对象(并未明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面)，这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p>
</li>
<li><p>加载阶段与连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，任然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
</li>
</ul>
<h2 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h2><h3 id="验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。"><a href="#验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。" class="headerlink" title="验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。"></a>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</h3><ul>
<li>Java语言本身是相对安全的语言，使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但class文件不一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生class文件。在字节码语言层面，上述Java代码无法做到的事情都是可以实现的，至少语义上是可以表达的。虚拟机如果不检查输入的字节流对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</li>
</ul>
<h3 id="验证阶段大致会完成4个阶段的检验动作："><a href="#验证阶段大致会完成4个阶段的检验动作：" class="headerlink" title="验证阶段大致会完成4个阶段的检验动作："></a>验证阶段大致会完成4个阶段的检验动作：</h3><ul>
<li><p>文件格式验证：第一阶段要验证字节流是否复合class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：<br><br>1.是否以魔数0xCAFABABE开头<br><br>2.主、次版本号是否在当前虚拟机处理范围之内<br><br>3.常量池的常量是否有不被支持的常量类型<br><br>该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这个阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再操作字节流。</p>
</li>
<li><p>元数据验证：第二阶段是对字节码描述的信息进行语义分析，以保证其描述信息符合Java语言规范的要求。这一阶段可能包括的验证点如下：<br><br>1.这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)<br><br>2.这个类的父类是否继承了不允许被继承的类(被final修饰的类)<br><br>3.如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的方法<br><br>4.类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的final字段，或者出现不符合规则的方法重载)<br><br>第二阶段主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p>
</li>
<li><p>字节码验证：是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证该校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：<br><br>1.保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作数栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中<br><br>2.保证跳转指令不会跳到方法体以外的字节码指令上<br><br>3.保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，但是把父类对象赋值给子类数据类型，则是危险和不合法的<br></p>
</li>
<li><p>符号引用校验：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在第三个阶段——解析阶段中发生。符号引用校验可以看作是对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验，通常需要校验下列内容：<br><br>1.符号引用中通过字符串描述的全限定名是否能找到相应的类。<br><br>2.在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。<br><br>3.符号引用中的类、字段、方法的访问性是否可以被当前类访问。<br><br>符号引用验证的目的是保证解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类。对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要(因为对程序运行期没有影响)的阶段。</p>
</li>
</ul>
<h2 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a>3.准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。首先。这个时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次这里所说的初始值“通常情况”下是数据类型的零值。<br><br>假设一个类变量定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</div></pre></td></tr></table></figure><br>变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行Java方法，而把value赋值为123的putstatic指令是在编译后，存放在类构造器<clinit>()方法之中，所以把value赋值的动作是在初始化阶段才会执行。<br><br>如果类字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值。</clinit></p>
<h2 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h2><ul>
<li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在class文件中以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。</li>
<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的class文件格式中。</li>
<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li>
<li>虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行用于操作符号引用的字节码之前，先将它们所用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是要等到一个符号引用将要被使用前才去解析它。</li>
<li>对同一个符号引用进行多次解析请求是很常见的事情，除了invokedynamic指令以外，虚拟机实现可以对一次出解析的结构进行缓存(在运行时常量池记录直接引用，并把常量标识为已解析状态)从而避免解析动作重复进行。</li>
<li>对于invokedynamic指令，上面的规则不成立。当碰到某个前面已经由invokedynamic指令触发过解析的符号引用，并不意味着这个解析结构对于其他invokedynamic指令也同样生效。因为invokedynamic指令的目的本来就是用于动态语言支持，必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码就进行解析。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</li>
</ul>
<h3 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h3><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3步：<br></p>
<ol>
<li>如果C不是数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证。字节码验证的需要，又可能触发相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，那就会按照第一点的规则加载数组元素类型。接着由虚拟机生成一个代表此数组维度和元素的数组对象。</li>
<li>如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经称为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</li>
</ol>
<h3 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h3><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。<br></p>
<ol>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，则会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出java.lang.NoSuchFiledError异常。<br></li>
</ol>
<p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。<br><br>在实际应用中，虚拟机的编译器实现可能比上述规范要求更加严格一些，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。</p>
<h3 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h3><p>类方法解析的第一步骤与字段解析一样，也需要先解析出类方法表的class_index索引的方法所属的类或接口的符号引用，如果解析成功，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。<br></p>
<ol>
<li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatiableClassError异常。</li>
<li>如果通过了第一步，在类C中查找是否带有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchAccessError异常。<br></li>
</ol>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<h3 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h3><p>接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。</p>
<ol>
<li>与类的方法解析，如果在接口方法表中发现class_index中索引C是个类而不是接口，那就直接抛出java.lang.IncompatiableClassError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类(查找范围会包括Object类)为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchAccessError异常。<br></li>
</ol>
<p>由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。</p>
<h2 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h2><p>类初始化是类加载的最后一步，在前面的类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。<br><br>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器&lt; clinit &gt;()方法的过程。</p>
<ul>
<li>&lt; clinit &gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})中语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">  <span class="keyword">static</span>&#123;</div><div class="line">   i=<span class="number">0</span>;                          <span class="comment">//给变量赋值可以正常编译通过</span></div><div class="line">   System.out.println(i);        <span class="comment">//这句编译器会提示"非法向前引用"</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>        </li>
<li>&lt; clinit &gt;()方法与类的构造函数(或者说实例构造器&lt; init &gt;())不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的&lt; clinit &gt;()方法执行之前，父类的&lt; clinit &gt;()方法已经执行完毕。因此虚拟机中第一个被执行的&lt; clinit &gt;()方法的类肯定是java.lang.Object。</li>
<li>由于父类的&lt; clinit &gt;()方法先执行，也就意味着父类定义的静态语句块要优先于子类的变量赋值操作。</li>
<li>&lt; clinit &gt;()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt; clinit &gt;()方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt; clinit &gt;()方法。但接口与类不同的是，执行接口的&lt; clinit &gt;()方法方法不需要先执行父接口的&lt; clinit &gt;()方法。只有父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化的时候也一样不会执行接口的&lt; clinit &gt;()方法。</li>
<li>虚拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确地加锁、同步，如果多线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt; clinit &gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit &gt;()方法完毕。如果在一个类的&lt; clinit &gt;()方法中有耗时很长的操作，就可能造成多个进程阻塞(其他线程虽然会被阻塞，但如果执行&lt; clinit &gt;()方法的那条线程退出&lt; clinit &gt;()方法后，其他线程唤醒之后不会再次进入&lt; clinit &gt;()方法。同一个类加载器下，一个类型只会初始化一次)。</li>
</ul>
<h1 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h1><p>虚拟机设计团队把类加载阶段“通过一类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。<br><br>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要有加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。<br><br>比较两个类是否“相等”，只有这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。<br></p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一部分就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。<br><br>绝大部分Java程序都会使用以下3种系统提供的类加载器:</p>
<ul>
<li>启动类加载器：这个类加载器负责将存放在&lt; JAVA_HOME &gt;\lib目录中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时吗，如果需要把加载请求委派给引导类加载器，那就直接使用null代替即可。</li>
<li>扩展类加载器：这个加载器负责加载&lt; JAVA_HOME &gt;\lib\ext目录中的，开发者可以直接使用扩展类加载器。</li>
<li>应用程序加载器：这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下就是程序默认的类加载器。<br></li>
</ul>
<p>我们的应用程序都是由这3种类加载器互相配合进行加载的。这些类加载器之间的关系如图：<br><br><img src="http://ob5qdb9lc.bkt.clouddn.com/1345973537_4943.jpg" alt="image3"></p>
<ul>
<li>类加载器之间的这种层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而都是使用组合关系来复用父加载器的代码。</li>
<li>双亲委派模型的工作过程是：如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。</li>
<li>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。eg：类java.lang.Object，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类进行加载。因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系最基础的行为也就无法保证，应用程序也将会变得一片混乱。</li>
</ul>

  </div>
  <footer class="article-footer">
    

    

  </footer>
</article>


  <link rel="stylesheet" href="http://static.duoshuo.com/styles/embed.default.css?349d9313.css">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2016/08/04/Java笔记-虚拟机类加载机制/" data-title="Java笔记-虚拟机类加载机制" data-url="/2016/08/04/Java笔记-虚拟机类加载机制/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
    var duoshuoQuery = {
      short_name: "SION"
    };
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';
      ds.async = true;
      ds.src = (document.location.protocol == 'https:'
        ? 'https:'
        : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->






          <div class="main-footer">
  
    © 2016 Be Level5 Coder - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
