<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Java笔记-垃圾收集器与内存分配策略
  
</title>

<meta name="description" content="Java与C++之间最大的区别就是内存动态分配和垃圾收集技术，Java中的对象没人用的话会有垃圾收集器自动回收，让它滚蛋，一直都有用的话还会将它移动到富人区，让它活着更舒适，减少被垃圾收集器打扰的可能。(原来Java里的对象跟人活在现实世界一样残酷啊)对象的出生也是有高低贵贱的，大的对象可以直接入住富人区，而大多数的一开始就只能在贫民区，只能努力向富人区奋斗。总结一下Java世界里对象面临的残酷生">
<meta property="og:type" content="article">
<meta property="og:title" content="Java笔记-垃圾收集器与内存分配策略">
<meta property="og:url" content="http://yoursite.com/2016/08/03/Java笔记-垃圾收集器与内存分配策略/index.html">
<meta property="og:site_name" content="Be Level5 Coder">
<meta property="og:description" content="Java与C++之间最大的区别就是内存动态分配和垃圾收集技术，Java中的对象没人用的话会有垃圾收集器自动回收，让它滚蛋，一直都有用的话还会将它移动到富人区，让它活着更舒适，减少被垃圾收集器打扰的可能。(原来Java里的对象跟人活在现实世界一样残酷啊)对象的出生也是有高低贵贱的，大的对象可以直接入住富人区，而大多数的一开始就只能在贫民区，只能努力向富人区奋斗。总结一下Java世界里对象面临的残酷生">
<meta property="og:image" content="http://ob5qdb9lc.bkt.clouddn.com/1349278110_8410.jpg">
<meta property="og:updated_time" content="2016-08-29T08:54:02.844Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java笔记-垃圾收集器与内存分配策略">
<meta name="twitter:description" content="Java与C++之间最大的区别就是内存动态分配和垃圾收集技术，Java中的对象没人用的话会有垃圾收集器自动回收，让它滚蛋，一直都有用的话还会将它移动到富人区，让它活着更舒适，减少被垃圾收集器打扰的可能。(原来Java里的对象跟人活在现实世界一样残酷啊)对象的出生也是有高低贵贱的，大的对象可以直接入住富人区，而大多数的一开始就只能在贫民区，只能努力向富人区奋斗。总结一下Java世界里对象面临的残酷生">
<meta name="twitter:image" content="http://ob5qdb9lc.bkt.clouddn.com/1349278110_8410.jpg">


  <link rel="alternative" href="/atom.xml" title="Be Level5 Coder" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">Be Level5 Coder</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">Be Level5 Coder</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">Sion</div>
        
      </div>
      
        <div class="avatar">
          
            <img src="http://ob5qdb9lc.bkt.clouddn.com/my_avatar.jpg">
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android笔记/">Android笔记</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java笔记/">Java笔记</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative笔记笔记/">ReactNative笔记笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP笔记/">TCP/IP笔记</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/其它/">其它</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统笔记/">操作系统笔记</a><span class="category-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android内存泄漏/">Android内存泄漏</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android开发框架/">Android开发框架</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android性能优化/">Android性能优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android插件化/">Android插件化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android热补丁/">Android热补丁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android系统/">Android系统</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android进程保活/">Android进程保活</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dagger2/">Dagger2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataBinding/">DataBinding</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler机制/">Handler机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVP模式/">MVP模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactNative/">ReactNative</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reaml/">Reaml</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/">Retrofit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View事件分发机制/">View事件分发机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View绘制流程/">View绘制流程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/other/">other</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">40</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/liaosiyang" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-Java笔记-垃圾收集器与内存分配策略" class="article article-type-post">
  
    <h1 class="article-header">
      Java笔记-垃圾收集器与内存分配策略
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2016-08-03
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java笔记/">Java笔记</a></li></ul>
	</span>


    
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li></ul>
	</span>


  </div>
  <div class="article-entry">
    <p>Java与C++之间最大的区别就是内存动态分配和垃圾收集技术，Java中的对象没人用的话会有垃圾收集器自动回收，让它滚蛋，一直都有用的话还会将它移动到富人区，让它活着更舒适，减少被垃圾收集器打扰的可能。(原来Java里的对象跟人活在现实世界一样残酷啊)<br>对象的出生也是有高低贵贱的，大的对象可以直接入住富人区，而大多数的一开始就只能在贫民区，只能努力向富人区奋斗。<br>总结一下Java世界里对象面临的残酷生存法则，和那些如同恶魔般的垃圾收集器。</p>
<a id="more"></a>
<h1 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h1><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ul>
<li>给对象添加一个引用计数器，每当有一个地方引用它，计数器加1；当引用失效时，计时器减1。任何时刻计数器为0的对象就是不可能再被引用的。</li>
<li>引用计算算法实现简单，判断效率也很高，但是至少主流的Java虚拟机里面没有选用引用计数算法实现管理内存。主要原因是很难解决对象间相互循环引用的问题。</li>
</ul>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li>基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的。</li>
<li>可作为GC Roots的对象包括：<br><br>1.虚拟机栈(栈帧中的本地变量表)中引用的对象；<br><br>2.方法区中类静态属性引用的对象；<br><br>3.方法区中常量引用的对象；<br><br>4.本地方法栈JNI(即一般说的Native方法)引用的对象。<br></li>
</ul>
<h3 id="Java引用"><a href="#Java引用" class="headerlink" title="Java引用"></a>Java引用</h3><ul>
<li>强引用就是在程序代码之中普遍存在的，类似“Object obj=new Object()”这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用是用来描述一些还有用但非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类实现软引用。</li>
<li>弱引用也是用来描述非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类实现软引用。</li>
<li>虚引用也称为幽灵引用或者幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantReference类实现软引用。</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ul>
<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行finalize()(Object类中的方法)方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行”。</li>
<li>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后的一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。</li>
<li>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F—Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，那么在第二次标记时将会被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上就真的被回收了。</li>
<li>任何对象的finalize()方法只能被系统调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。</li>
</ul>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><ul>
<li>Java虚拟机规范确切说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的”性价比”一般比较低。</li>
<li>方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类。</li>
<li>回收废弃常量与回收Java堆中的对象非常类似。假如字符串”abc”进入了常量池，但是当前系统没有任何一个String对象引用”abc”，这个常量就被被系统清理出常量池。</li>
<li>类要满足3个条件才能算”无用的类”：<br><br>1.该类的所有实例都已经被回收；<br><br>2.加载该类的ClassLoader已经被回收；<br><br>3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
<li>虚拟机可以对满足上述3个条件的无用类进行回收，仅仅是“可以”，而并不是和对象一样，不使用了就必然会被回收。</li>
</ul>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h3 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h3><ul>
<li>首先标记出所以需要回收的对象，在标记完成后统一回收所有被标记的对象。</li>
<li>是最基础的收集算法，主要不足有两个：一个是效率问题，标记个清除两个过程的效率都不高；另一个是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能导致以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前进行触发另一次垃圾收集动作。</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><ul>
<li>为了解决效率问题，它可以将内存按容量划分大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用的内存空间一次清理掉。</li>
<li>现在的商业虚拟机都采用这种收集算法来回收新生代，研究表明，新生代中的对象98%是”朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间。</li>
<li>而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1。</li>
<li>当Survivor空间空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保。如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</li>
</ul>
<h3 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h3><ul>
<li>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率会变低，所以老年代一般不能选用这种算法。</li>
<li>根据老年代的特点，提出了一种”标记—整理”算法，过程与”标记—清除”算法一样，但后续步骤不是直接对可回收对象进行整理，而是让所有存活对象都向一端移动。</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul>
<li>根据对象存活周期的不同将内存划分为几块，一般把java堆分为新生代和老年代。新生代选用复制算法，老年代选用标记—清除算法或标记—整理算法。</li>
</ul>
<h1 id="垃圾收集算法的实现"><a href="#垃圾收集算法的实现" class="headerlink" title="垃圾收集算法的实现"></a>垃圾收集算法的实现</h1><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><ul>
<li>可作为GC Roots的节点主要在全局性的引用与执行上下文中。如果要逐个检查这里面的引用，必然会消耗很多时间。</li>
<li>可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个确保一致性的快照中进行。”一致性”的意思是整个分析期间整个执行系统看起来就想被冻结在某个时间点上，不可以出分析过程中对象引用关系还在不断变化的情况。这点是导致GC进行时必须停顿所有Java执行线程的一个重要原因。</li>
<li>目前主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿之后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。</li>
<li>在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量是什么类型的数据计算出来，在JIT(即时编译器)编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样在GC扫描的时候就可以直接得知这些信息了。</li>
</ul>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><ul>
<li>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</li>
<li>实际上HotSpot的确没有为每条指令都OopMap，只是在”特定的位置”记录了这些信息，这些位置称为安全点(SafePoint)，即程序执行时并非在所有的地方都能停顿下来开始GC，只有在到达安全点才能暂停。安全点的选择基本上是以程序”是否具有让程序长时间执行的特征”为标准选定的，例如方法调用、循环跳转、异常跳转等这些功能的指令才会产生SafePoint。</li>
<li>另一个需要考虑的问题是如何在GC发生时让所有线程(不包括执行JNI调用的线程)都”跑”到最近的安全点再停顿下来。两种方案可供选择：<br>1.抢先式中断:不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程让它跑到安全点上。现在几乎没有虚拟机实现此方案；<br>2.主动式中断:当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><ul>
<li>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是程序”不执行”的时候呢？线程出于Sleep或者Blocked状态，这时候线程无法响应JVM的中断请求。这种情况需要安全区域(Safe Region)来解决</li>
<li>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</li>
<li>在线程执行的Safe Region中的代码时，首先标识自己已经进入Safe Region，那样，当JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程离开Safe Region时，它要检查系统是否已经完成了根节点的枚举(或者是整个GC过程)，如果完成，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</li>
</ul>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>通常虚拟机中往往不止有一种GC收集器。<br><img src="http://ob5qdb9lc.bkt.clouddn.com/1349278110_8410.jpg" alt="image2"></p>
<h3 id="Serial-串行GC-收集器"><a href="#Serial-串行GC-收集器" class="headerlink" title="Serial(串行GC)收集器"></a>Serial(串行GC)收集器</h3><ul>
<li>Serial收集器是一个新生代收集器，单线程执行，使用复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是Jvm client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</li>
</ul>
<h3 id="ParNew-并行GC-收集器"><a href="#ParNew-并行GC-收集器" class="headerlink" title="ParNew(并行GC)收集器"></a>ParNew(并行GC)收集器</h3><ul>
<li>ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。</li>
</ul>
<h3 id="Parallel-Scavenge-并行回收GC-收集器"><a href="#Parallel-Scavenge-并行回收GC-收集器" class="headerlink" title="Parallel Scavenge(并行回收GC)收集器"></a>Parallel Scavenge(并行回收GC)收集器</h3><ul>
<li>Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。</li>
</ul>
<h3 id="Serial-Old-串行GC-收集器"><a href="#Serial-Old-串行GC-收集器" class="headerlink" title="Serial Old(串行GC)收集器"></a>Serial Old(串行GC)收集器</h3><ul>
<li>Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。</li>
</ul>
<h3 id="Parallel-Old-并行GC-收集器"><a href="#Parallel-Old-并行GC-收集器" class="headerlink" title="Parallel Old(并行GC)收集器"></a>Parallel Old(并行GC)收集器</h3><ul>
<li>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。</li>
</ul>
<h3 id="CMS-并发GC-收集器"><a href="#CMS-并发GC-收集器" class="headerlink" title="CMS(并发GC)收集器"></a>CMS(并发GC)收集器</h3><ul>
<li>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，整个收集过程大致分为4个步骤：<br>1.初始标记(CMS initial mark)<br>2.并发标记(CMS concurrenr mark)<br>3.重新标记(CMS remark)<br>4.并发清除(CMS concurrent sweep)</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ul>
<li>G1(Garbage First)收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。还有一个特点，之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆划分出多个大小相等的独立区域，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。</li>
</ul>
<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><p>Java技术体系所提倡的自动内存管理最终可以归结为自动化解决了两个问题：给对象分配内存以及回收分配给对象的内存。</p>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><ul>
<li>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</li>
<li>新生代GC(Minor GC)：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li>
<li>老年代GC(Major GC/Full GC)；指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GCM慢10倍以上。</li>
</ul>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul>
<li>所谓大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</li>
<li>大对象对虚拟机的内存分配就是一个坏消息，更坏的是朝生夕灭的大对象。</li>
</ul>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><ul>
<li>虚拟机给每个对象定义了一个对象年龄(Age)计数器。</li>
<li>如果对象在Eden初始化并经过第一次Minor GC后仍能存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象的年龄设为1。</li>
<li>对象在Survivor区每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认是15岁)，将会被晋升到老年代中。年龄阈值可以设置。</li>
</ul>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><ul>
<li>为了能更好适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到年龄阈值才能晋升老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。</li>
</ul>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul>
<li>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。</li>
<li>如果不成立，则虚拟机会查看设置是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的。如果小于，或者设置不允许冒险，这时也要改为进行一次Full GC。</li>
<li>冒险：新生代采用复制算法，但为了内存利用率，只使用了其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</li>
<li>进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一次有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次晋升到老年代对象的平均值大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</li>
<li>如果某次Minor GC存活后对象突增，远远高于平均值的话，依然会导致担保失败，如果出现担保失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是设置允许担保，避免Full GC过于频繁。</li>
</ul>

  </div>
  <footer class="article-footer">
    

    

  </footer>
</article>


  <link rel="stylesheet" href="http://static.duoshuo.com/styles/embed.default.css?349d9313.css">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2016/08/03/Java笔记-垃圾收集器与内存分配策略/" data-title="Java笔记-垃圾收集器与内存分配策略" data-url="/2016/08/03/Java笔记-垃圾收集器与内存分配策略/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
    var duoshuoQuery = {
      short_name: "SION"
    };
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';
      ds.async = true;
      ds.src = (document.location.protocol == 'https:'
        ? 'https:'
        : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->






          <div class="main-footer">
  
    © 2016 Be Level5 Coder - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
