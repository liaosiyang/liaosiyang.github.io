<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Java笔记-多线程
  
</title>

<meta property="og:type" content="article">
<meta property="og:title" content="Java笔记-多线程">
<meta property="og:url" content="http://yoursite.com/2016/08/07/Java笔记-多线程/index.html">
<meta property="og:site_name" content="Be Level5 Coder">
<meta property="og:image" content="http://ob5qdb9lc.bkt.clouddn.com/t01c8028393c3f209ad.jpg">
<meta property="og:updated_time" content="2016-08-07T13:04:01.425Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java笔记-多线程">
<meta name="twitter:image" content="http://ob5qdb9lc.bkt.clouddn.com/t01c8028393c3f209ad.jpg">


  <link rel="alternative" href="/atom.xml" title="Be Level5 Coder" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">Be Level5 Coder</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">Be Level5 Coder</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">Sion</div>
        
      </div>
      
        <div class="avatar">
          
            <img src="http://ob5qdb9lc.bkt.clouddn.com/my_avatar.jpg">
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android笔记/">Android笔记</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java笔记/">Java笔记</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/TCP-IP笔记/">TCP/IP笔记</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统笔记/">操作系统笔记</a><span class="category-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">32</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/liaosiyang" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-Java笔记-多线程" class="article article-type-post">
  
    <h1 class="article-header">
      Java笔记-多线程
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2016-08-07
</span>

    
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java笔记/">Java笔记</a></li></ul>
	</span>


    
	<span class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
	</span>


  </div>
  <div class="article-entry">
    <p><img src="http://ob5qdb9lc.bkt.clouddn.com/t01c8028393c3f209ad.jpg" alt="Image"></p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常，每一个任务称为一个线程，它是线程控制的简称，可以同时运行一个以上线程的程序称为多线程程序。</p>
<p>多进程与多线程区别：每一个进程拥有自己的一整套变量，而线程则共享数据。这是有风险的，但共享变量使线程之间的通信要比进程之间的通信更有效、更容易。此外，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小得多。</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>下面是在一个单独的线程执行一个任务的简单过程：</p>
<ol>
<li>将任务代码移到Runnable接口的类的run方法中，可以如下实现一个类：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    task code;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>创建一个类对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Runnable r=<span class="keyword">new</span> Runnable();</div></pre></td></tr></table></figure>  </li>
<li>由Runnable对象创建一个Thread对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread t=<span class="keyword">new</span> Thread(r);</div></pre></td></tr></table></figure>    </li>
<li>启动线程：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.start();</div></pre></td></tr></table></figure>   
</li>
</ol>
<p>不要调用Thread类或Runnable对象的Run方法。直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用Thread.start方法。这个方法将创建一个执行run方法的新线程。</p>
<h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>当线程的run方法执行方法体中最后一条语句后，并经过有执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。</p>
<p>没有可以强制线程终止的方法，然而，interrupt方法可以用来请求终止线程。</p>
<p>当对线程调用interrupt方法时，线程的中断状态将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时检查这个标志，以判断线程是否被中断。</p>
<p>要想弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用isInterrupted方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupt())&#123;</div><div class="line">    do more work</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>但是如果线程被阻塞，就无法检测中断状态，这是产生InterruptException异常的地方。当在一个被阻塞的线程(调用sleep或wait)上调用interrupt方式时，阻塞调用将会被InterruptException异常中断。</p>
<p>没有任何语言方面的需求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。重要的线程应该处理完异常后继续执行而不理会中断。但是，普遍的情况是，线程简单地将中断作为一个终止的请求。</p>
<p>Interrupted方法是一个静态方法，它检测当前的线程是否中断。而且，调用interrupted方法会清除该线程的中断状态(将当前线程的中断状态重置为false)。isInterrupted方法是一个实例方法，可以用来检验是否有线程被中断。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程可以有6种状态：</p>
<ol>
<li>New(新创建)</li>
<li>Runnable(可运行)</li>
<li>Blocked(被阻塞)</li>
<li>Waiting(等待)</li>
<li>Timed waiting(计时等待)</li>
<li>Terminated(被终止)</li>
</ol>
<p>要想确定一个线程的当前状态，可调用getState方法。</p>
<h3 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h3><p>当用new操作符创建一个新线程时，该线程还没有开始运行。这意味着它的状态是new。当一个线程处于被创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。</p>
<h3 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h3><p>一旦调用start方法，线程处于runnable状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供的运行时间。</p>
<p>一旦一个线程开始运行，它不必始终保存运行。事实上，运行的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。</p>
<p>抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另外一个线程运行机会。当选择下一个线程是，操作系统会考虑线程的优先级。</p>
<p>协同式调度系统线程的执行时间由线程本身控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。一个线程只有在调用yield方法，或者被阻塞或等待时，线程才失去控制权。</p>
<p>在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行(这就是将这个状态称为可运行而不是运行)。</p>
<h3 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h3><p>当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。</p>
<ul>
<li>当一个线程试图获取一个内部的对象锁(而不是java.util.concurrent库中的锁)，而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。</li>
<li>当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是在等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。</li>
<li>有几个方法有一个超时参数。调用它们导致线程进入计时等待状态。这一状态将一致保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep和Object.wait、Thread.join等。</li>
</ul>
<h3 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h3><p>线程因如下两个原因之一而被终止：</p>
<ol>
<li>因为run方法正常退出而死亡。</li>
<li>因为一个没有捕获的异常终止了run方法而意外死亡。</li>
</ol>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>Java线程优先级是高度依赖系统的。当虚拟机依赖与宿主机平台的线程实现机制是，Java线程的优先级被映射到宿主机平台的优先级上。<br>如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>可以通过调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.setDaemon（<span class="keyword">true</span>）; <span class="comment">//这个方法必须在线程启动之前调用</span></div></pre></td></tr></table></figure><br>将线程转换为守护线程。守护线程的唯一是为其他线程提供服务。当只剩守护线程时，虚拟机就退出了，由于如果只剩守护线程，就没必要继续运行程序了。守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时刻甚至在一个操作中间发生中断。</p>
<h3 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h3><p>线程的run方法不能抛出任何被检测的异常，但是，不被检测的异常会导致线程终止。在这种情况下，线程就死亡了。</p>
<p>不需要任何catch子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。</p>
<p>可以为线程安装一个处理器。如果不安装默认的处理器，默认处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>根据各线程访问数据的顺序，可能会产生讹误的对象。这样一个情况通常称为竞争条件。</p>
<h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>有两种机制防止代码块受并发访问的干扰。Java语言提供一个synchronized关键字达到这一目的，并且Java SE5.0引入ReentrantLock类。synchronized关键字自动提供一个锁以及相关的“条件”，对于大多数需要显式锁的情况，这是很便利的。java.util.concurrent框架为这些继承机制提供了独立的类。用ReentrantLock保护代码块的基本结构如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">myLock.lock();</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">    ...</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">    myLock.unLock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这一结构确保任何时刻中有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。</p>
<p>锁是可以重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同方法的锁的方法。</p>
<h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>通常，线程进入临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得一个锁但是却不能做有用工作的线程。</p>
<p>一个锁对象可以有一个或多个相关的条件对象。可以使用newCondition方法获得一个条件对象。</p>
<p>等待获得锁的线程和调用await方法的线程存在本质上的不同。一旦一个线程调用await方法，它现在被阻塞了，并放弃了锁，进入该条件的等待集。当锁可用的时候，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的signalAll方法时为止。</p>
<p>signalAll方法重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们，同时，它们将试图重新进入该对象。一旦锁称为可用的，它们中的某个将从await调用返回，获得该锁并从被阻塞的地方继续执行。</p>
<p>此时，线程应该再次测试该条件。由于无法确保该条件被满足——signalAll方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检查该条件。</p>
<p>至关重要的是最终需要某个其他线程调用signAll方法。当一个线程调用await时，它没有办法重新激活自身。它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不再运行了。这导致死锁现象。如果所有其他线程被阻塞，最后一个活动线程在解除其他线程的阻塞状态之前就调用了await方法，那么它也被阻塞。没有任何线程可以解除其他线程的阻塞，那么程序就挂起了。</p>
<p>调用signalAll不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问。</p>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>锁和条件的关键之处：</p>
<ul>
<li>锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。</li>
<li>锁可以管理试图进入被保护代码段的线程。</li>
<li>锁可以拥有一个或多个相关的条件对象。</li>
<li>每个条件对象管理那些已经进入被保护的代码段但还不能运行的代码。</li>
</ul>
<p>Java中每一个对象都有一个内部锁。如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得对象的内部锁。</p>
<p>内部锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll/notify方法解除等待线程的阻塞状态。</p>
<p>将静态方法声明为synchronized也是合法的。如果调用这个方法，该方法获得相关的类内部的对象锁。</p>
<p>内部锁和条件存在一些局限。包括：</p>
<ol>
<li>不能中断一个正在试图获得锁的线程</li>
<li>视图获得锁时不能设定超时</li>
<li>每个锁仅有单一的条件，可能是不够的。</li>
</ol>
<h3 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h3><p>每一个Java对象有一个锁。线程可以调用同步方法获得锁。还有另外一种机制可以获得锁，通过进入一个同步阻塞。当线程进入如下形式的阻塞：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(obj)<span class="comment">//this is the syntax for a synchronized block</span></div><div class="line">&#123;</div><div class="line">    critical section</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>于是它获得obj的锁。</p>
<h3 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h3><ul>
<li>volatile关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另外一个线程并发更新的。</li>
<li>volatile变量不能提供原子性。</li>
</ul>
<h3 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h3><ul>
<li>还有一种情况可以安全地访问一个共享域，即这个域声明为final。</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul>
<li>假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为volatile。</li>
<li>java.util.concurrent.atomic包中有很多类使用了机器级指令(而不是使用锁)来保证其他操作的原子性。例如，AtomicInteger类提供了方法incrementAndGet和decrementAndGet，它们分别以原子方式将一个整数自增或自减。可以安全地使用AtomicInteger作为共享计数器而无须同步。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>Java编程语言没有任何东西可以避免或打破死锁现象。必须仔细设计程序以确保不会出现死锁。</li>
</ul>
<h3 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h3><p>有时要避免共享变量，使用ThreadLocal辅助类为各个线程提供各自的实例。</p>
<p>要为每个线程构造一个实例，可以使用以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormat=</div><div class="line">    <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</div><div class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br>要访问具体的格式化方法，可以调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String dateStamp=dateFormat.get().format(<span class="keyword">new</span> Date());</div></pre></td></tr></table></figure><br>在多个线程中生成随机数也存在类似的问题。java.util.Romdom类是线程安全的。但是如果多个线程需要等待一个共享的随机数生成器，这会很低效。<br>可以使用ThreadLocal辅助类为各个线程提供一个单独的生成器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> random=ThreadLocalRandom.current().nextInt(upperBound);</div></pre></td></tr></table></figure><br>ThreadLocalRandom.current()调用会返回特定于当前线程的Romdom类实例。</p>
<h3 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h3><p>线程在调用lock方法来获得另外一个线程的持有的锁时候，很可能发生阻塞。应该更谨慎地申请锁。tryLock方法试图申请一个锁，在成功获得锁后返回true，否则，立即返回false，而且线程可以立即离开去做其他事情。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(myLock.tryLock())</div><div class="line">    <span class="keyword">try</span>&#123;...&#125;</div><div class="line">    <span class="keyword">finally</span>&#123;myLock.unLock();&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="comment">//do something else</span></div></pre></td></tr></table></figure><br>可以调用tryLock时，使用超时参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(myLock.tryLock(<span class="number">100</span>,TimeUnit.MILLISECONDS));</div></pre></td></tr></table></figure><br>lock方法不能中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁，那么，lock方法就无法终止。<br>然而，如果调用带有超时参数的tryLock，那么如果线程在等待期间被中断，将会抛出异常。这是一个有用的特性，因为允许程序打破死锁。</p>
<h3 id="读-写锁"><a href="#读-写锁" class="headerlink" title="读/写锁"></a>读/写锁</h3><p>java.util.concurrent.locks包定义了两个锁类：ReentrantLock类和ReentrantReadWriteLock类。如果很多线程从一个数据结构读取数据而很少线程修改其中的数据的话，后者是十分有用的。允许读者线程共享访问是合适的，写者线程依然是互斥访问的。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>对于许多多线程问题，可以通过使用一个或多个队列将其形式化。生产者线程向队列中插入元素，消费者线程则取出它们。</p>
<p>当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列导致线程阻塞。队列会自动地平衡负载。</p>
<p>java.util.concurrent包提供了阻塞队列的几个变种。默认情况下，LinkedBlockingQueue的容量是没有上边界的，但是也可以选择指定最大容量。LinkedBlockingDeque是一个双端版本。ArrayBlockingQueue在构造时需要指定容量，并且有一个可选的参数来直到是否需要公平性。PriorityBlockingQueue是一个带优先级的队列，而不是先进先出队列。</p>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><p>可以通过提供锁来保护共享数据结构，但是选择线程安全的实现作为替代可能更容易些。</p>
<h3 id="高效的映射表、集合和队列"><a href="#高效的映射表、集合和队列" class="headerlink" title="高效的映射表、集合和队列"></a>高效的映射表、集合和队列</h3><ul>
<li>java.util.concurrent包提供了映射表、有许集和队列的高效实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue。</li>
<li>这些集合使用了复杂的算法，通过允许并发访问数据结构的不同部分来使竞争极小化。</li>
<li>集合返回弱一致性的迭代器。这意味着迭代器不一定能反映出它们被构造之后的所有修改。</li>
</ul>
<h3 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h3><ul>
<li>CopyOnWriteArrayList和CopyOnWriteArrayList是线程安全的集合，其中所有的修改线程对底层数组进行复制。如果在集合上进行迭代的线程数超过修改线程数，这样的安排是很有用的。当构建一个迭代器的时候，它包含一个对当前数组的引用。如果数组后来被修改了，迭代器仍然引用旧数组，但是，集合的数组已经被替换的。因而，旧的迭代器拥有一致的视图，访问它无须任何同步开销。</li>
</ul>
<h3 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h3><p>Vertor和Hashtable类提供了线程安全的动态数组和散列表的实现。现在这些类被弃用了，取而代之的是ArrayList和HashMap类。这些类不是线程安全的，而集合库中提供了不同的机制。任何集合可以通过使用同步包装器变成线程安全的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;E&gt; synchArrayList=Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</div><div class="line">Map&lt;K,V&gt; synchHashMap=Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;K,V&gt;());</div></pre></td></tr></table></figure><br>如果在另一个线程可能进行修改时要对集合进行迭代，仍需要使用锁定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(synchHashMap)&#123;</div><div class="line">    Itertor&lt;K&gt; iter=synchHashMap.keySet().iterator();</div><div class="line">    <span class="keyword">while</span>(iter.hasNext())...;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>如果使用了“for each”循环必须使用同样的代码，因为循环使用了迭代器。如果在迭代过程中，别的线程修改集合，迭代器会失效，抛出异常。同步仍然是需要的，因此并发的修改可以被可靠地检测出来。</p>
<p>最好使用java.util.concurrent包中定义的集合，不使用同步包装器中的。</p>
<h2 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h2><ul>
<li>Runnable封装一个异步运行的任务，可以把它想象成为一个没有参数和返回值的异步方法，Callable域Runnable类似，但是有返回值。Callable接口是一个参数化的类型，只有一个方法call。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>          
参数类型是返回值的类型。例如Callable<integet>表示一个最终返回Integer对象的异步计算。</integet></li>
<li>Future保存异步计算的结果。可以启动一个计算，将Future对象交给某个线程，然后忘掉他。Future对象的所有者在结果计算好之后就可以获得它。</li>
</ul>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>构建一个新的线程是有一定代价的，因为涉及与操作系统的交互。如果程序中创建了大量生命周期很短的线程，应该使用线程池。一个线程池包含许多准备运行的空闲线程。将Runnable对象交给线程池，就会有一个线程调用run方法。当run方法退出 时，线程不会死亡，而是在池中准备为下一个请求线程提供服务。</p>
<p>另一个使用线程池的理由是减少并发线程的数目。创建大量线程会大大降低性能甚至使虚拟机崩溃。如果有一个会创建许多线程的算法，应该使用一个线程数“固定的”线程池以限制并发线程的总数。</p>
<p>执行器类有许多静态工厂方法用来构建线程池。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>newCachedThreadPool方法构建了一个线程池，对于每个任务，如果有空闲线程可用，立即让它执行任务，如果没有可用的空闲线程，则创建一个新线程。</li>
<li>newFixedThreadPool方法构建一个具有固定大小的线程池。如果提交的任务数多于空闲的线程数，那么把得不到服务的任务放置到队列中。当其他任务完成以后再运行它们。</li>
<li>newSingleThreadExecutor是一个退化了的大小为1的线程池：有一个线程执行提交的任务，一个接一个。</li>
</ul>
<p>当用完一个线程池的时候，调用shutdown。该方法启动该池的关闭队列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡。另一种方法是调用shutdownNow，该池取消尚开始的所有任务并试图中断正在运行的线程。</p>

  </div>
  <footer class="article-footer">
    

    

  </footer>
</article>


  <link rel="stylesheet" href="http://static.duoshuo.com/styles/embed.default.css?349d9313.css">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2016/08/07/Java笔记-多线程/" data-title="Java笔记-多线程" data-url="/2016/08/07/Java笔记-多线程/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
    var duoshuoQuery = {
      short_name: "SION"
    };
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';
      ds.async = true;
      ds.src = (document.location.protocol == 'https:'
        ? 'https:'
        : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->






          <div class="main-footer">
  
    © 2016 Be Level5 Coder - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
